From: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
Date: Tue, 28 Dec 2021 23:05:32 +0100
Subject: Use USE_SWAPCONTEXT on IA64.

On IA64 the use of setjmp()/ longjmp() does not properly save the
state of the register stack engine (RSE) and requires extra care.
The use of it in the async interface led to a failure in the
test_async.t test since its introduction in 1.1.0 series.

Instead of properly adding the needed assembly bits here use the
swapcontext() function which properly saves the whole context.

Signed-off-by: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
---
 crypto/async/arch/async_posix.h | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/crypto/async/arch/async_posix.h b/crypto/async/arch/async_posix.h
index db42a018806f..a74c3fbe1a17 100644
--- a/crypto/async/arch/async_posix.h
+++ b/crypto/async/arch/async_posix.h
@@ -25,12 +25,14 @@
 #  define ASYNC_POSIX
 #  define ASYNC_ARCH
 
-#  ifdef __CET__
+#  if defined(__CET__) || defined(__ia64__)
 /*
  * When Intel CET is enabled, makecontext will create a different
  * shadow stack for each context.  async_fibre_swapcontext cannot
  * use _longjmp.  It must call swapcontext to swap shadow stack as
  * well as normal stack.
+ * On IA64 the register stack engine is not saved across setjmp/longjmp. Here
+ * swapcontext() performs correctly.
  */
 #   define USE_SWAPCONTEXT
 #  endif
