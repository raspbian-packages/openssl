From: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
Date: Sat, 4 Jun 2022 13:01:47 +0200
Subject: Update to openssl-3.0 HEAD

Update to commit
   47d8a1cb53e90 ("Change the SCT issuer key to RSA 2048")

Signed-off-by: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
---
 Configurations/10-main.conf                        |   8 +
 Configurations/descrip.mms.tmpl                    |   3 +-
 Configurations/gentemplate.pm                      |  11 +-
 Configurations/unix-Makefile.tmpl                  |   3 +-
 Configurations/windows-makefile.tmpl               |   9 +-
 Configure                                          |  78 ++++-
 NEWS.md                                            |   3 +-
 apps/dhparam.c                                     |  12 +-
 apps/dsaparam.c                                    |   2 +-
 apps/ec.c                                          |   2 +-
 apps/ecparam.c                                     |   2 +-
 apps/rsa.c                                         |   2 +-
 apps/s_client.c                                    |  15 +-
 apps/s_server.c                                    |  48 ++-
 apps/speed.c                                       |   8 +-
 build.info                                         |   6 +-
 configdata.pm.in                                   |  60 +++-
 crypto/aes/build.info                              |  16 +-
 crypto/bf/build.info                               |   6 +-
 crypto/bio/bio_sock.c                              |   4 +-
 crypto/bio/bio_sock2.c                             |  20 +-
 crypto/bio/bss_conn.c                              |  15 +-
 crypto/bn/bn_nist.c                                |  33 +-
 crypto/bn/build.info                               |  18 +-
 crypto/build.info                                  |   8 +-
 crypto/camellia/build.info                         |   6 +-
 crypto/cast/build.info                             |   6 +-
 crypto/chacha/build.info                           |   7 +-
 crypto/cmac/cmac.c                                 |   4 +-
 crypto/cms/cms_dh.c                                |   2 +-
 crypto/cms/cms_ec.c                                |   4 +-
 crypto/cms/cms_smime.c                             |   2 +-
 crypto/conf/conf_mod.c                             | 106 +++++-
 crypto/context.c                                   |   3 +-
 crypto/core_algorithm.c                            | 103 ++++--
 crypto/core_fetch.c                                |  73 +++--
 crypto/crmf/crmf_lib.c                             |   6 +
 crypto/ct/ct_log.c                                 |   2 +-
 crypto/ctype.c                                     | 143 +++-----
 crypto/des/build.info                              |  10 +-
 crypto/dh/dh_ameth.c                               |  11 +-
 crypto/ec/build.info                               |   4 +-
 crypto/ec/ec_asn1.c                                |  10 +
 crypto/ec/ec_key.c                                 |   3 +-
 crypto/ec/ecx_meth.c                               |  40 +++
 crypto/encode_decode/decoder_lib.c                 |  13 +-
 crypto/encode_decode/decoder_meth.c                |  19 ++
 crypto/encode_decode/encoder_meth.c                |  19 ++
 crypto/err/err.c                                   |  35 +-
 crypto/evp/evp_enc.c                               |   2 +-
 crypto/evp/evp_fetch.c                             |  16 +-
 crypto/evp/evp_lib.c                               |   5 +
 crypto/evp/p_dec.c                                 |   8 +-
 crypto/evp/p_enc.c                                 |   8 +-
 crypto/evp/p_lib.c                                 |   4 +-
 crypto/evp/p_open.c                                |   2 +-
 crypto/evp/pmeth_lib.c                             |   2 -
 crypto/init.c                                      |  14 +-
 crypto/md5/build.info                              |   4 +-
 crypto/modes/build.info                            |   4 +-
 crypto/o_str.c                                     |  26 ++
 crypto/perlasm/x86asm.pl                           |   2 +
 crypto/pkcs7/pk7_doit.c                            |   2 +-
 crypto/pkcs7/pk7_lib.c                             |   4 +-
 crypto/pkcs7/pk7_smime.c                           |   4 +-
 crypto/poly1305/asm/poly1305-ia64.S                | 365 +++++++++++++++++++++
 crypto/poly1305/asm/poly1305-ia64.s                | 365 ---------------------
 crypto/poly1305/build.info                         |   7 +-
 crypto/property/property.c                         | 122 +++++--
 crypto/provider_child.c                            |  22 +-
 crypto/provider_core.c                             | 109 ++++--
 crypto/rand/rand_egd.c                             |   6 +-
 crypto/rc4/build.info                              |   6 +-
 crypto/rc5/build.info                              |   6 +-
 crypto/ripemd/build.info                           |   6 +-
 crypto/rsa/rsa_ameth.c                             |   2 +-
 crypto/rsa/rsa_lib.c                               |   6 +-
 crypto/sha/build.info                              |  14 +-
 crypto/store/store_meth.c                          |  19 ++
 crypto/ui/ui_util.c                                |   2 +-
 crypto/whrlpool/build.info                         |   6 +-
 crypto/x509/v3_addr.c                              |   2 +-
 crypto/x509/x509_cmp.c                             |   4 +-
 crypto/x509/x_crl.c                                |  12 +-
 doc/internal/man3/OSSL_METHOD_STORE.pod            |  18 +-
 doc/internal/man3/ossl_provider_new.pod            |   8 +-
 doc/man1/openssl-s_client.pod.in                   |   1 +
 doc/man1/openssl-s_server.pod.in                   |   1 -
 doc/man3/BIO_ctrl.pod                              |   8 +-
 doc/man3/DSA_sign.pod                              |   2 +-
 doc/man3/ECDSA_SIG_new.pod                         |   4 +-
 doc/man3/EC_GROUP_copy.pod                         |   5 +-
 doc/man3/EVP_DigestSignInit.pod                    |   4 +-
 doc/man3/EVP_DigestVerifyInit.pod                  |   4 +-
 doc/man3/EVP_PKEY_check.pod                        |  12 +
 doc/man3/EVP_PKEY_decrypt.pod                      |   2 +-
 doc/man3/EVP_PKEY_encrypt.pod                      |   2 +-
 doc/man3/EVP_PKEY_gettable_params.pod              |   2 +-
 doc/man3/OSSL_CRMF_MSG_set0_validity.pod           |   6 +-
 doc/man3/OSSL_PARAM_BLD.pod                        |   2 +-
 doc/man3/X509_STORE_CTX_get_error.pod              |   2 +-
 doc/man7/EVP_KDF-PBKDF2.pod                        |   2 +-
 doc/man7/EVP_PKEY-DH.pod                           |  65 +++-
 doc/man7/EVP_PKEY-DSA.pod                          |  18 +-
 doc/man7/EVP_PKEY-EC.pod                           |  22 +-
 doc/man7/EVP_PKEY-FFC.pod                          |   2 +-
 doc/man7/EVP_PKEY-RSA.pod                          |  20 ++
 doc/man7/OSSL_PROVIDER-FIPS.pod                    |  10 +-
 doc/man7/OSSL_PROVIDER-default.pod                 |   2 +
 doc/man7/fips_module.pod                           |   2 +-
 doc/man7/migration_guide.pod                       |   4 +-
 doc/man7/provider-keymgmt.pod                      |   4 +-
 e_os.h                                             |  20 ++
 engines/build.info                                 |   4 +-
 engines/e_loader_attic.c                           |   4 +-
 include/crypto/ctype.h                             |  15 +-
 include/crypto/decoder.h                           |   2 +
 include/crypto/encoder.h                           |  10 +-
 include/crypto/evp.h                               |   4 +-
 include/crypto/store.h                             |   2 +
 include/internal/core.h                            |   5 +-
 include/internal/property.h                        |   4 +-
 include/internal/provider.h                        |   7 +-
 include/openssl/bio.h.in                           |   4 +-
 providers/build.info                               |  13 +
 providers/fips/fipsprov.c                          |  38 +--
 providers/fips/self_test_kats.c                    |   8 +-
 .../implementations/ciphers/cipher_blowfish.c      |   4 +-
 .../implementations/include/prov/implementations.h |   4 +-
 providers/implementations/kdfs/krb5kdf.c           |   4 +-
 providers/implementations/macs/gmac_prov.c         |   4 +-
 providers/legacyprov.c                             |   4 +-
 ssl/record/rec_layer_d1.c                          |   6 +-
 ssl/record/ssl3_record.c                           |   2 +-
 ssl/record/tls_pad.c                               |  14 +-
 ssl/s3_lib.c                                       |   4 +-
 ssl/ssl_conf.c                                     |   4 +-
 ssl/ssl_init.c                                     |  14 +-
 ssl/ssl_rsa.c                                      |  10 +-
 ssl/statem/statem_clnt.c                           |  14 +-
 ssl/t1_enc.c                                       |  14 +-
 ssl/t1_lib.c                                       |  16 +-
 ssl/tls13_enc.c                                    |   6 +-
 ssl/tls_srp.c                                      |   4 +-
 test/acvp_test.c                                   |  30 +-
 test/aesgcmtest.c                                  |   2 +-
 test/bad_dtls_test.c                               |   2 +-
 test/certs/embeddedSCTs1.pem                       |  17 +-
 test/certs/embeddedSCTs1.sct                       |  10 +-
 test/certs/embeddedSCTs1_issuer-key.pem            |  38 ++-
 test/certs/embeddedSCTs1_issuer.pem                |  35 +-
 test/drbgtest.c                                    |   2 +-
 test/ecdsatest.c                                   |   2 +-
 test/evp_extra_test.c                              |  60 +++-
 test/evp_extra_test2.c                             |  37 +++
 test/evp_libctx_test.c                             |   2 +-
 test/evp_pkey_provided_test.c                      |  48 +--
 test/evp_test.c                                    |  24 +-
 test/exptest.c                                     |   6 +-
 test/fake_rsaprov.c                                |  38 +++
 test/localetest.c                                  |  30 +-
 test/provider_pkey_test.c                          |  61 ++++
 test/ssl-tests/12-ct.cnf.in                        |   8 +-
 test/ssl-tests/17-renegotiate.cnf                  | 339 ++++++++++---------
 test/ssl-tests/17-renegotiate.cnf.in               |  19 +-
 test/ssl_old_test.c                                |  33 +-
 test/threadstest.c                                 | 109 ++++++
 test/uitest.c                                      |   4 +-
 test/wpackettest.c                                 |   2 +-
 util/markdownlint.rb                               |   1 +
 util/mkdef.pl                                      |   6 +-
 util/perl/OpenSSL/config.pm                        |   1 +
 172 files changed, 2369 insertions(+), 1310 deletions(-)
 create mode 100644 crypto/poly1305/asm/poly1305-ia64.S
 delete mode 100644 crypto/poly1305/asm/poly1305-ia64.s

diff --git a/Configurations/10-main.conf b/Configurations/10-main.conf
index 617ad2e65655..096d53283890 100644
--- a/Configurations/10-main.conf
+++ b/Configurations/10-main.conf
@@ -1062,6 +1062,14 @@ my %targets = (
         perlasm_scheme   => "elf",
     },
 
+    "BSD-aarch64" => {
+        inherit_from     => [ "BSD-generic64" ],
+        lib_cppflags     => add("-DL_ENDIAN"),
+        bn_ops           => "SIXTY_FOUR_BIT_LONG",
+        asm_arch         => 'aarch64',
+        perlasm_scheme   => "linux64",
+    },
+
     # riscv64 below refers to contemporary RISCV Architecture
     # specifications,
     "BSD-riscv64" => {
diff --git a/Configurations/descrip.mms.tmpl b/Configurations/descrip.mms.tmpl
index c202bd44319f..b7d1df259280 100644
--- a/Configurations/descrip.mms.tmpl
+++ b/Configurations/descrip.mms.tmpl
@@ -549,6 +549,7 @@ clean : libclean
         - DELETE []vmsconfig.pm;*
 
 distclean : clean
+        - DELETE [.include.openssl]configuration.h;*
         - DELETE configdata.pm;*
         - DELETE descrip.mms;*
 
@@ -981,7 +982,7 @@ EOF
               ? '' : ' --case-insensitive';
           return <<"EOF";
 $target : $gen0 $deps $mkdef
-	\$(PERL) $mkdef$ord_ver --ordinals $gen0 --name $ord_name "--OS" "VMS"$case_insensitive > $target
+	\$(PERL) $mkdef$ord_ver --type $args{intent} --ordinals $gen0 --name $ord_name "--OS" "VMS"$case_insensitive > $target
 EOF
       } elsif (platform->isasm($args{src})) {
           #
diff --git a/Configurations/gentemplate.pm b/Configurations/gentemplate.pm
index a02b19a68810..3fd5f675c9c8 100644
--- a/Configurations/gentemplate.pm
+++ b/Configurations/gentemplate.pm
@@ -56,7 +56,8 @@ sub emit {
     my $fh = $self->{output};
 
     die "No name?" unless $name;
-    print $fh "{-\n ", $name, '(', dump_data(\%opts), ');', " \n-}";
+    print $fh "{-\n ", $name, '(', dump_data(\%opts), ');', " \n-}"
+        unless defined $opts{attrs}->{skip};
 }
 
 my $debug_resolvedepends = $ENV{BUILDFILE_DEBUG_DEPENDS};
@@ -200,7 +201,7 @@ sub dogenerate {
     my $self = shift;
     my $src = shift;
     # Safety measure
-    return "" unless defined $self->{info}->{generate}->{$_};
+    return "" unless defined $self->{info}->{generate}->{$src};
     return "" if $cache{$src};
     my $obj = shift;
     my $bin = shift;
@@ -209,6 +210,7 @@ sub dogenerate {
         die "$src is generated by Configure, should not appear in build file\n"
             if ref $self->{info}->{generate}->{$src} eq "";
         my $script = $self->{info}->{generate}->{$src}->[0];
+        my %attrs = %{$self->{info}->{attributes}->{generate}->{$src} // {}};
         $self->emit('generatesrc',
              src => $src,
              product => $bin,
@@ -220,10 +222,15 @@ sub dogenerate {
                        defined $bin ? @{$self->{info}->{includes}->{$bin} // []} : () ],
              defs => [ defined $obj ? @{$self->{info}->{defines}->{$obj} // []} : (),
                        defined $bin ? @{$self->{info}->{defines}->{$bin} // []} : () ],
+             attrs => { %attrs },
              %opts);
         foreach (@{$self->{info}->{depends}->{$src} // []}) {
             $self->dogenerate($_, $obj, $bin, %opts);
         }
+        # The generator itself may be is generated
+        if ($self->{info}->{generate}->{$script}) {
+            $self->dogenerate($script, $obj, $bin, %opts);
+        }
     }
     $cache{$src} = 1;
 }
diff --git a/Configurations/unix-Makefile.tmpl b/Configurations/unix-Makefile.tmpl
index 39194f13696f..4ee148fed7e5 100644
--- a/Configurations/unix-Makefile.tmpl
+++ b/Configurations/unix-Makefile.tmpl
@@ -595,6 +595,7 @@ clean: libclean
 	-find . -type l \! -name '.*' -exec $(RM) {} \;
 
 distclean: clean
+	$(RM) include/openssl/configuration.h
 	$(RM) configdata.pm
 	$(RM) Makefile
 
@@ -1549,7 +1550,7 @@ EOF
           my $ord_name = $args{generator}->[1] || $args{product};
           return <<"EOF";
 $target: $gen0 $deps \$(SRCDIR)/util/mkdef.pl
-	\$(PERL) \$(SRCDIR)/util/mkdef.pl$ord_ver --ordinals $gen0  --name $ord_name --OS $mkdef_os > $target
+	\$(PERL) \$(SRCDIR)/util/mkdef.pl$ord_ver --type $args{intent} --ordinals $gen0  --name $ord_name --OS $mkdef_os > $target
 EOF
       } elsif (platform->isasm($args{src})) {
           #
diff --git a/Configurations/windows-makefile.tmpl b/Configurations/windows-makefile.tmpl
index 2167180e144a..47c10d79df23 100644
--- a/Configurations/windows-makefile.tmpl
+++ b/Configurations/windows-makefile.tmpl
@@ -478,6 +478,7 @@ clean: libclean
 	-rd /Q /S test\test-runs
 
 distclean: clean
+	-del /Q /F include\openssl\configuration.h
 	-del /Q /F configdata.pm
 	-del /Q /F makefile
 
@@ -744,7 +745,7 @@ EOF
               $args{generator}->[1] || platform->dsoname($args{product});
           return <<"EOF";
 $target: $gen0 $deps $mkdef
-	"\$(PERL)" $mkdef$ord_ver --ordinals $gen0 --name $ord_name --OS windows > $target
+	"\$(PERL)" "$mkdef"$ord_ver --type $args{intent} --ordinals $gen0 --name $ord_name --OS windows > $target
 EOF
       } elsif (platform->isasm($args{src})) {
           #
@@ -760,7 +761,7 @@ EOF
 
           my $generator;
           if ($gen0 =~ /\.pl$/) {
-              $generator = '"$(PERL)"'.$gen_incs.' '.$gen0.$gen_args
+              $generator = '"$(PERL)"'.$gen_incs.' "'.$gen0.'"'.$gen_args
                   .' "$(PERLASM_SCHEME)"'.$incs.' '.$cppflags.$defs.' $(PROCESSSOR)';
           } elsif ($gen0 =~ /\.S$/) {
               $generator = undef;
@@ -817,7 +818,7 @@ EOF
           $gen0 = platform->bin($gen0);
           return <<"EOF";
 $args{src}: $gen0 $deps "\$(BLDDIR)\\util\\wrap.pl"
-	"\$(PERL)" "\$(BLDDIR)\\util\\wrap.pl" $gen0$gen_args > \$@
+	"\$(PERL)" "\$(BLDDIR)\\util\\wrap.pl" "$gen0"$gen_args > \$@
 EOF
       } else {
           #
@@ -825,7 +826,7 @@ EOF
           #
           return <<"EOF";
 $args{src}: "$gen0" $deps
-	"\$(PERL)"$gen_incs $gen0$gen_args > \$@
+	"\$(PERL)"$gen_incs "$gen0"$gen_args > \$@
 EOF
       }
   }
diff --git a/Configure b/Configure
index 308086509ee7..09ae2417862a 100755
--- a/Configure
+++ b/Configure
@@ -17,6 +17,7 @@ use lib "$FindBin::Bin/util/perl";
 use File::Basename;
 use File::Spec::Functions qw/:DEFAULT abs2rel rel2abs splitdir/;
 use File::Path qw/mkpath/;
+use File::Compare qw(compare_text);
 use OpenSSL::fallback "$FindBin::Bin/external/perl/MODULES.txt";
 use OpenSSL::Glob;
 use OpenSSL::Template;
@@ -2211,9 +2212,10 @@ if ($builder eq "unified") {
                                 \$attributes{depends}, $+{ATTRIBS},
                                 tokenize($expand_variables->($+{VALUE})))
                          if !@skip || $skip[$#skip] > 0; },
-            qr/^\s* GENERATE ${index_re} \s* = \s* ${value_re} \s* $/x
+            qr/^\s* GENERATE ${index_re} ${attribs_re} \s* = \s* ${value_re} \s* $/x
             => sub { $push_to->(\%generate, $expand_variables->($+{INDEX}),
-                                undef, undef, $expand_variables->($+{VALUE}))
+                                \$attributes{generate}, $+{ATTRIBS},
+                                $expand_variables->($+{VALUE}))
                          if !@skip || $skip[$#skip] > 0; },
             qr/^\s* (?:\#.*)? $/x => sub { },
             "OTHERWISE" => sub { die "Something wrong with this line:\n$_\nat $sourced/$f" },
@@ -2381,6 +2383,10 @@ EOF
             $check_generate{$ddest}->{$generator[0]}++;
 
             $unified_info{generate}->{$ddest} = [ @generator ];
+            # Fix up associated attributes
+            $unified_info{attributes}->{generate}->{$ddest} =
+                $attributes{generate}->{$dest}->{$gen}
+                if defined $attributes{generate}->{$dest}->{$gen};
         }
 
         foreach (keys %depends) {
@@ -2771,7 +2777,7 @@ EOF
                                   keys %{$unified_info{htmldocs} // {}}),
                                  (map { @{$unified_info{mandocs}->{$_} // []} }
                                   keys %{$unified_info{mandocs} // {}}) ] );
-    foreach my $type (keys %loopinfo) {
+    foreach my $type (sort keys %loopinfo) {
         foreach my $product (@{$loopinfo{$type}}) {
             my %dirs = ();
             my $pd = dirname($product);
@@ -2792,7 +2798,7 @@ EOF
                 push @{$unified_info{dirinfo}->{$d}->{deps}}, $_
                     if $d ne $pd;
             }
-            foreach (keys %dirs) {
+            foreach (sort keys %dirs) {
                 push @{$unified_info{dirinfo}->{$_}->{products}->{$type}},
                     $product;
             }
@@ -2827,7 +2833,6 @@ my %template_vars = (
     user_crossable => \@user_crossable,
 );
 my $configdata_outname = 'configdata.pm';
-print "Creating $configdata_outname\n";
 open CONFIGDATA, ">$configdata_outname.new"
     or die "Trying to create $configdata_outname.new: $!";
 my $configdata_tmplname = cleanfile($srcdir, "configdata.pm.in", $blddir);
@@ -2843,19 +2848,60 @@ $configdata_tmpl->fill_in(
               ] }
 ) or die $Text::Template::ERROR;
 close CONFIGDATA;
-rename "$configdata_outname.new", $configdata_outname;
-if ($builder_platform eq 'unix') {
-    my $mode = (0755 & ~umask);
-    chmod $mode, 'configdata.pm'
-        or warn sprintf("WARNING: Couldn't change mode for 'configdata.pm' to 0%03o: %s\n",$mode,$!);
+
+# When using stat() on Windows, we can get it to perform better by avoid some
+# data.  This doesn't affect the mtime field, so we're not losing anything...
+${^WIN32_SLOPPY_STAT} = 1;
+
+my $update_configdata = 0;
+my $run_configdata = 0;
+if (-f $configdata_outname) {
+    my $Configure_mtime = (stat($0))[9];
+    my $configdata_mtime = (stat($configdata_outname))[9];
+
+    # If this script was updated after the last configdata.pm, or if
+    # configdata.pm.new differs from configdata.pm, we update configdata.pm
+    if ($configdata_mtime < $Configure_mtime
+        || compare_text("$configdata_outname.new", $configdata_outname) != 0) {
+        $update_configdata = 1;
+    } else {
+        # If nothing has changed, let's just drop the new one and pretend
+        # like nothing happened
+        unlink "$configdata_outname.new";
+
+        # We still run configdata.pm if one of the build file (Makefile) or
+        # the configuration header file are missing
+        $run_configdata =
+            !( -f $target{build_file} )
+            || !( -f catfile('include', 'openssl', 'configuration.h') );
+    }
+} else {
+    $update_configdata = 1;
 }
 
-print "Running $configdata_outname\n";
-my $perlcmd = (quotify("maybeshell", $config{PERL}))[0];
-my $cmd = "$perlcmd $configdata_outname";
-#print STDERR "DEBUG[run_dofile]: \$cmd = $cmd\n";
-system($cmd);
-exit 1 if $? != 0;
+if ($update_configdata) {
+    # If something did change, or there was no previous configdata.pm, we
+    # rename the new one, set permissions as needed, and run it.
+    rename "$configdata_outname.new", $configdata_outname;
+    if ($builder_platform eq 'unix') {
+        my $mode = (0755 & ~umask);
+        chmod $mode, 'configdata.pm'
+            or warn sprintf("WARNING: Couldn't change mode for 'configdata.pm' to 0%03o: %s\n",$mode,$!);
+    }
+    $run_configdata = 1;
+    print "Created $configdata_outname\n";
+}
+
+if ($run_configdata) {
+    print "Running $configdata_outname\n";
+    my $perlcmd = (quotify("maybeshell", $config{PERL}))[0];
+    my $cmd = "$perlcmd $configdata_outname";
+    #print STDERR "DEBUG[run_dofile]: \$cmd = $cmd\n";
+    system($cmd);
+    exit 1 if $? != 0;
+} else {
+    print "No changes in $configdata_outname, no need to run it\n";
+}
 
 $SIG{__DIE__} = $orig_death_handler;
 
diff --git a/NEWS.md b/NEWS.md
index f6903d200940..371bf60f15b9 100644
--- a/NEWS.md
+++ b/NEWS.md
@@ -111,7 +111,8 @@ OpenSSL 3.0
     RC4, RC5 and SEED cipher functions have been deprecated.
   * All of the low-level DH, DSA, ECDH, ECDSA and RSA public key functions
     have been deprecated.
-  * SSL 3, TLS 1.0, TLS 1.1, and DTLS 1.0 only work at security level 0.
+  * SSL 3, TLS 1.0, TLS 1.1, and DTLS 1.0 only work at security level 0,
+    except when RSA key exchange without SHA1 is used.
   * Added providers, a new pluggability concept that will replace the
     ENGINE API and ENGINE implementations.
 
diff --git a/apps/dhparam.c b/apps/dhparam.c
index 0e90698cd694..2742389bb377 100644
--- a/apps/dhparam.c
+++ b/apps/dhparam.c
@@ -181,6 +181,10 @@ int dhparam_main(int argc, char **argv)
     if (num) {
         const char *alg = dsaparam ? "DSA" : "DH";
 
+        if (infile != NULL) {
+            BIO_printf(bio_err, "Warning, input file %s ignored\n", infile);
+        }
+
         ctx = EVP_PKEY_CTX_new_from_name(NULL, alg, NULL);
         if (ctx == NULL) {
             BIO_printf(bio_err,
@@ -202,16 +206,16 @@ int dhparam_main(int argc, char **argv)
         }
 
         if (dsaparam) {
-            if (!EVP_PKEY_CTX_set_dsa_paramgen_bits(ctx, num)) {
+            if (EVP_PKEY_CTX_set_dsa_paramgen_bits(ctx, num) <= 0) {
                 BIO_printf(bio_err, "Error, unable to set DSA prime length\n");
                 goto end;
             }
         } else {
-            if (!EVP_PKEY_CTX_set_dh_paramgen_prime_len(ctx, num)) {
+            if (EVP_PKEY_CTX_set_dh_paramgen_prime_len(ctx, num) <= 0) {
                 BIO_printf(bio_err, "Error, unable to set DH prime length\n");
                 goto end;
             }
-            if (!EVP_PKEY_CTX_set_dh_paramgen_generator(ctx, g)) {
+            if (EVP_PKEY_CTX_set_dh_paramgen_generator(ctx, g) <= 0) {
                 BIO_printf(bio_err, "Error, unable to set generator\n");
                 goto end;
             }
@@ -314,7 +318,7 @@ int dhparam_main(int argc, char **argv)
             BIO_printf(bio_err, "Error, failed to check DH parameters\n");
             goto end;
         }
-        if (!EVP_PKEY_param_check(ctx)) {
+        if (EVP_PKEY_param_check(ctx) <= 0) {
             BIO_printf(bio_err, "Error, invalid parameters generated\n");
             goto end;
         }
diff --git a/apps/dsaparam.c b/apps/dsaparam.c
index 8025b8be67c8..82e4e2bd3a8c 100644
--- a/apps/dsaparam.c
+++ b/apps/dsaparam.c
@@ -172,7 +172,7 @@ int dsaparam_main(int argc, char **argv)
                        "Error, DSA key generation paramgen init failed\n");
             goto end;
         }
-        if (!EVP_PKEY_CTX_set_dsa_paramgen_bits(ctx, num)) {
+        if (EVP_PKEY_CTX_set_dsa_paramgen_bits(ctx, num) <= 0) {
             BIO_printf(bio_err,
                        "Error, DSA key generation setting bit length failed\n");
             goto end;
diff --git a/apps/ec.c b/apps/ec.c
index dcbef104eefe..c6ff6fdefc4e 100644
--- a/apps/ec.c
+++ b/apps/ec.c
@@ -232,7 +232,7 @@ int ec_main(int argc, char **argv)
             BIO_printf(bio_err, "unable to check EC key\n");
             goto end;
         }
-        if (!EVP_PKEY_check(pctx))
+        if (EVP_PKEY_check(pctx) <= 0)
             BIO_printf(bio_err, "EC Key Invalid!\n");
         else
             BIO_printf(bio_err, "EC Key valid.\n");
diff --git a/apps/ecparam.c b/apps/ecparam.c
index e93ecaea6a18..5d869cfd14f7 100644
--- a/apps/ecparam.c
+++ b/apps/ecparam.c
@@ -284,7 +284,7 @@ int ecparam_main(int argc, char **argv)
                 goto end;
         }
         pctx = EVP_PKEY_CTX_new_from_pkey(NULL, params_key, NULL);
-        if (pctx == NULL || !EVP_PKEY_param_check(pctx)) {
+        if (pctx == NULL || EVP_PKEY_param_check(pctx) <= 0) {
             BIO_printf(bio_err, "failed\n");
             goto end;
         }
diff --git a/apps/rsa.c b/apps/rsa.c
index c702f03354bb..4cc45c55332a 100644
--- a/apps/rsa.c
+++ b/apps/rsa.c
@@ -304,7 +304,7 @@ int rsa_main(int argc, char **argv)
         } else if (r == 0) {
             BIO_printf(bio_err, "RSA key not ok\n");
             ERR_print_errors(bio_err);
-        } else if (r == -1) {
+        } else if (r < 0) {
             ERR_print_errors(bio_err);
             goto end;
         }
diff --git a/apps/s_client.c b/apps/s_client.c
index 2b248be485a7..a9142386428d 100644
--- a/apps/s_client.c
+++ b/apps/s_client.c
@@ -703,7 +703,6 @@ typedef enum PROTOCOL_choice {
     PROTO_TELNET,
     PROTO_XMPP,
     PROTO_XMPP_SERVER,
-    PROTO_CONNECT,
     PROTO_IRC,
     PROTO_MYSQL,
     PROTO_POSTGRES,
@@ -986,7 +985,6 @@ int s_client_main(int argc, char **argv)
             break;
         case OPT_PROXY:
             proxystr = opt_arg();
-            starttls_proto = PROTO_CONNECT;
             break;
         case OPT_PROXY_USER:
             proxyuser = opt_arg();
@@ -2157,6 +2155,13 @@ int s_client_main(int argc, char **argv)
     sbuf_len = 0;
     sbuf_off = 0;
 
+    if (proxystr != NULL) {
+        /* Here we must use the connect string target host & port */
+        if (!OSSL_HTTP_proxy_connect(sbio, thost, tport, proxyuser, proxypass,
+                                     0 /* no timeout */, bio_err, prog))
+            goto shut;
+    }
+
     switch ((PROTOCOL_CHOICE) starttls_proto) {
     case PROTO_OFF:
         break;
@@ -2344,12 +2349,6 @@ int s_client_main(int argc, char **argv)
                 goto shut;
         }
         break;
-    case PROTO_CONNECT:
-        /* Here we must use the connect string target host & port */
-        if (!OSSL_HTTP_proxy_connect(sbio, thost, tport, proxyuser, proxypass,
-                                     0 /* no timeout */, bio_err, prog))
-            goto shut;
-        break;
     case PROTO_IRC:
         {
             int numeric;
diff --git a/apps/s_server.c b/apps/s_server.c
index e93cfa1e2c7a..45b2552d5634 100644
--- a/apps/s_server.c
+++ b/apps/s_server.c
@@ -2296,6 +2296,30 @@ static void print_stats(BIO *bio, SSL_CTX *ssl_ctx)
                SSL_CTX_sess_get_cache_size(ssl_ctx));
 }
 
+static long int count_reads_callback(BIO *bio, int cmd, const char *argp, size_t len,
+                                 int argi, long argl, int ret, size_t *processed)
+{
+    unsigned int *p_counter = (unsigned int *)BIO_get_callback_arg(bio);
+
+    switch (cmd) {
+    case BIO_CB_READ:  /* No break here */
+    case BIO_CB_GETS:
+        if (p_counter != NULL)
+            ++*p_counter;
+        break;
+    default:
+        break;
+    }
+
+    if (s_debug) {
+        BIO_set_callback_arg(bio, (char *)bio_s_out);
+        ret = (int)bio_dump_callback(bio, cmd, argp, len, argi, argl, ret, processed);
+        BIO_set_callback_arg(bio, (char *)p_counter);
+    }
+
+    return ret;
+}
+
 static int sv_body(int s, int stype, int prot, unsigned char *context)
 {
     char *buf = NULL;
@@ -2425,10 +2449,7 @@ static int sv_body(int s, int stype, int prot, unsigned char *context)
     SSL_set_accept_state(con);
     /* SSL_set_fd(con,s); */
 
-    if (s_debug) {
-        BIO_set_callback_ex(SSL_get_rbio(con), bio_dump_callback);
-        BIO_set_callback_arg(SSL_get_rbio(con), (char *)bio_s_out);
-    }
+    BIO_set_callback_ex(SSL_get_rbio(con), count_reads_callback);
     if (s_msg) {
 #ifndef OPENSSL_NO_SSL_TRACE
         if (s_msg == 2)
@@ -2706,8 +2727,25 @@ static int sv_body(int s, int stype, int prot, unsigned char *context)
              */
             if ((!async || !SSL_waiting_for_async(con))
                     && !SSL_is_init_finished(con)) {
-                i = init_ssl_connection(con);
+                /*
+                 * Count number of reads during init_ssl_connection.
+                 * It helps us to distinguish configuration errors from errors
+                 * caused by a client.
+                 */
+                unsigned int read_counter = 0;
 
+                BIO_set_callback_arg(SSL_get_rbio(con), (char *)&read_counter);
+                i = init_ssl_connection(con);
+                BIO_set_callback_arg(SSL_get_rbio(con), NULL);
+
+                /*
+                 * If initialization fails without reads, then
+                 * there was a fatal error in configuration.
+                 */
+                if (i <= 0 && read_counter == 0) {
+                    ret = -1;
+                    goto err;
+                }
                 if (i < 0) {
                     ret = 0;
                     goto err;
diff --git a/apps/speed.c b/apps/speed.c
index d252b41ca431..535e0f45c246 100644
--- a/apps/speed.c
+++ b/apps/speed.c
@@ -691,7 +691,7 @@ static EVP_CIPHER_CTX *init_evp_cipher_ctx(const char *ciphername,
         goto end;
     }
 
-    if (!EVP_CIPHER_CTX_set_key_length(ctx, keylen)) {
+    if (EVP_CIPHER_CTX_set_key_length(ctx, keylen) <= 0) {
         EVP_CIPHER_CTX_free(ctx);
         ctx = NULL;
         goto end;
@@ -3607,14 +3607,14 @@ static void multiblock_speed(const EVP_CIPHER *evp_cipher, int lengths_single,
         goto err;
     }
     key = app_malloc(keylen, "evp_cipher key");
-    if (!EVP_CIPHER_CTX_rand_key(ctx, key))
+    if (EVP_CIPHER_CTX_rand_key(ctx, key) <= 0)
         app_bail_out("failed to generate random cipher key\n");
     if (!EVP_EncryptInit_ex(ctx, NULL, NULL, key, NULL))
         app_bail_out("failed to set cipher key\n");
     OPENSSL_clear_free(key, keylen);
 
-    if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_MAC_KEY,
-                             sizeof(no_key), no_key))
+    if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_MAC_KEY,
+                             sizeof(no_key), no_key) <= 0)
         app_bail_out("failed to set AEAD key\n");
     if ((alg_name = EVP_CIPHER_get0_name(evp_cipher)) == NULL)
         app_bail_out("failed to get cipher name\n");
diff --git a/build.info b/build.info
index a70d1671f240..5a8421623b97 100644
--- a/build.info
+++ b/build.info
@@ -22,7 +22,6 @@ DEPEND[]=include/openssl/asn1.h \
          include/openssl/cmp.h \
          include/openssl/cms.h \
          include/openssl/conf.h \
-         include/openssl/configuration.h \
          include/openssl/crmf.h \
          include/openssl/crypto.h \
          include/openssl/ct.h \
@@ -49,7 +48,10 @@ GENERATE[include/openssl/bio.h]=include/openssl/bio.h.in
 GENERATE[include/openssl/cmp.h]=include/openssl/cmp.h.in
 GENERATE[include/openssl/cms.h]=include/openssl/cms.h.in
 GENERATE[include/openssl/conf.h]=include/openssl/conf.h.in
-GENERATE[include/openssl/configuration.h]=include/openssl/configuration.h.in
+# include/openssl/configuration.h is generated by configdata.pm
+# We still need this information for the FIPS module checksum, but the attribute
+# 'skip' ensures that nothing is actually done with it.
+GENERATE[include/openssl/configuration.h]{skip}=include/openssl/configuration.h.in
 GENERATE[include/openssl/crmf.h]=include/openssl/crmf.h.in
 GENERATE[include/openssl/crypto.h]=include/openssl/crypto.h.in
 GENERATE[include/openssl/ct.h]=include/openssl/ct.h.in
diff --git a/configdata.pm.in b/configdata.pm.in
index 14da489cd38f..bef90608463c 100644
--- a/configdata.pm.in
+++ b/configdata.pm.in
@@ -77,6 +77,7 @@ unless (caller) {
     use Getopt::Long;
     use File::Spec::Functions;
     use File::Basename;
+    use File::Compare qw(compare_text);
     use File::Copy;
     use Pod::Usage;
 
@@ -111,7 +112,6 @@ unless (caller) {
         use lib '{- sourcedir('Configurations') -}';
         use gentemplate;
 
-        print 'Creating ',$buildfile_template,"\n";
         open my $buildfile_template_fh, ">$buildfile_template"
             or die "Trying to create $buildfile_template: $!";
         foreach (@{$config{build_file_templates}}) {
@@ -120,6 +120,7 @@ unless (caller) {
         }
         gentemplate(output => $buildfile_template_fh, %gendata);
         close $buildfile_template_fh;
+        print 'Created ',$buildfile_template,"\n";
 
         use OpenSSL::Template;
 
@@ -131,11 +132,11 @@ use lib '{- $config{builddir} -}';
 use platform;
 _____
 
-        print 'Creating ',$buildfile,"\n";
+        my $tmpl;
         open BUILDFILE, ">$buildfile.new"
             or die "Trying to create $buildfile.new: $!";
-        my $tmpl = OpenSSL::Template->new(TYPE => 'FILE',
-                                          SOURCE => $buildfile_template);
+        $tmpl = OpenSSL::Template->new(TYPE => 'FILE',
+                                       SOURCE => $buildfile_template);
         $tmpl->fill_in(FILENAME => $_,
                        OUTPUT => \*BUILDFILE,
                        HASH => \%gendata,
@@ -148,6 +149,57 @@ _____
         close BUILDFILE;
         rename("$buildfile.new", $buildfile)
             or die "Trying to rename $buildfile.new to $buildfile: $!";
+        print 'Created ',$buildfile,"\n";
+
+        my $configuration_h =
+            catfile('include', 'openssl', 'configuration.h');
+        my $configuration_h_in =
+            catfile($config{sourcedir}, 'include', 'openssl', 'configuration.h.in');
+        open CONFIGURATION_H, ">${configuration_h}.new"
+            or die "Trying to create ${configuration_h}.new: $!";
+        $tmpl = OpenSSL::Template->new(TYPE => 'FILE',
+                                       SOURCE => $configuration_h_in);
+        $tmpl->fill_in(FILENAME => $_,
+                       OUTPUT => \*CONFIGURATION_H,
+                       HASH => \%gendata,
+                       PREPEND => $prepend,
+                       # To ensure that global variables and functions
+                       # defined in one template stick around for the
+                       # next, making them combinable
+                       PACKAGE => 'OpenSSL::safe')
+            or die $Text::Template::ERROR;
+        close CONFIGURATION_H;
+
+        # When using stat() on Windows, we can get it to perform better by
+        # avoid some data.  This doesn't affect the mtime field, so we're not
+        # losing anything...
+        ${^WIN32_SLOPPY_STAT} = 1;
+
+        my $update_configuration_h = 0;
+        if (-f $configuration_h) {
+            my $configuration_h_mtime = (stat($configuration_h))[9];
+            my $configuration_h_in_mtime = (stat($configuration_h_in))[9];
+
+            # If configuration.h.in was updated after the last configuration.h,
+            # or if configuration.h.new differs configuration.h, we update
+            # configuration.h
+            if ($configuration_h_mtime < $configuration_h_in_mtime
+                || compare_text("${configuration_h}.new", $configuration_h) != 0) {
+                $update_configuration_h = 1;
+            } else {
+                # If nothing has changed, let's just drop the new one and
+                # pretend like nothing happened
+                unlink "${configuration_h}.new"
+            }
+        } else {
+            $update_configuration_h = 1;
+        }
+
+        if ($update_configuration_h) {
+            rename("${configuration_h}.new", $configuration_h)
+                or die "Trying to rename ${configuration_h}.new to $configuration_h: $!";
+            print 'Created ',$configuration_h,"\n";
+        }
 
         exit(0);
     }
diff --git a/crypto/aes/build.info b/crypto/aes/build.info
index af362bcf6254..b250903fa6e2 100644
--- a/crypto/aes/build.info
+++ b/crypto/aes/build.info
@@ -2,9 +2,9 @@ LIBS=../../libcrypto
 
 $AESASM=aes_core.c aes_cbc.c
 IF[{- !$disabled{asm} -}]
-  $AESASM_x86=aes-586.s
+  $AESASM_x86=aes-586.S
   $AESDEF_x86=AES_ASM
-  $AESASM_x86_sse2=vpaes-x86.s aesni-x86.s
+  $AESASM_x86_sse2=vpaes-x86.S aesni-x86.S
   $AESDEF_x86_sse2=VPAES_ASM OPENSSL_IA32_SSE2
 
   $AESASM_x86_64=\
@@ -81,12 +81,12 @@ ENDIF
 
 GENERATE[aes-ia64.s]=asm/aes-ia64.S
 
-GENERATE[aes-586.s]=asm/aes-586.pl
-DEPEND[aes-586.s]=../perlasm/x86asm.pl
-GENERATE[vpaes-x86.s]=asm/vpaes-x86.pl
-DEPEND[vpaes-586.s]=../perlasm/x86asm.pl
-GENERATE[aesni-x86.s]=asm/aesni-x86.pl
-DEPEND[aesni-586.s]=../perlasm/x86asm.pl
+GENERATE[aes-586.S]=asm/aes-586.pl
+DEPEND[aes-586.S]=../perlasm/x86asm.pl
+GENERATE[vpaes-x86.S]=asm/vpaes-x86.pl
+DEPEND[vpaes-586.S]=../perlasm/x86asm.pl
+GENERATE[aesni-x86.S]=asm/aesni-x86.pl
+DEPEND[aesni-586.S]=../perlasm/x86asm.pl
 
 GENERATE[aes-x86_64.s]=asm/aes-x86_64.pl
 GENERATE[vpaes-x86_64.s]=asm/vpaes-x86_64.pl
diff --git a/crypto/bf/build.info b/crypto/bf/build.info
index 9fa818781866..0c32fedef8ef 100644
--- a/crypto/bf/build.info
+++ b/crypto/bf/build.info
@@ -2,7 +2,7 @@ LIBS=../../libcrypto
 
 $BFASM=bf_enc.c
 IF[{- !$disabled{asm} -}]
-  $BFASM_x86=bf-586.s
+  $BFASM_x86=bf-586.S
 
   # Now that we have defined all the arch specific variables, use the
   # appropriate one
@@ -21,5 +21,5 @@ IF[{- $disabled{'deprecated-3.0'} -}]
   SOURCE[../../providers/liblegacy.a]=$ALL
 ENDIF
 
-GENERATE[bf-586.s]=asm/bf-586.pl
-DEPEND[bf-586.s]=../perlasm/x86asm.pl ../perlasm/cbc.pl
+GENERATE[bf-586.S]=asm/bf-586.pl
+DEPEND[bf-586.S]=../perlasm/x86asm.pl ../perlasm/cbc.pl
diff --git a/crypto/bio/bio_sock.c b/crypto/bio/bio_sock.c
index b827c5b902b1..fef6934998a6 100644
--- a/crypto/bio/bio_sock.c
+++ b/crypto/bio/bio_sock.c
@@ -35,6 +35,8 @@ static int wsa_init_done = 0;
 #  include <unistd.h>
 #  if defined __VMS
 #   include <sys/socket.h>
+#  elif defined _HPUX_SOURCE
+#   include <sys/time.h>
 #  else
 #   include <sys/select.h>
 #  endif
@@ -400,7 +402,7 @@ int BIO_socket_wait(int fd, int for_read, time_t max_time)
         return 1;
 
     now = time(NULL);
-    if (max_time <= now)
+    if (max_time < now)
         return 0;
 
     FD_ZERO(&confds);
diff --git a/crypto/bio/bio_sock2.c b/crypto/bio/bio_sock2.c
index b6c95913ce6d..d1a44169bdeb 100644
--- a/crypto/bio/bio_sock2.c
+++ b/crypto/bio/bio_sock2.c
@@ -52,17 +52,6 @@ int BIO_socket(int domain, int socktype, int protocol, int options)
         ERR_raise(ERR_LIB_BIO, BIO_R_UNABLE_TO_CREATE_SOCKET);
         return INVALID_SOCKET;
     }
-# ifndef OPENSSL_NO_KTLS
-    {
-        /*
-         * The new socket is created successfully regardless of ktls_enable.
-         * ktls_enable doesn't change any functionality of the socket, except
-         * changing the setsockopt to enable the processing of ktls_start.
-         * Thus, it is not a problem to call it for non-TLS sockets.
-         */
-        ktls_enable(sock);
-    }
-# endif
 
     return sock;
 }
@@ -128,6 +117,15 @@ int BIO_connect(int sock, const BIO_ADDR *addr, int options)
         }
         return 0;
     }
+# ifndef OPENSSL_NO_KTLS
+    /*
+     * The new socket is created successfully regardless of ktls_enable.
+     * ktls_enable doesn't change any functionality of the socket, except
+     * changing the setsockopt to enable the processing of ktls_start.
+     * Thus, it is not a problem to call it for non-TLS sockets.
+     */
+    ktls_enable(sock);
+# endif
     return 1;
 }
 
diff --git a/crypto/bio/bss_conn.c b/crypto/bio/bss_conn.c
index d146c97b82a5..e71c05f96c41 100644
--- a/crypto/bio/bss_conn.c
+++ b/crypto/bio/bss_conn.c
@@ -188,6 +188,9 @@ static int conn_state(BIO *b, BIO_CONNECT *c)
             break;
 
         case BIO_CONN_S_BLOCKED_CONNECT:
+            /* wait for socket being writable, before querying BIO_sock_error */
+            if (BIO_socket_wait(b->num, 0, time(NULL)) == 0)
+                break;
             i = BIO_sock_error(b->num);
             if (i != 0) {
                 BIO_clear_retry_flags(b);
@@ -205,8 +208,18 @@ static int conn_state(BIO *b, BIO_CONNECT *c)
                 ERR_raise(ERR_LIB_BIO, BIO_R_NBIO_CONNECT_ERROR);
                 ret = 0;
                 goto exit_loop;
-            } else
+            } else {
                 c->state = BIO_CONN_S_OK;
+# ifndef OPENSSL_NO_KTLS
+                /*
+                 * The new socket is created successfully regardless of ktls_enable.
+                 * ktls_enable doesn't change any functionality of the socket, except
+                 * changing the setsockopt to enable the processing of ktls_start.
+                 * Thus, it is not a problem to call it for non-TLS sockets.
+                 */
+                ktls_enable(b->num);
+# endif
+            }
             break;
 
         case BIO_CONN_S_CONNECT_ERROR:
diff --git a/crypto/bn/bn_nist.c b/crypto/bn/bn_nist.c
index aea8a6e65d99..5b6d4e7e4dff 100644
--- a/crypto/bn/bn_nist.c
+++ b/crypto/bn/bn_nist.c
@@ -249,17 +249,28 @@ const BIGNUM *BN_get0_nist_prime_521(void)
     return &ossl_bignum_nist_p_521;
 }
 
-static void nist_cp_bn_0(BN_ULONG *dst, const BN_ULONG *src, int top, int max)
-{
-    int i;
-
-#ifdef BN_DEBUG
-    (void)ossl_assert(top <= max);
-#endif
-    for (i = 0; i < top; i++)
-        dst[i] = src[i];
-    for (; i < max; i++)
-        dst[i] = 0;
+/*
+ * To avoid more recent compilers (specifically clang-14) from treating this
+ * code as a violation of the strict aliasing conditions and omiting it, this
+ * cannot be declared as a function.  Moreover, the dst parameter cannot be
+ * cached in a local since this no longer references the union and again falls
+ * foul of the strict aliasing criteria.  Refer to #18225 for the initial
+ * diagnostics and llvm/llvm-project#55255 for the later discussions with the
+ * LLVM developers.  The problem boils down to if an array in the union is
+ * converted to a pointer or if it is used directly.
+ *
+ * This function was inlined regardless, so there is no space cost to be
+ * paid for making it a macro.
+ */
+#define nist_cp_bn_0(dst, src_in, top, max) \
+{                                           \
+    int ii;                                 \
+    const BN_ULONG *src = src_in;           \
+                                            \
+    for (ii = 0; ii < top; ii++)            \
+        (dst)[ii] = src[ii];                \
+    for (; ii < max; ii++)                  \
+        (dst)[ii] = 0;                      \
 }
 
 static void nist_cp_bn(BN_ULONG *dst, const BN_ULONG *src, int top)
diff --git a/crypto/bn/build.info b/crypto/bn/build.info
index 9330274aefad..abbe8577eac8 100644
--- a/crypto/bn/build.info
+++ b/crypto/bn/build.info
@@ -16,7 +16,7 @@ IF[{- !$disabled{asm} -}]
   # All variables are named in such a way that they can be "indexed" with
   # $target{asm_arch}
 
-  $BNASM_x86=bn-586.s co-586.s x86-mont.s x86-gf2m.s
+  $BNASM_x86=bn-586.S co-586.S x86-mont.S x86-gf2m.S
   # bn-586 is the only one implementing bn_*_part_words
   # => OPENSSL_BN_ASM_PART_WORDS
   $BNDEF_x86=OPENSSL_BN_ASM_PART_WORDS OPENSSL_BN_ASM_MONT OPENSSL_BN_ASM_GF2m
@@ -127,14 +127,14 @@ DEFINE[../../providers/libcommon.a]=$BNDEF
 
 INCLUDE[bn_exp.o]=..
 
-GENERATE[bn-586.s]=asm/bn-586.pl
-DEPEND[bn-586.s]=../perlasm/x86asm.pl
-GENERATE[co-586.s]=asm/co-586.pl
-DEPEND[co-586.s]=../perlasm/x86asm.pl
-GENERATE[x86-mont.s]=asm/x86-mont.pl
-DEPEND[x86-mont.s]=../perlasm/x86asm.pl
-GENERATE[x86-gf2m.s]=asm/x86-gf2m.pl
-DEPEND[x86-gf2m.s]=../perlasm/x86asm.pl
+GENERATE[bn-586.S]=asm/bn-586.pl
+DEPEND[bn-586.S]=../perlasm/x86asm.pl
+GENERATE[co-586.S]=asm/co-586.pl
+DEPEND[co-586.S]=../perlasm/x86asm.pl
+GENERATE[x86-mont.S]=asm/x86-mont.pl
+DEPEND[x86-mont.S]=../perlasm/x86asm.pl
+GENERATE[x86-gf2m.S]=asm/x86-gf2m.pl
+DEPEND[x86-gf2m.S]=../perlasm/x86asm.pl
 
 GENERATE[sparcv9a-mont.S]=asm/sparcv9a-mont.pl
 INCLUDE[sparcv9a-mont.o]=..
diff --git a/crypto/build.info b/crypto/build.info
index efca6cc10545..c04db5591120 100644
--- a/crypto/build.info
+++ b/crypto/build.info
@@ -14,7 +14,7 @@ $UPLINKSRC=
 $UPLINKDEF=
 IF[{- !$disabled{uplink} -}]
   $UPLINKSRC_common=../ms/uplink.c
-  $UPLINKSRC_x86=$UPLINKSRC_common uplink-x86.s
+  $UPLINKSRC_x86=$UPLINKSRC_common uplink-x86.S
   $UPLINKSRC_x86_64=$UPLINKSRC_common uplink-x86_64.s
   $UPLINKSRC_ia64=$UPLINKSRC_common uplink-ia64.s
 
@@ -27,7 +27,7 @@ ENDIF
 $CPUIDASM=mem_clr.c
 $CPUIDDEF=
 IF[{- !$disabled{asm} && $config{processor} ne '386' -}]
-  $CPUIDASM_x86=x86cpuid.s
+  $CPUIDASM_x86=x86cpuid.S
 
   $CPUIDASM_x86_64=x86_64cpuid.s
 
@@ -111,11 +111,11 @@ DEPEND[info.o]=buildinf.h
 DEPEND[cversion.o]=buildinf.h
 GENERATE[buildinf.h]=../util/mkbuildinf.pl "$(CC) $(LIB_CFLAGS) $(CPPFLAGS_Q)" "$(PLATFORM)"
 
-GENERATE[uplink-x86.s]=../ms/uplink-x86.pl
+GENERATE[uplink-x86.S]=../ms/uplink-x86.pl
 GENERATE[uplink-x86_64.s]=../ms/uplink-x86_64.pl
 GENERATE[uplink-ia64.s]=../ms/uplink-ia64.pl
 
-GENERATE[x86cpuid.s]=x86cpuid.pl
+GENERATE[x86cpuid.S]=x86cpuid.pl
 DEPEND[x86cpuid.s]=perlasm/x86asm.pl
 
 GENERATE[x86_64cpuid.s]=x86_64cpuid.pl
diff --git a/crypto/camellia/build.info b/crypto/camellia/build.info
index 02f9afeb8009..f13cd8c958be 100644
--- a/crypto/camellia/build.info
+++ b/crypto/camellia/build.info
@@ -2,7 +2,7 @@ LIBS=../../libcrypto
 
 $CMLLASM=camellia.c cmll_misc.c cmll_cbc.c
 IF[{- !$disabled{asm} -}]
-  $CMLLASM_x86=cmll-x86.s
+  $CMLLASM_x86=cmll-x86.S
   $CMLLASM_x86_64=cmll-x86_64.s cmll_misc.c
   $CMLLASM_sparcv9=camellia.c cmll_misc.c cmll_cbc.c cmllt4-sparcv9.S
 
@@ -17,8 +17,8 @@ ENDIF
 SOURCE[../../libcrypto]=cmll_ecb.c cmll_ofb.c cmll_cfb.c cmll_ctr.c $CMLLASM
 DEFINE[../../libcrypto]=$CMLLDEF
 
-GENERATE[cmll-x86.s]=asm/cmll-x86.pl
-DEPEND[cmll-x86.s]=../perlasm/x86asm.pl
+GENERATE[cmll-x86.S]=asm/cmll-x86.pl
+DEPEND[cmll-x86.S]=../perlasm/x86asm.pl
 GENERATE[cmll-x86_64.s]=asm/cmll-x86_64.pl
 GENERATE[cmllt4-sparcv9.S]=asm/cmllt4-sparcv9.pl
 INCLUDE[cmllt4-sparcv9.o]=..
diff --git a/crypto/cast/build.info b/crypto/cast/build.info
index 01a3691d687d..7653b221881a 100644
--- a/crypto/cast/build.info
+++ b/crypto/cast/build.info
@@ -3,7 +3,7 @@ LIBS=../../libcrypto
 $CASTASM=c_enc.c
 # CAST assembly source is not PIC
 IF[{- !$disabled{asm} && $disabled{pic} -}]
-  $CASTASM_x86=cast-586.s
+  $CASTASM_x86=cast-586.S
 
   # Now that we have defined all the arch specific variables, use the
   # appropriate one
@@ -22,5 +22,5 @@ IF[{- $disabled{'deprecated-3.0'} -}]
   SOURCE[../../providers/liblegacy.a]=$ALL
 ENDIF
 
-GENERATE[cast-586.s]=asm/cast-586.pl
-DEPEND[cast-586.s]=../perlasm/x86asm.pl ../perlasm/cbc.pl
+GENERATE[cast-586.S]=asm/cast-586.pl
+DEPEND[cast-586.S]=../perlasm/x86asm.pl ../perlasm/cbc.pl
diff --git a/crypto/chacha/build.info b/crypto/chacha/build.info
index 026b09de74c5..e7159dc066dc 100644
--- a/crypto/chacha/build.info
+++ b/crypto/chacha/build.info
@@ -2,7 +2,7 @@ LIBS=../../libcrypto
 
 $CHACHAASM=chacha_enc.c
 IF[{- !$disabled{asm} -}]
-  $CHACHAASM_x86=chacha-x86.s
+  $CHACHAASM_x86=chacha-x86.S
   $CHACHAASM_x86_64=chacha-x86_64.s
 
   $CHACHAASM_ia64=chacha-ia64.s
@@ -26,7 +26,7 @@ ENDIF
 
 SOURCE[../../libcrypto]=$CHACHAASM
 
-GENERATE[chacha-x86.s]=asm/chacha-x86.pl
+GENERATE[chacha-x86.S]=asm/chacha-x86.pl
 GENERATE[chacha-x86_64.s]=asm/chacha-x86_64.pl
 GENERATE[chacha-ppc.s]=asm/chacha-ppc.pl
 GENERATE[chacha-armv4.S]=asm/chacha-armv4.pl
@@ -36,4 +36,5 @@ INCLUDE[chacha-armv8.o]=..
 INCLUDE[chacha-s390x.o]=..
 GENERATE[chacha-c64xplus.S]=asm/chacha-c64xplus.pl
 GENERATE[chacha-s390x.S]=asm/chacha-s390x.pl
-GENERATE[chacha-ia64.s]=asm/chacha-ia64.pl
+GENERATE[chacha-ia64.S]=asm/chacha-ia64.pl
+GENERATE[chacha-ia64.s]=chacha-ia64.S
diff --git a/crypto/cmac/cmac.c b/crypto/cmac/cmac.c
index 218eb9425961..15968f74c433 100644
--- a/crypto/cmac/cmac.c
+++ b/crypto/cmac/cmac.c
@@ -137,9 +137,9 @@ int CMAC_Init(CMAC_CTX *ctx, const void *key, size_t keylen,
 
         /* If anything fails then ensure we can't use this ctx */
         ctx->nlast_block = -1;
-        if (!EVP_CIPHER_CTX_get0_cipher(ctx->cctx))
+        if (EVP_CIPHER_CTX_get0_cipher(ctx->cctx) == NULL)
             return 0;
-        if (!EVP_CIPHER_CTX_set_key_length(ctx->cctx, keylen))
+        if (EVP_CIPHER_CTX_set_key_length(ctx->cctx, keylen) <= 0)
             return 0;
         if (!EVP_EncryptInit_ex(ctx->cctx, NULL, NULL, key, zero_iv))
             return 0;
diff --git a/crypto/cms/cms_dh.c b/crypto/cms/cms_dh.c
index f14546c70378..98f440ed5a96 100644
--- a/crypto/cms/cms_dh.c
+++ b/crypto/cms/cms_dh.c
@@ -244,7 +244,7 @@ static int dh_cms_encrypt(CMS_RecipientInfo *ri)
 
     /* See if custom parameters set */
     kdf_type = EVP_PKEY_CTX_get_dh_kdf_type(pctx);
-    if (kdf_type <= 0 || !EVP_PKEY_CTX_get_dh_kdf_md(pctx, &kdf_md))
+    if (kdf_type <= 0 || EVP_PKEY_CTX_get_dh_kdf_md(pctx, &kdf_md) <= 0)
         goto err;
 
     if (kdf_type == EVP_PKEY_DH_KDF_NONE) {
diff --git a/crypto/cms/cms_ec.c b/crypto/cms/cms_ec.c
index b07af92bad8b..28b047c19f54 100644
--- a/crypto/cms/cms_ec.c
+++ b/crypto/cms/cms_ec.c
@@ -48,7 +48,7 @@ static EVP_PKEY *pkey_type2param(int ptype, const void *pval,
         if (pctx == NULL || EVP_PKEY_paramgen_init(pctx) <= 0)
             goto err;
         if (OBJ_obj2txt(groupname, sizeof(groupname), poid, 0) <= 0
-                || !EVP_PKEY_CTX_set_group_name(pctx, groupname)) {
+                || EVP_PKEY_CTX_set_group_name(pctx, groupname) <= 0) {
             ERR_raise(ERR_LIB_CMS, CMS_R_DECODE_ERROR);
             goto err;
         }
@@ -289,7 +289,7 @@ static int ecdh_cms_encrypt(CMS_RecipientInfo *ri)
     kdf_type = EVP_PKEY_CTX_get_ecdh_kdf_type(pctx);
     if (kdf_type <= 0)
         goto err;
-    if (!EVP_PKEY_CTX_get_ecdh_kdf_md(pctx, &kdf_md))
+    if (EVP_PKEY_CTX_get_ecdh_kdf_md(pctx, &kdf_md) <= 0)
         goto err;
     ecdh_nid = EVP_PKEY_CTX_get_ecdh_cofactor_mode(pctx);
     if (ecdh_nid < 0)
diff --git a/crypto/cms/cms_smime.c b/crypto/cms/cms_smime.c
index 4e80a13b4daa..f1517c464741 100644
--- a/crypto/cms/cms_smime.c
+++ b/crypto/cms/cms_smime.c
@@ -48,7 +48,7 @@ static int cms_copy_content(BIO *out, BIO *in, unsigned int flags)
         i = BIO_read(in, buf, sizeof(buf));
         if (i <= 0) {
             if (BIO_method_type(in) == BIO_TYPE_CIPHER) {
-                if (!BIO_get_cipher_status(in))
+                if (BIO_get_cipher_status(in) <= 0)
                     goto err;
             }
             if (i < 0)
diff --git a/crypto/conf/conf_mod.c b/crypto/conf/conf_mod.c
index 36b054ca516f..6286282108e6 100644
--- a/crypto/conf/conf_mod.c
+++ b/crypto/conf/conf_mod.c
@@ -62,8 +62,10 @@ struct conf_imodule_st {
     void *usr_data;
 };
 
-static STACK_OF(CONF_MODULE) *supported_modules = NULL;
-static STACK_OF(CONF_IMODULE) *initialized_modules = NULL;
+static CRYPTO_ONCE init_module_list_lock = CRYPTO_ONCE_STATIC_INIT;
+static CRYPTO_RWLOCK *module_list_lock = NULL;
+static STACK_OF(CONF_MODULE) *supported_modules = NULL; /* protected by lock */
+static STACK_OF(CONF_IMODULE) *initialized_modules = NULL; /* protected by lock */
 
 static CRYPTO_ONCE load_builtin_modules = CRYPTO_ONCE_STATIC_INIT;
 
@@ -80,6 +82,29 @@ static int module_init(CONF_MODULE *pmod, const char *name, const char *value,
 static CONF_MODULE *module_load_dso(const CONF *cnf, const char *name,
                                     const char *value);
 
+static void module_lists_free(void)
+{
+    CRYPTO_THREAD_lock_free(module_list_lock);
+    module_list_lock = NULL;
+
+    sk_CONF_MODULE_free(supported_modules);
+    supported_modules = NULL;
+
+    sk_CONF_IMODULE_free(initialized_modules);
+    initialized_modules = NULL;
+}
+
+DEFINE_RUN_ONCE_STATIC(do_init_module_list_lock)
+{
+    module_list_lock = CRYPTO_THREAD_lock_new();
+    if (module_list_lock == NULL) {
+        ERR_raise(ERR_LIB_CONF, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+
+    return 1;
+}
+
 static int conf_diagnostics(const CONF *cnf)
 {
     return _CONF_get_number(cnf, NULL, "config_diagnostics") != 0;
@@ -294,31 +319,42 @@ static CONF_MODULE *module_add(DSO *dso, const char *name,
                                conf_init_func *ifunc, conf_finish_func *ffunc)
 {
     CONF_MODULE *tmod = NULL;
+
+    if (!RUN_ONCE(&init_module_list_lock, do_init_module_list_lock))
+        return NULL;
+
+    if (!CRYPTO_THREAD_write_lock(module_list_lock))
+        return NULL;
+
     if (supported_modules == NULL)
         supported_modules = sk_CONF_MODULE_new_null();
     if (supported_modules == NULL)
-        return NULL;
+        goto err;
     if ((tmod = OPENSSL_zalloc(sizeof(*tmod))) == NULL) {
         ERR_raise(ERR_LIB_CONF, ERR_R_MALLOC_FAILURE);
-        return NULL;
+        goto err;
     }
 
     tmod->dso = dso;
     tmod->name = OPENSSL_strdup(name);
     tmod->init = ifunc;
     tmod->finish = ffunc;
-    if (tmod->name == NULL) {
-        OPENSSL_free(tmod);
-        return NULL;
-    }
+    if (tmod->name == NULL)
+        goto err;
 
-    if (!sk_CONF_MODULE_push(supported_modules, tmod)) {
+    if (!sk_CONF_MODULE_push(supported_modules, tmod))
+        goto err;
+
+    CRYPTO_THREAD_unlock(module_list_lock);
+    return tmod;
+
+ err:
+    CRYPTO_THREAD_unlock(module_list_lock);
+    if (tmod != NULL) {
         OPENSSL_free(tmod->name);
         OPENSSL_free(tmod);
-        return NULL;
     }
-
-    return tmod;
+    return NULL;
 }
 
 /*
@@ -339,14 +375,22 @@ static CONF_MODULE *module_find(const char *name)
     else
         nchar = strlen(name);
 
+    if (!RUN_ONCE(&init_module_list_lock, do_init_module_list_lock))
+        return NULL;
+
+    if (!CRYPTO_THREAD_read_lock(module_list_lock))
+        return NULL;
+
     for (i = 0; i < sk_CONF_MODULE_num(supported_modules); i++) {
         tmod = sk_CONF_MODULE_value(supported_modules, i);
-        if (strncmp(tmod->name, name, nchar) == 0)
+        if (strncmp(tmod->name, name, nchar) == 0) {
+            CRYPTO_THREAD_unlock(module_list_lock);
             return tmod;
+        }
     }
 
+    CRYPTO_THREAD_unlock(module_list_lock);
     return NULL;
-
 }
 
 /* initialize a module */
@@ -379,21 +423,30 @@ static int module_init(CONF_MODULE *pmod, const char *name, const char *value,
             goto err;
     }
 
+    if (!RUN_ONCE(&init_module_list_lock, do_init_module_list_lock))
+        goto err;
+
+    if (!CRYPTO_THREAD_write_lock(module_list_lock))
+        goto err;
+
     if (initialized_modules == NULL) {
         initialized_modules = sk_CONF_IMODULE_new_null();
-        if (!initialized_modules) {
+        if (initialized_modules == NULL) {
+            CRYPTO_THREAD_unlock(module_list_lock);
             ERR_raise(ERR_LIB_CONF, ERR_R_MALLOC_FAILURE);
             goto err;
         }
     }
 
     if (!sk_CONF_IMODULE_push(initialized_modules, imod)) {
+        CRYPTO_THREAD_unlock(module_list_lock);
         ERR_raise(ERR_LIB_CONF, ERR_R_MALLOC_FAILURE);
         goto err;
     }
 
     pmod->links++;
 
+    CRYPTO_THREAD_unlock(module_list_lock);
     return ret;
 
  err:
@@ -423,7 +476,12 @@ void CONF_modules_unload(int all)
 {
     int i;
     CONF_MODULE *md;
-    CONF_modules_finish();
+
+    CONF_modules_finish(); /* also inits module list lock */
+
+    if (!CRYPTO_THREAD_write_lock(module_list_lock))
+        return;
+
     /* unload modules in reverse order */
     for (i = sk_CONF_MODULE_num(supported_modules) - 1; i >= 0; i--) {
         md = sk_CONF_MODULE_value(supported_modules, i);
@@ -434,10 +492,13 @@ void CONF_modules_unload(int all)
         (void)sk_CONF_MODULE_delete(supported_modules, i);
         module_free(md);
     }
+
     if (sk_CONF_MODULE_num(supported_modules) == 0) {
         sk_CONF_MODULE_free(supported_modules);
         supported_modules = NULL;
     }
+
+    CRYPTO_THREAD_unlock(module_list_lock);
 }
 
 /* unload a single module */
@@ -453,12 +514,21 @@ static void module_free(CONF_MODULE *md)
 void CONF_modules_finish(void)
 {
     CONF_IMODULE *imod;
+
+    if (!RUN_ONCE(&init_module_list_lock, do_init_module_list_lock))
+        return;
+
+    if (!CRYPTO_THREAD_write_lock(module_list_lock))
+        return;
+
     while (sk_CONF_IMODULE_num(initialized_modules) > 0) {
         imod = sk_CONF_IMODULE_pop(initialized_modules);
         module_finish(imod);
     }
     sk_CONF_IMODULE_free(initialized_modules);
     initialized_modules = NULL;
+
+    CRYPTO_THREAD_unlock(module_list_lock);
 }
 
 /* finish a module instance */
@@ -488,8 +558,8 @@ int CONF_module_add(const char *name, conf_init_func *ifunc,
 
 void ossl_config_modules_free(void)
 {
-    CONF_modules_finish();
-    CONF_modules_unload(1);
+    CONF_modules_unload(1); /* calls CONF_modules_finish */
+    module_lists_free();
 }
 
 /* Utility functions */
diff --git a/crypto/context.c b/crypto/context.c
index 4fef24cadd5a..bdfc4d02a3f0 100644
--- a/crypto/context.c
+++ b/crypto/context.c
@@ -151,8 +151,7 @@ static CRYPTO_THREAD_LOCAL default_context_thread_local;
 DEFINE_RUN_ONCE_STATIC(default_context_do_init)
 {
     return CRYPTO_THREAD_init_local(&default_context_thread_local, NULL)
-        && context_init(&default_context_int)
-        && ossl_init_casecmp();
+        && context_init(&default_context_int);
 }
 
 void ossl_lib_ctx_default_deinit(void)
diff --git a/crypto/core_algorithm.c b/crypto/core_algorithm.c
index 5ff33eff7c74..6d1192f098d7 100644
--- a/crypto/core_algorithm.c
+++ b/crypto/core_algorithm.c
@@ -16,7 +16,8 @@
 struct algorithm_data_st {
     OSSL_LIB_CTX *libctx;
     int operation_id;            /* May be zero for finding them all */
-    int (*pre)(OSSL_PROVIDER *, int operation_id, void *data, int *result);
+    int (*pre)(OSSL_PROVIDER *, int operation_id, int no_store, void *data,
+               int *result);
     void (*fn)(OSSL_PROVIDER *, const OSSL_ALGORITHM *, int no_store,
                void *data);
     int (*post)(OSSL_PROVIDER *, int operation_id, int no_store, void *data,
@@ -24,10 +25,71 @@ struct algorithm_data_st {
     void *data;
 };
 
+/*
+ * Process one OSSL_ALGORITHM array, for the operation |cur_operation|,
+ * by constructing methods for all its implementations and adding those
+ * to the appropriate method store.
+ * Which method store is appropriate is given by |no_store| ("permanent"
+ * if 0, temporary if 1) and other data in |data->data|.
+ *
+ * Returns:
+ * -1 to quit adding algorithm implementations immediately
+ * 0 if not successful, but adding should continue
+ * 1 if successful so far, and adding should continue
+ */
+static int algorithm_do_map(OSSL_PROVIDER *provider, const OSSL_ALGORITHM *map,
+                            int cur_operation, int no_store, void *cbdata)
+{
+    struct algorithm_data_st *data = cbdata;
+    int ret = 0;
+
+    /* Do we fulfill pre-conditions? */
+    if (data->pre == NULL) {
+        /* If there is no pre-condition function, assume "yes" */
+        ret = 1;
+    } else if (!data->pre(provider, cur_operation, no_store, data->data,
+                          &ret)) {
+        /* Error, bail out! */
+        return -1;
+    }
+
+    /*
+     * If pre-condition not fulfilled don't add this set of implementations,
+     * but do continue with the next.  This simply means that another thread
+     * got to it first.
+     */
+    if (ret == 0)
+        return 1;
+
+    if (map != NULL) {
+        const OSSL_ALGORITHM *thismap;
+
+        for (thismap = map; thismap->algorithm_names != NULL; thismap++)
+            data->fn(provider, thismap, no_store, data->data);
+    }
+
+    /* Do we fulfill post-conditions? */
+    if (data->post == NULL) {
+        /* If there is no post-condition function, assume "yes" */
+        ret = 1;
+    } else if (!data->post(provider, cur_operation, no_store, data->data,
+                           &ret)) {
+        /* Error, bail out! */
+        return -1;
+    }
+
+    return ret;
+}
+
+/*
+ * Given a provider, process one operation given by |data->operation_id|, or
+ * if that's zero, process all known operations.
+ * For each such operation, query the associated OSSL_ALGORITHM array from
+ * the provider, then process that array with |algorithm_do_map()|.
+ */
 static int algorithm_do_this(OSSL_PROVIDER *provider, void *cbdata)
 {
     struct algorithm_data_st *data = cbdata;
-    int no_store = 0;    /* Assume caching is ok */
     int first_operation = 1;
     int last_operation = OSSL_OP__HIGHEST;
     int cur_operation;
@@ -39,43 +101,18 @@ static int algorithm_do_this(OSSL_PROVIDER *provider, void *cbdata)
     for (cur_operation = first_operation;
          cur_operation <= last_operation;
          cur_operation++) {
+        int no_store = 0;        /* Assume caching is ok */
         const OSSL_ALGORITHM *map = NULL;
         int ret;
 
-        /* Do we fulfill pre-conditions? */
-        if (data->pre == NULL) {
-            /* If there is no pre-condition function, assume "yes" */
-            ret = 1;
-        } else {
-            if (!data->pre(provider, cur_operation, data->data, &ret))
-                /* Error, bail out! */
-                return 0;
-        }
-
-        /* If pre-condition not fulfilled, go to the next operation */
-        if (!ret)
-            continue;
-
         map = ossl_provider_query_operation(provider, cur_operation,
                                             &no_store);
-        if (map != NULL) {
-            const OSSL_ALGORITHM *thismap;
-
-            for (thismap = map; thismap->algorithm_names != NULL; thismap++)
-                data->fn(provider, thismap, no_store, data->data);
-        }
+        ret = algorithm_do_map(provider, map, cur_operation, no_store, data);
         ossl_provider_unquery_operation(provider, cur_operation, map);
 
-        /* Do we fulfill post-conditions? */
-        if (data->post == NULL) {
-            /* If there is no post-condition function, assume "yes" */
-            ret = 1;
-        } else {
-            if (!data->post(provider, cur_operation, no_store, data->data,
-                            &ret))
-                /* Error, bail out! */
-                return 0;
-        }
+        if (ret < 0)
+            /* Hard error, bail out immediately! */
+            return 0;
 
         /* If post-condition not fulfilled, set general failure */
         if (!ret)
@@ -88,7 +125,7 @@ static int algorithm_do_this(OSSL_PROVIDER *provider, void *cbdata)
 void ossl_algorithm_do_all(OSSL_LIB_CTX *libctx, int operation_id,
                            OSSL_PROVIDER *provider,
                            int (*pre)(OSSL_PROVIDER *, int operation_id,
-                                      void *data, int *result),
+                                      int no_store, void *data, int *result),
                            void (*fn)(OSSL_PROVIDER *provider,
                                       const OSSL_ALGORITHM *algo,
                                       int no_store, void *data),
diff --git a/crypto/core_fetch.c b/crypto/core_fetch.c
index 367f6ba8a47b..faa6ebdefd17 100644
--- a/crypto/core_fetch.c
+++ b/crypto/core_fetch.c
@@ -24,16 +24,28 @@ struct construct_data_st {
     void *mcm_data;
 };
 
+static int is_temporary_method_store(int no_store, void *cbdata)
+{
+    struct construct_data_st *data = cbdata;
+
+    return no_store && !data->force_store;
+}
+
 static int ossl_method_construct_precondition(OSSL_PROVIDER *provider,
-                                              int operation_id, void *cbdata,
-                                              int *result)
+                                              int operation_id, int no_store,
+                                              void *cbdata, int *result)
 {
     if (!ossl_assert(result != NULL)) {
         ERR_raise(ERR_LIB_CRYPTO, ERR_R_PASSED_NULL_PARAMETER);
         return 0;
     }
 
-    if (!ossl_provider_test_operation_bit(provider, operation_id, result))
+    /* Assume that no bits are set */
+    *result = 0;
+
+    /* No flag bits for temporary stores */
+    if (!is_temporary_method_store(no_store, cbdata)
+        && !ossl_provider_test_operation_bit(provider, operation_id, result))
         return 0;
 
     /*
@@ -56,7 +68,9 @@ static int ossl_method_construct_postcondition(OSSL_PROVIDER *provider,
     }
 
     *result = 1;
-    return no_store != 0
+
+    /* No flag bits for temporary stores */
+    return is_temporary_method_store(no_store, cbdata)
         || ossl_provider_set_operation_bit(provider, operation_id);
 }
 
@@ -82,7 +96,7 @@ static void ossl_method_construct_this(OSSL_PROVIDER *provider,
      * of the passed method.
      */
 
-    if (data->force_store || !no_store) {
+    if (!is_temporary_method_store(no_store, data)) {
         /* If we haven't been told not to store, add to the global store */
         data->mcm->put(NULL, method, provider, algo->algorithm_names,
                        algo->property_definition, data->mcm_data);
@@ -109,31 +123,38 @@ void *ossl_method_construct(OSSL_LIB_CTX *libctx, int operation_id,
                             OSSL_METHOD_CONSTRUCT_METHOD *mcm, void *mcm_data)
 {
     void *method = NULL;
+    OSSL_PROVIDER *provider = provider_rw != NULL ? *provider_rw : NULL;
+    struct construct_data_st cbdata;
 
-    if ((method = mcm->get(NULL, (const OSSL_PROVIDER **)provider_rw,
-                           mcm_data)) == NULL) {
-        OSSL_PROVIDER *provider = provider_rw != NULL ? *provider_rw : NULL;
-        struct construct_data_st cbdata;
+    /*
+     * We might be tempted to try to look into the method store without
+     * constructing to see if we can find our method there already.
+     * Unfortunately that does not work well if the query contains
+     * optional properties as newly loaded providers can match them better.
+     * We trust that ossl_method_construct_precondition() and
+     * ossl_method_construct_postcondition() make sure that the
+     * ossl_algorithm_do_all() does very little when methods from
+     * a provider have already been constructed.
+     */
 
-        cbdata.store = NULL;
-        cbdata.force_store = force_store;
-        cbdata.mcm = mcm;
-        cbdata.mcm_data = mcm_data;
-        ossl_algorithm_do_all(libctx, operation_id, provider,
-                              ossl_method_construct_precondition,
-                              ossl_method_construct_this,
-                              ossl_method_construct_postcondition,
-                              &cbdata);
+    cbdata.store = NULL;
+    cbdata.force_store = force_store;
+    cbdata.mcm = mcm;
+    cbdata.mcm_data = mcm_data;
+    ossl_algorithm_do_all(libctx, operation_id, provider,
+                          ossl_method_construct_precondition,
+                          ossl_method_construct_this,
+                          ossl_method_construct_postcondition,
+                          &cbdata);
 
-        /* If there is a temporary store, try there first */
-        if (cbdata.store != NULL)
-            method = mcm->get(cbdata.store, (const OSSL_PROVIDER **)provider_rw,
-                              mcm_data);
+    /* If there is a temporary store, try there first */
+    if (cbdata.store != NULL)
+        method = mcm->get(cbdata.store, (const OSSL_PROVIDER **)provider_rw,
+                          mcm_data);
 
-        /* If no method was found yet, try the global store */
-        if (method == NULL)
-            method = mcm->get(NULL, (const OSSL_PROVIDER **)provider_rw, mcm_data);
-    }
+    /* If no method was found yet, try the global store */
+    if (method == NULL)
+        method = mcm->get(NULL, (const OSSL_PROVIDER **)provider_rw, mcm_data);
 
     return method;
 }
diff --git a/crypto/crmf/crmf_lib.c b/crypto/crmf/crmf_lib.c
index ea1e2dda09f2..11351e33d165 100644
--- a/crypto/crmf/crmf_lib.c
+++ b/crypto/crmf/crmf_lib.c
@@ -369,6 +369,8 @@ static int create_popo_signature(OSSL_CRMF_POPOSIGNINGKEY *ps,
                                  EVP_PKEY *pkey, const EVP_MD *digest,
                                  OSSL_LIB_CTX *libctx, const char *propq)
 {
+    char name[80] = "";
+
     if (ps == NULL || cr == NULL || pkey == NULL) {
         ERR_raise(ERR_LIB_CRMF, CRMF_R_NULL_ARGUMENT);
         return 0;
@@ -379,6 +381,10 @@ static int create_popo_signature(OSSL_CRMF_POPOSIGNINGKEY *ps,
         return 0;
     }
 
+    if (EVP_PKEY_get_default_digest_name(pkey, name, sizeof(name)) > 0
+            && strcmp(name, "UNDEF") == 0) /* at least for Ed25519, Ed448 */
+        digest = NULL;
+
     return ASN1_item_sign_ex(ASN1_ITEM_rptr(OSSL_CRMF_CERTREQUEST),
                              ps->algorithmIdentifier, NULL, ps->signature, cr,
                              NULL, pkey, digest, libctx, propq);
diff --git a/crypto/ct/ct_log.c b/crypto/ct/ct_log.c
index 9b77d7a96346..ec6ac1dd7f68 100644
--- a/crypto/ct/ct_log.c
+++ b/crypto/ct/ct_log.c
@@ -276,7 +276,7 @@ CTLOG *CTLOG_new_ex(EVP_PKEY *public_key, const char *name, OSSL_LIB_CTX *libctx
 
     ret->libctx = libctx;
     if (propq != NULL) {
-        ret->name = OPENSSL_strdup(propq);
+        ret->propq = OPENSSL_strdup(propq);
         if (ret->propq == NULL) {
             ERR_raise(ERR_LIB_CT, ERR_R_MALLOC_FAILURE);
             goto err;
diff --git a/crypto/ctype.c b/crypto/ctype.c
index 43b32f842e65..de2e836ff783 100644
--- a/crypto/ctype.c
+++ b/crypto/ctype.c
@@ -12,19 +12,6 @@
 #include "crypto/ctype.h"
 #include <openssl/ebcdic.h>
 
-#include <openssl/crypto.h>
-#include "internal/core.h"
-#include "internal/thread_once.h"
-
-#ifndef OPENSSL_SYS_WINDOWS
-#include <strings.h>
-#endif
-#include <locale.h>
-
-#ifdef OPENSSL_SYS_MACOSX
-#include <xlocale.h>
-#endif
-
 /*
  * Define the character classes for each character in the seven bit ASCII
  * character set.  This is independent of the host's character set, characters
@@ -270,6 +257,36 @@ int ossl_ctype_check(int c, unsigned int mask)
     return a >= 0 && a < max && (ctype_char_map[a] & mask) != 0;
 }
 
+/*
+ * Implement some of the simplier functions directly to avoid the overhead of
+ * accessing memory via ctype_char_map[].
+ */
+
+#define ASCII_IS_DIGIT(c)   (c >= 0x30 && c <= 0x39)
+#define ASCII_IS_UPPER(c)   (c >= 0x41 && c <= 0x5A)
+#define ASCII_IS_LOWER(c)   (c >= 0x61 && c <= 0x7A)
+
+int ossl_isdigit(int c)
+{
+    int a = ossl_toascii(c);
+
+    return ASCII_IS_DIGIT(a);
+}
+
+int ossl_isupper(int c)
+{
+    int a = ossl_toascii(c);
+
+    return ASCII_IS_UPPER(a);
+}
+
+int ossl_islower(int c)
+{
+    int a = ossl_toascii(c);
+
+    return ASCII_IS_LOWER(a);
+}
+
 #if defined(CHARSET_EBCDIC) && !defined(CHARSET_EBCDIC_TEST)
 static const int case_change = 0x40;
 #else
@@ -278,103 +295,19 @@ static const int case_change = 0x20;
 
 int ossl_tolower(int c)
 {
-    return ossl_isupper(c) ? c ^ case_change : c;
+    int a = ossl_toascii(c);
+
+    return ASCII_IS_UPPER(a) ? c ^ case_change : c;
 }
 
 int ossl_toupper(int c)
 {
-    return ossl_islower(c) ? c ^ case_change : c;
+    int a = ossl_toascii(c);
+
+    return ASCII_IS_LOWER(a) ? c ^ case_change : c;
 }
 
-int ossl_ascii_isdigit(const char inchar) {
-    if (inchar > 0x2F && inchar < 0x3A)
-        return 1;
-    return 0;
-}
-
-/* str[n]casecmp_l is defined in POSIX 2008-01. Value is taken accordingly
- * https://www.gnu.org/software/libc/manual/html_node/Feature-Test-Macros.html */
-
-#if (defined OPENSSL_SYS_WINDOWS) || (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200809L)
-
-# if defined OPENSSL_SYS_WINDOWS
-# define locale_t _locale_t
-# define freelocale _free_locale
-# define strcasecmp_l _stricmp_l
-# define strncasecmp_l _strnicmp_l
-# endif
-
-# ifndef FIPS_MODULE
-static locale_t loc;
-
-static int locale_base_inited = 0;
-static CRYPTO_ONCE locale_base = CRYPTO_ONCE_STATIC_INIT;
-static CRYPTO_ONCE locale_base_deinit = CRYPTO_ONCE_STATIC_INIT;
-
-void *ossl_c_locale() {
-    return (void *)loc;
-}
-
-DEFINE_RUN_ONCE_STATIC(ossl_init_locale_base)
+int ossl_ascii_isdigit(int c)
 {
-# ifdef OPENSSL_SYS_WINDOWS
-    loc = _create_locale(LC_COLLATE, "C");
-# else
-    loc = newlocale(LC_COLLATE_MASK, "C", (locale_t) 0);
-# endif
-    locale_base_inited = 1;
-    return (loc == (locale_t) 0) ? 0 : 1;
+    return ASCII_IS_DIGIT(c);
 }
-
-DEFINE_RUN_ONCE_STATIC(ossl_deinit_locale_base)
-{
-    if (locale_base_inited && loc) {
-        freelocale(loc);
-        loc = NULL;
-    }
-    return 1;
-}
-
-int ossl_init_casecmp()
-{
-   return RUN_ONCE(&locale_base, ossl_init_locale_base);
-}
-
-void ossl_deinit_casecmp() {
-    (void)RUN_ONCE(&locale_base_deinit, ossl_deinit_locale_base);
-}
-# endif
-
-int OPENSSL_strcasecmp(const char *s1, const char *s2)
-{
-    return strcasecmp_l(s1, s2, (locale_t)ossl_c_locale());
-}
-
-int OPENSSL_strncasecmp(const char *s1, const char *s2, size_t n)
-{
-    return strncasecmp_l(s1, s2, n, (locale_t)ossl_c_locale());
-}
-#else
-# ifndef FIPS_MODULE
-void *ossl_c_locale() {
-    return NULL;
-}
-# endif
-
-int ossl_init_casecmp() {
-    return 1;
-}
-
-void ossl_deinit_casecmp() {
-}
-
-int OPENSSL_strcasecmp(const char *s1, const char *s2)
-{
-    return strcasecmp(s1, s2);
-}
-
-int OPENSSL_strncasecmp(const char *s1, const char *s2, size_t n)
-{
-    return strncasecmp(s1, s2, n);
-}
-#endif
diff --git a/crypto/des/build.info b/crypto/des/build.info
index ad8553a41a75..4284272cfa80 100644
--- a/crypto/des/build.info
+++ b/crypto/des/build.info
@@ -1,6 +1,6 @@
 $DESASM=des_enc.c fcrypt_b.c
 IF[{- !$disabled{asm} -}]
-  $DESASM_x86=des-586.s crypt586.s
+  $DESASM_x86=des-586.S crypt586.S
   $DESASM_sparcv9=des_enc-sparc.S fcrypt_b.c dest4-sparcv9.S
   $DESASM_sparcv8=des_enc-sparc.S fcrypt_b.c
 
@@ -40,7 +40,7 @@ GENERATE[des_enc-sparc.S]=asm/des_enc.m4
 GENERATE[dest4-sparcv9.S]=asm/dest4-sparcv9.pl
 INCLUDE[dest4-sparcv9.o]=..
 
-GENERATE[des-586.s]=asm/des-586.pl
-DEPEND[des-586.s]=../perlasm/x86asm.pl ../perlasm/cbc.pl
-GENERATE[crypt586.s]=asm/crypt586.pl
-DEPEND[crypt586.s]=../perlasm/x86asm.pl ../perlasm/cbc.pl
+GENERATE[des-586.S]=asm/des-586.pl
+DEPEND[des-586.S]=../perlasm/x86asm.pl ../perlasm/cbc.pl
+GENERATE[crypt586.S]=asm/crypt586.pl
+DEPEND[crypt586.S]=../perlasm/x86asm.pl ../perlasm/cbc.pl
diff --git a/crypto/dh/dh_ameth.c b/crypto/dh/dh_ameth.c
index b2ff8c3eb5e0..47a6ab7d0c7c 100644
--- a/crypto/dh/dh_ameth.c
+++ b/crypto/dh/dh_ameth.c
@@ -393,14 +393,21 @@ int DHparams_print(BIO *bp, const DH *x)
 
 static int dh_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)
 {
+    DH *dh;
     switch (op) {
     case ASN1_PKEY_CTRL_SET1_TLS_ENCPT:
         /* We should only be here if we have a legacy key */
         if (!ossl_assert(evp_pkey_is_legacy(pkey)))
             return 0;
-        return ossl_dh_buf2key(evp_pkey_get0_DH_int(pkey), arg2, arg1);
+        dh = (DH *) evp_pkey_get0_DH_int(pkey);
+        if (dh == NULL)
+            return 0;
+        return ossl_dh_buf2key(dh, arg2, arg1);
     case ASN1_PKEY_CTRL_GET1_TLS_ENCPT:
-        return ossl_dh_key2buf(EVP_PKEY_get0_DH(pkey), arg2, 0, 1);
+        dh = (DH *) EVP_PKEY_get0_DH(pkey);
+        if (dh == NULL)
+            return 0;
+        return ossl_dh_key2buf(dh, arg2, 0, 1);
     default:
         return -2;
     }
diff --git a/crypto/ec/build.info b/crypto/ec/build.info
index 9ee9842fecfb..70ec25079df9 100644
--- a/crypto/ec/build.info
+++ b/crypto/ec/build.info
@@ -1,6 +1,6 @@
 $ECASM=
 IF[{- !$disabled{asm} -}]
-  $ECASM_x86=ecp_nistz256.c ecp_nistz256-x86.s
+  $ECASM_x86=ecp_nistz256.c ecp_nistz256-x86.S
   $ECDEF_x86=ECP_NISTZ256_ASM
 
   $ECASM_x86_64=ecp_nistz256.c ecp_nistz256-x86_64.s x25519-x86_64.s
@@ -72,7 +72,7 @@ SOURCE[../../providers/libfips.a]=$COMMON
 DEFINE[../../libcrypto]=$ECDEF
 DEFINE[../../providers/libfips.a]=$ECDEF
 
-GENERATE[ecp_nistz256-x86.s]=asm/ecp_nistz256-x86.pl
+GENERATE[ecp_nistz256-x86.S]=asm/ecp_nistz256-x86.pl
 
 GENERATE[ecp_nistz256-x86_64.s]=asm/ecp_nistz256-x86_64.pl
 
diff --git a/crypto/ec/ec_asn1.c b/crypto/ec/ec_asn1.c
index 6323131a22b7..60550c75395f 100644
--- a/crypto/ec/ec_asn1.c
+++ b/crypto/ec/ec_asn1.c
@@ -687,6 +687,16 @@ EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params)
 
     /* extract seed (optional) */
     if (params->curve->seed != NULL) {
+        /*
+         * This happens for instance with
+         * fuzz/corpora/asn1/65cf44e85614c62f10cf3b7a7184c26293a19e4a
+         * and causes the OPENSSL_malloc below to choke on the
+         * zero length allocation request.
+         */
+        if (params->curve->seed->length == 0) {
+            ERR_raise(ERR_LIB_EC, EC_R_ASN1_ERROR);
+            goto err;
+        }
         OPENSSL_free(ret->seed);
         if ((ret->seed = OPENSSL_malloc(params->curve->seed->length)) == NULL) {
             ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
diff --git a/crypto/ec/ec_key.c b/crypto/ec/ec_key.c
index eb14f4e40903..0ae1c3f36770 100644
--- a/crypto/ec/ec_key.c
+++ b/crypto/ec/ec_key.c
@@ -947,8 +947,7 @@ int ossl_ec_key_simple_oct2priv(EC_KEY *eckey, const unsigned char *buf,
         ERR_raise(ERR_LIB_EC, ERR_R_MALLOC_FAILURE);
         return 0;
     }
-    eckey->priv_key = BN_bin2bn(buf, len, eckey->priv_key);
-    if (eckey->priv_key == NULL) {
+    if (BN_bin2bn(buf, len, eckey->priv_key) == NULL) {
         ERR_raise(ERR_LIB_EC, ERR_R_BN_LIB);
         return 0;
     }
diff --git a/crypto/ec/ecx_meth.c b/crypto/ec/ecx_meth.c
index 9098decf2f55..f88731a0e252 100644
--- a/crypto/ec/ecx_meth.c
+++ b/crypto/ec/ecx_meth.c
@@ -808,6 +808,11 @@ static int pkey_ecd_digestsign25519(EVP_MD_CTX *ctx, unsigned char *sig,
 {
     const ECX_KEY *edkey = evp_pkey_get_legacy(EVP_MD_CTX_get_pkey_ctx(ctx)->pkey);
 
+    if (edkey == NULL) {
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_KEY);
+        return 0;
+    }
+
     if (sig == NULL) {
         *siglen = ED25519_SIGSIZE;
         return 1;
@@ -830,6 +835,11 @@ static int pkey_ecd_digestsign448(EVP_MD_CTX *ctx, unsigned char *sig,
 {
     const ECX_KEY *edkey = evp_pkey_get_legacy(EVP_MD_CTX_get_pkey_ctx(ctx)->pkey);
 
+    if (edkey == NULL) {
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_KEY);
+        return 0;
+    }
+
     if (sig == NULL) {
         *siglen = ED448_SIGSIZE;
         return 1;
@@ -852,6 +862,11 @@ static int pkey_ecd_digestverify25519(EVP_MD_CTX *ctx, const unsigned char *sig,
 {
     const ECX_KEY *edkey = evp_pkey_get_legacy(EVP_MD_CTX_get_pkey_ctx(ctx)->pkey);
 
+    if (edkey == NULL) {
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_KEY);
+        return 0;
+    }
+
     if (siglen != ED25519_SIGSIZE)
         return 0;
 
@@ -865,6 +880,11 @@ static int pkey_ecd_digestverify448(EVP_MD_CTX *ctx, const unsigned char *sig,
 {
     const ECX_KEY *edkey = evp_pkey_get_legacy(EVP_MD_CTX_get_pkey_ctx(ctx)->pkey);
 
+    if (edkey == NULL) {
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_KEY);
+        return 0;
+    }
+
     if (siglen != ED448_SIGSIZE)
         return 0;
 
@@ -1180,6 +1200,11 @@ static int s390x_pkey_ecd_digestsign25519(EVP_MD_CTX *ctx,
     const ECX_KEY *edkey = evp_pkey_get_legacy(EVP_MD_CTX_get_pkey_ctx(ctx)->pkey);
     int rc;
 
+    if (edkey == NULL) {
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_KEY);
+        return 0;
+    }
+
     if (sig == NULL) {
         *siglen = ED25519_SIGSIZE;
         return 1;
@@ -1220,6 +1245,11 @@ static int s390x_pkey_ecd_digestsign448(EVP_MD_CTX *ctx,
     const ECX_KEY *edkey = evp_pkey_get_legacy(EVP_MD_CTX_get_pkey_ctx(ctx)->pkey);
     int rc;
 
+    if (edkey == NULL) {
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_KEY);
+        return 0;
+    }
+
     if (sig == NULL) {
         *siglen = ED448_SIGSIZE;
         return 1;
@@ -1262,6 +1292,11 @@ static int s390x_pkey_ecd_digestverify25519(EVP_MD_CTX *ctx,
     } param;
     const ECX_KEY *edkey = evp_pkey_get_legacy(EVP_MD_CTX_get_pkey_ctx(ctx)->pkey);
 
+    if (edkey == NULL) {
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_KEY);
+        return 0;
+    }
+
     if (siglen != ED25519_SIGSIZE)
         return 0;
 
@@ -1289,6 +1324,11 @@ static int s390x_pkey_ecd_digestverify448(EVP_MD_CTX *ctx,
     } param;
     const ECX_KEY *edkey = evp_pkey_get_legacy(EVP_MD_CTX_get_pkey_ctx(ctx)->pkey);
 
+    if (edkey == NULL) {
+        ERR_raise(ERR_LIB_EC, EC_R_INVALID_KEY);
+        return 0;
+    }
+
     if (siglen != ED448_SIGSIZE)
         return 0;
 
diff --git a/crypto/encode_decode/decoder_lib.c b/crypto/encode_decode/decoder_lib.c
index 334ff22ae715..e24d2c6cd588 100644
--- a/crypto/encode_decode/decoder_lib.c
+++ b/crypto/encode_decode/decoder_lib.c
@@ -227,10 +227,6 @@ OSSL_DECODER_INSTANCE *ossl_decoder_instance_new(OSSL_DECODER *decoder,
         ERR_raise(ERR_LIB_OSSL_DECODER, ERR_R_MALLOC_FAILURE);
         return 0;
     }
-    if (!OSSL_DECODER_up_ref(decoder)) {
-        ERR_raise(ERR_LIB_OSSL_DECODER, ERR_R_INTERNAL_ERROR);
-        goto err;
-    }
 
     prov = OSSL_DECODER_get0_provider(decoder);
     libctx = ossl_provider_libctx(prov);
@@ -261,6 +257,10 @@ OSSL_DECODER_INSTANCE *ossl_decoder_instance_new(OSSL_DECODER *decoder,
             = ossl_property_get_string_value(libctx, prop);
     }
 
+    if (!OSSL_DECODER_up_ref(decoder)) {
+        ERR_raise(ERR_LIB_OSSL_DECODER, ERR_R_INTERNAL_ERROR);
+        goto err;
+    }
     decoder_inst->decoder = decoder;
     decoder_inst->decoderctx = decoderctx;
     return decoder_inst;
@@ -358,8 +358,9 @@ static void collect_all_decoders(OSSL_DECODER *decoder, void *arg)
 {
     STACK_OF(OSSL_DECODER) *skdecoders = arg;
 
-    if (OSSL_DECODER_up_ref(decoder))
-        sk_OSSL_DECODER_push(skdecoders, decoder);
+    if (OSSL_DECODER_up_ref(decoder)
+            && !sk_OSSL_DECODER_push(skdecoders, decoder))
+        OSSL_DECODER_free(decoder);
 }
 
 static void collect_extra_decoder(OSSL_DECODER *decoder, void *arg)
diff --git a/crypto/encode_decode/decoder_meth.c b/crypto/encode_decode/decoder_meth.c
index cb53343c54d0..434385f04fb8 100644
--- a/crypto/encode_decode/decoder_meth.c
+++ b/crypto/encode_decode/decoder_meth.c
@@ -446,6 +446,25 @@ OSSL_DECODER *ossl_decoder_fetch_by_number(OSSL_LIB_CTX *libctx, int id,
     return method;
 }
 
+int ossl_decoder_store_cache_flush(OSSL_LIB_CTX *libctx)
+{
+    OSSL_METHOD_STORE *store = get_decoder_store(libctx);
+
+    if (store != NULL)
+        return ossl_method_store_cache_flush_all(store);
+    return 1;
+}
+
+int ossl_decoder_store_remove_all_provided(const OSSL_PROVIDER *prov)
+{
+    OSSL_LIB_CTX *libctx = ossl_provider_libctx(prov);
+    OSSL_METHOD_STORE *store = get_decoder_store(libctx);
+
+    if (store != NULL)
+        return ossl_method_store_remove_all_provided(store, prov);
+    return 1;
+}
+
 /*
  * Library of basic method functions
  */
diff --git a/crypto/encode_decode/encoder_meth.c b/crypto/encode_decode/encoder_meth.c
index eb8fd2f457a0..52bbd2baacea 100644
--- a/crypto/encode_decode/encoder_meth.c
+++ b/crypto/encode_decode/encoder_meth.c
@@ -455,6 +455,25 @@ OSSL_ENCODER *ossl_encoder_fetch_by_number(OSSL_LIB_CTX *libctx, int id,
     return method;
 }
 
+int ossl_encoder_store_cache_flush(OSSL_LIB_CTX *libctx)
+{
+    OSSL_METHOD_STORE *store = get_encoder_store(libctx);
+
+    if (store != NULL)
+        return ossl_method_store_cache_flush_all(store);
+    return 1;
+}
+
+int ossl_encoder_store_remove_all_provided(const OSSL_PROVIDER *prov)
+{
+    OSSL_LIB_CTX *libctx = ossl_provider_libctx(prov);
+    OSSL_METHOD_STORE *store = get_encoder_store(libctx);
+
+    if (store != NULL)
+        return ossl_method_store_remove_all_provided(store, prov);
+    return 1;
+}
+
 /*
  * Library of basic method functions
  */
diff --git a/crypto/err/err.c b/crypto/err/err.c
index c605c21f01b9..be35c913b068 100644
--- a/crypto/err/err.c
+++ b/crypto/err/err.c
@@ -29,7 +29,9 @@
 /* Forward declaration in case it's not published because of configuration */
 ERR_STATE *ERR_get_state(void);
 
+#ifndef OPENSSL_NO_ERR
 static int err_load_strings(const ERR_STRING_DATA *str);
+#endif
 
 static void ERR_STATE_free(ERR_STATE *s);
 #ifndef OPENSSL_NO_ERR
@@ -142,15 +144,19 @@ static int set_err_thread_local;
 static CRYPTO_THREAD_LOCAL err_thread_local;
 
 static CRYPTO_ONCE err_string_init = CRYPTO_ONCE_STATIC_INIT;
-static CRYPTO_RWLOCK *err_string_lock;
+static CRYPTO_RWLOCK *err_string_lock = NULL;
 
+#ifndef OPENSSL_NO_ERR
 static ERR_STRING_DATA *int_err_get_item(const ERR_STRING_DATA *);
+#endif
 
 /*
  * The internal state
  */
 
+#ifndef OPENSSL_NO_ERR
 static LHASH_OF(ERR_STRING_DATA) *int_error_hash = NULL;
+#endif
 static int int_err_library_number = ERR_LIB_USER;
 
 typedef enum ERR_GET_ACTION_e {
@@ -162,6 +168,7 @@ static unsigned long get_error_values(ERR_GET_ACTION g,
                                       const char **func, const char **data,
                                       int *flags);
 
+#ifndef OPENSSL_NO_ERR
 static unsigned long err_string_data_hash(const ERR_STRING_DATA *a)
 {
     unsigned long ret, l;
@@ -190,6 +197,7 @@ static ERR_STRING_DATA *int_err_get_item(const ERR_STRING_DATA *d)
 
     return p;
 }
+#endif
 
 static void ERR_STATE_free(ERR_STATE *s)
 {
@@ -210,6 +218,7 @@ DEFINE_RUN_ONCE_STATIC(do_err_strings_init)
     err_string_lock = CRYPTO_THREAD_lock_new();
     if (err_string_lock == NULL)
         return 0;
+#ifndef OPENSSL_NO_ERR
     int_error_hash = lh_ERR_STRING_DATA_new(err_string_data_hash,
                                             err_string_data_cmp);
     if (int_error_hash == NULL) {
@@ -217,6 +226,7 @@ DEFINE_RUN_ONCE_STATIC(do_err_strings_init)
         err_string_lock = NULL;
         return 0;
     }
+#endif
     return 1;
 }
 
@@ -226,10 +236,13 @@ void err_cleanup(void)
         CRYPTO_THREAD_cleanup_local(&err_thread_local);
     CRYPTO_THREAD_lock_free(err_string_lock);
     err_string_lock = NULL;
+#ifndef OPENSSL_NO_ERR
     lh_ERR_STRING_DATA_free(int_error_hash);
     int_error_hash = NULL;
+#endif
 }
 
+#ifndef OPENSSL_NO_ERR
 /*
  * Legacy; pack in the library.
  */
@@ -254,6 +267,7 @@ static int err_load_strings(const ERR_STRING_DATA *str)
     CRYPTO_THREAD_unlock(err_string_lock);
     return 1;
 }
+#endif
 
 int ossl_err_load_ERR_strings(void)
 {
@@ -269,24 +283,31 @@ int ossl_err_load_ERR_strings(void)
 
 int ERR_load_strings(int lib, ERR_STRING_DATA *str)
 {
+#ifndef OPENSSL_NO_ERR
     if (ossl_err_load_ERR_strings() == 0)
         return 0;
 
     err_patch(lib, str);
     err_load_strings(str);
+#endif
+
     return 1;
 }
 
 int ERR_load_strings_const(const ERR_STRING_DATA *str)
 {
+#ifndef OPENSSL_NO_ERR
     if (ossl_err_load_ERR_strings() == 0)
         return 0;
     err_load_strings(str);
+#endif
+
     return 1;
 }
 
 int ERR_unload_strings(int lib, ERR_STRING_DATA *str)
 {
+#ifndef OPENSSL_NO_ERR
     if (!RUN_ONCE(&err_string_init, do_err_strings_init))
         return 0;
 
@@ -299,14 +320,14 @@ int ERR_unload_strings(int lib, ERR_STRING_DATA *str)
     for (; str->error; str++)
         (void)lh_ERR_STRING_DATA_delete(int_error_hash, str);
     CRYPTO_THREAD_unlock(err_string_lock);
+#endif
 
     return 1;
 }
 
 void err_free_strings_int(void)
 {
-    if (!RUN_ONCE(&err_string_init, do_err_strings_init))
-        return;
+    /* obsolete */
 }
 
 /********************************************************/
@@ -564,6 +585,7 @@ char *ERR_error_string(unsigned long e, char *ret)
 
 const char *ERR_lib_error_string(unsigned long e)
 {
+#ifndef OPENSSL_NO_ERR
     ERR_STRING_DATA d, *p;
     unsigned long l;
 
@@ -575,6 +597,9 @@ const char *ERR_lib_error_string(unsigned long e)
     d.error = ERR_PACK(l, 0, 0);
     p = int_err_get_item(&d);
     return ((p == NULL) ? NULL : p->string);
+#else
+    return NULL;
+#endif
 }
 
 #ifndef OPENSSL_NO_DEPRECATED_3_0
@@ -586,6 +611,7 @@ const char *ERR_func_error_string(unsigned long e)
 
 const char *ERR_reason_error_string(unsigned long e)
 {
+#ifndef OPENSSL_NO_ERR
     ERR_STRING_DATA d, *p = NULL;
     unsigned long l, r;
 
@@ -610,6 +636,9 @@ const char *ERR_reason_error_string(unsigned long e)
         p = int_err_get_item(&d);
     }
     return ((p == NULL) ? NULL : p->string);
+#else
+    return NULL;
+#endif
 }
 
 static void err_delete_thread_state(void *unused)
diff --git a/crypto/evp/evp_enc.c b/crypto/evp/evp_enc.c
index 19a07debd948..e69da3f9a04e 100644
--- a/crypto/evp/evp_enc.c
+++ b/crypto/evp/evp_enc.c
@@ -304,7 +304,7 @@ static int evp_cipher_init_internal(EVP_CIPHER_CTX *ctx,
         /* Preserve wrap enable flag, zero everything else */
         ctx->flags &= EVP_CIPHER_CTX_FLAG_WRAP_ALLOW;
         if (ctx->cipher->flags & EVP_CIPH_CTRL_INIT) {
-            if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_INIT, 0, NULL)) {
+            if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_INIT, 0, NULL) <= 0) {
                 ctx->cipher = NULL;
                 ERR_raise(ERR_LIB_EVP, EVP_R_INITIALIZATION_ERROR);
                 return 0;
diff --git a/crypto/evp/evp_fetch.c b/crypto/evp/evp_fetch.c
index c126ea177e62..90d6a4e6d421 100644
--- a/crypto/evp/evp_fetch.c
+++ b/crypto/evp/evp_fetch.c
@@ -429,12 +429,22 @@ void *evp_generic_fetch_from_prov(OSSL_PROVIDER *prov, int operation_id,
     return method;
 }
 
-int evp_method_store_flush(OSSL_LIB_CTX *libctx)
+int evp_method_store_cache_flush(OSSL_LIB_CTX *libctx)
 {
     OSSL_METHOD_STORE *store = get_evp_method_store(libctx);
 
     if (store != NULL)
-        return ossl_method_store_flush_cache(store, 1);
+        return ossl_method_store_cache_flush_all(store);
+    return 1;
+}
+
+int evp_method_store_remove_all_provided(const OSSL_PROVIDER *prov)
+{
+    OSSL_LIB_CTX *libctx = ossl_provider_libctx(prov);
+    OSSL_METHOD_STORE *store = get_evp_method_store(libctx);
+
+    if (store != NULL)
+        return ossl_method_store_remove_all_provided(store, prov);
     return 1;
 }
 
@@ -481,7 +491,7 @@ static int evp_set_parsed_default_properties(OSSL_LIB_CTX *libctx,
         ossl_property_free(*plp);
         *plp = def_prop;
         if (store != NULL)
-            return ossl_method_store_flush_cache(store, 0);
+            return ossl_method_store_cache_flush_all(store);
     }
     ERR_raise(ERR_LIB_EVP, ERR_R_INTERNAL_ERROR);
     return 0;
diff --git a/crypto/evp/evp_lib.c b/crypto/evp/evp_lib.c
index 3fe4743761c4..b9180812cf6a 100644
--- a/crypto/evp/evp_lib.c
+++ b/crypto/evp/evp_lib.c
@@ -24,6 +24,7 @@
 #include <openssl/dh.h>
 #include <openssl/ec.h>
 #include "crypto/evp.h"
+#include "crypto/cryptlib.h"
 #include "internal/provider.h"
 #include "evp_local.h"
 
@@ -1094,6 +1095,8 @@ int EVP_CIPHER_CTX_test_flags(const EVP_CIPHER_CTX *ctx, int flags)
     return (ctx->flags & flags);
 }
 
+#if !defined(FIPS_MODULE)
+
 int EVP_PKEY_CTX_set_group_name(EVP_PKEY_CTX *ctx, const char *name)
 {
     OSSL_PARAM params[] = { OSSL_PARAM_END, OSSL_PARAM_END };
@@ -1189,3 +1192,5 @@ EVP_PKEY *EVP_PKEY_Q_keygen(OSSL_LIB_CTX *libctx, const char *propq,
     va_end(args);
     return ret;
 }
+
+#endif /* !defined(FIPS_MODULE) */
diff --git a/crypto/evp/p_dec.c b/crypto/evp/p_dec.c
index 7b33edecd55f..29ea3f5fbcb3 100644
--- a/crypto/evp/p_dec.c
+++ b/crypto/evp/p_dec.c
@@ -22,15 +22,19 @@ int EVP_PKEY_decrypt_old(unsigned char *key, const unsigned char *ek, int ekl,
                          EVP_PKEY *priv)
 {
     int ret = -1;
+    RSA *rsa = NULL;
 
     if (EVP_PKEY_get_id(priv) != EVP_PKEY_RSA) {
         ERR_raise(ERR_LIB_EVP, EVP_R_PUBLIC_KEY_NOT_RSA);
         goto err;
     }
 
+    rsa = evp_pkey_get0_RSA_int(priv);
+    if (rsa == NULL)
+        goto err;
+
     ret =
-        RSA_private_decrypt(ekl, ek, key, evp_pkey_get0_RSA_int(priv),
-                            RSA_PKCS1_PADDING);
+        RSA_private_decrypt(ekl, ek, key, rsa, RSA_PKCS1_PADDING);
  err:
     return ret;
 }
diff --git a/crypto/evp/p_enc.c b/crypto/evp/p_enc.c
index d4db5951640a..64e67514561c 100644
--- a/crypto/evp/p_enc.c
+++ b/crypto/evp/p_enc.c
@@ -22,15 +22,19 @@ int EVP_PKEY_encrypt_old(unsigned char *ek, const unsigned char *key,
                          int key_len, EVP_PKEY *pubk)
 {
     int ret = 0;
+    RSA *rsa = NULL;
 
     if (EVP_PKEY_get_id(pubk) != EVP_PKEY_RSA) {
         ERR_raise(ERR_LIB_EVP, EVP_R_PUBLIC_KEY_NOT_RSA);
         goto err;
     }
 
+    rsa = evp_pkey_get0_RSA_int(pubk);
+    if (rsa == NULL)
+        goto err;
+
     ret =
-        RSA_public_encrypt(key_len, key, ek, evp_pkey_get0_RSA_int(pubk),
-                           RSA_PKCS1_PADDING);
+        RSA_public_encrypt(key_len, key, ek, rsa, RSA_PKCS1_PADDING);
  err:
     return ret;
 }
diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c
index a4ad904f7739..46883255c6e4 100644
--- a/crypto/evp/p_lib.c
+++ b/crypto/evp/p_lib.c
@@ -2343,10 +2343,10 @@ int EVP_PKEY_get_params(const EVP_PKEY *pkey, OSSL_PARAM params[])
 {
     if (pkey != NULL) {
         if (evp_pkey_is_provided(pkey))
-            return evp_keymgmt_get_params(pkey->keymgmt, pkey->keydata, params);
+            return evp_keymgmt_get_params(pkey->keymgmt, pkey->keydata, params) > 0;
 #ifndef FIPS_MODULE
         else if (evp_pkey_is_legacy(pkey))
-            return evp_pkey_get_params_to_ctrl(pkey, params);
+            return evp_pkey_get_params_to_ctrl(pkey, params) > 0;
 #endif
     }
     ERR_raise(ERR_LIB_EVP, EVP_R_INVALID_KEY);
diff --git a/crypto/evp/p_open.c b/crypto/evp/p_open.c
index b08f27164262..92fd20f6aa6a 100644
--- a/crypto/evp/p_open.c
+++ b/crypto/evp/p_open.c
@@ -50,7 +50,7 @@ int EVP_OpenInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
     if (EVP_PKEY_decrypt(pctx, key, &keylen, ek, ekl) <= 0)
         goto err;
 
-    if (!EVP_CIPHER_CTX_set_key_length(ctx, keylen)
+    if (EVP_CIPHER_CTX_set_key_length(ctx, keylen) <= 0
         || !EVP_DecryptInit_ex(ctx, NULL, NULL, key, iv))
         goto err;
 
diff --git a/crypto/evp/pmeth_lib.c b/crypto/evp/pmeth_lib.c
index b58541057690..da367ed05fbe 100644
--- a/crypto/evp/pmeth_lib.c
+++ b/crypto/evp/pmeth_lib.c
@@ -27,7 +27,6 @@
 #ifndef FIPS_MODULE
 # include "crypto/asn1.h"
 #endif
-#include "crypto/ctype.h"
 #include "crypto/evp.h"
 #include "crypto/dh.h"
 #include "crypto/ec.h"
@@ -200,7 +199,6 @@ static EVP_PKEY_CTX *int_ctx_new(OSSL_LIB_CTX *libctx,
             }
 #ifndef FIPS_MODULE
             if (keytype != NULL) {
-                ossl_init_casecmp();
                 id = evp_pkey_name2type(keytype);
                 if (id == NID_undef)
                     id = -1;
diff --git a/crypto/init.c b/crypto/init.c
index 8d9ed7e9b2d8..51f09b6bc63a 100644
--- a/crypto/init.c
+++ b/crypto/init.c
@@ -170,7 +170,7 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_load_crypto_nodelete)
 }
 
 static CRYPTO_ONCE load_crypto_strings = CRYPTO_ONCE_STATIC_INIT;
-static int load_crypto_strings_inited = 0;
+
 DEFINE_RUN_ONCE_STATIC(ossl_init_load_crypto_strings)
 {
     int ret = 1;
@@ -181,7 +181,6 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_load_crypto_strings)
 #if !defined(OPENSSL_NO_ERR) && !defined(OPENSSL_NO_AUTOERRINIT)
     OSSL_TRACE(INIT, "ossl_err_load_crypto_strings()\n");
     ret = ossl_err_load_crypto_strings();
-    load_crypto_strings_inited = 1;
 #endif
     return ret;
 }
@@ -388,11 +387,6 @@ void OPENSSL_cleanup(void)
         async_deinit();
     }
 
-    if (load_crypto_strings_inited) {
-        OSSL_TRACE(INIT, "OPENSSL_cleanup: err_free_strings_int()\n");
-        err_free_strings_int();
-    }
-
     /*
      * Note that cleanup order is important:
      * - ossl_rand_cleanup_int could call an ENGINE's RAND cleanup function so
@@ -448,9 +442,6 @@ void OPENSSL_cleanup(void)
     OSSL_TRACE(INIT, "OPENSSL_cleanup: ossl_trace_cleanup()\n");
     ossl_trace_cleanup();
 
-    OSSL_TRACE(INIT, "OPENSSL_cleanup: ossl_deinit_casecmp()\n");
-    ossl_deinit_casecmp();
-
     base_inited = 0;
 }
 
@@ -464,9 +455,6 @@ int OPENSSL_init_crypto(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings)
     uint64_t tmp;
     int aloaddone = 0;
 
-    if (!ossl_init_casecmp())
-        return 0;
-
    /* Applications depend on 0 being returned when cleanup was already done */
     if (stopped) {
         if (!(opts & OPENSSL_INIT_BASE_ONLY))
diff --git a/crypto/md5/build.info b/crypto/md5/build.info
index 080411cc2cf2..a1e28c815329 100644
--- a/crypto/md5/build.info
+++ b/crypto/md5/build.info
@@ -2,7 +2,7 @@ LIBS=../../libcrypto
 
 $MD5ASM=
 IF[{- !$disabled{asm} -}]
-  $MD5ASM_x86=md5-586.s
+  $MD5ASM_x86=md5-586.S
   $MD5ASM_x86_64=md5-x86_64.s
   $MD5ASM_sparcv9=md5-sparcv9.S
 
@@ -32,7 +32,7 @@ ENDIF
 DEFINE[../../libcrypto]=$MD5DEF
 DEFINE[../../providers/liblegacy.a]=$MD5DEF
 
-GENERATE[md5-586.s]=asm/md5-586.pl
+GENERATE[md5-586.S]=asm/md5-586.pl
 
 GENERATE[md5-x86_64.s]=asm/md5-x86_64.pl
 
diff --git a/crypto/modes/build.info b/crypto/modes/build.info
index 687e872a1ebc..f3558fa1a465 100644
--- a/crypto/modes/build.info
+++ b/crypto/modes/build.info
@@ -2,7 +2,7 @@ LIBS=../../libcrypto
 
 $MODESASM=
 IF[{- !$disabled{asm} -}]
-  $MODESASM_x86=ghash-x86.s
+  $MODESASM_x86=ghash-x86.S
   $MODESDEF_x86=GHASH_ASM
   $MODESASM_x86_64=ghash-x86_64.s aesni-gcm-x86_64.s
   $MODESDEF_x86_64=GHASH_ASM
@@ -63,7 +63,7 @@ DEFINE[../../providers/libfips.a]=$MODESDEF
 INCLUDE[gcm128.o]=..
 
 GENERATE[ghash-ia64.s]=asm/ghash-ia64.pl
-GENERATE[ghash-x86.s]=asm/ghash-x86.pl
+GENERATE[ghash-x86.S]=asm/ghash-x86.pl
 GENERATE[ghash-x86_64.s]=asm/ghash-x86_64.pl
 GENERATE[aesni-gcm-x86_64.s]=asm/aesni-gcm-x86_64.pl
 GENERATE[ghash-sparcv9.S]=asm/ghash-sparcv9.pl
diff --git a/crypto/o_str.c b/crypto/o_str.c
index 5c4e4e7781cf..7fa487dd5fcd 100644
--- a/crypto/o_str.c
+++ b/crypto/o_str.c
@@ -8,9 +8,12 @@
  */
 
 #include "e_os.h"
+#include <string.h>
 #include <limits.h>
 #include <openssl/crypto.h>
+#include "crypto/ctype.h"
 #include "internal/cryptlib.h"
+#include "internal/thread_once.h"
 
 #define DEFAULT_SEPARATOR ':'
 #define CH_ZERO '\0'
@@ -338,3 +341,26 @@ int openssl_strerror_r(int errnum, char *buf, size_t buflen)
     return 1;
 #endif
 }
+
+int OPENSSL_strcasecmp(const char *s1, const char *s2)
+{
+    int t;
+
+    while ((t = ossl_tolower(*s1) - ossl_tolower(*s2++)) == 0)
+        if (*s1++ == '\0')
+            return 0;
+    return t;
+}
+
+int OPENSSL_strncasecmp(const char *s1, const char *s2, size_t n)
+{
+    int t;
+    size_t i;
+
+    for (i = 0; i < n; i++)
+        if ((t = ossl_tolower(*s1) - ossl_tolower(*s2++)) != 0)
+            return t;
+        else if (*s1++ == '\0')
+            return 0;
+    return 0;
+}
diff --git a/crypto/perlasm/x86asm.pl b/crypto/perlasm/x86asm.pl
index be462cec6eef..2ec16c5571d8 100644
--- a/crypto/perlasm/x86asm.pl
+++ b/crypto/perlasm/x86asm.pl
@@ -174,7 +174,9 @@ sub ::vprotd
 
 sub ::endbranch
 {
+    &::generic("#ifdef __CET__\n");
     &::data_byte(0xf3,0x0f,0x1e,0xfb);
+    &::generic("#endif\n");
 }
 
 # label management
diff --git a/crypto/pkcs7/pk7_doit.c b/crypto/pkcs7/pk7_doit.c
index 441bf78bbae0..4a13070a0a4f 100644
--- a/crypto/pkcs7/pk7_doit.c
+++ b/crypto/pkcs7/pk7_doit.c
@@ -612,7 +612,7 @@ BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)
              * length. The key length is determined by the size of the
              * decrypted RSA key.
              */
-            if (!EVP_CIPHER_CTX_set_key_length(evp_ctx, eklen)) {
+            if (EVP_CIPHER_CTX_set_key_length(evp_ctx, eklen) <= 0) {
                 /* Use random key as MMA defence */
                 OPENSSL_clear_free(ek, eklen);
                 ek = tkey;
diff --git a/crypto/pkcs7/pk7_lib.c b/crypto/pkcs7/pk7_lib.c
index c32a66662600..d90731f5c269 100644
--- a/crypto/pkcs7/pk7_lib.c
+++ b/crypto/pkcs7/pk7_lib.c
@@ -402,7 +402,7 @@ PKCS7_SIGNER_INFO *PKCS7_add_signature(PKCS7 *p7, X509 *x509, EVP_PKEY *pkey,
 
     if ((si = PKCS7_SIGNER_INFO_new()) == NULL)
         goto err;
-    if (!PKCS7_SIGNER_INFO_set(si, x509, pkey, dgst))
+    if (PKCS7_SIGNER_INFO_set(si, x509, pkey, dgst) <= 0)
         goto err;
     if (!PKCS7_add_signer(p7, si))
         goto err;
@@ -560,7 +560,7 @@ PKCS7_RECIP_INFO *PKCS7_add_recipient(PKCS7 *p7, X509 *x509)
 
     if ((ri = PKCS7_RECIP_INFO_new()) == NULL)
         goto err;
-    if (!PKCS7_RECIP_INFO_set(ri, x509))
+    if (PKCS7_RECIP_INFO_set(ri, x509) <= 0)
         goto err;
     if (!PKCS7_add_recipient_info(p7, ri))
         goto err;
diff --git a/crypto/pkcs7/pk7_smime.c b/crypto/pkcs7/pk7_smime.c
index 8bc83bc9f45d..56891b6efb76 100644
--- a/crypto/pkcs7/pk7_smime.c
+++ b/crypto/pkcs7/pk7_smime.c
@@ -533,7 +533,7 @@ int PKCS7_decrypt(PKCS7 *p7, EVP_PKEY *pkey, X509 *cert, BIO *data, int flags)
         }
         ret = SMIME_text(bread, data);
         if (ret > 0 && BIO_method_type(tmpmem) == BIO_TYPE_CIPHER) {
-            if (!BIO_get_cipher_status(tmpmem))
+            if (BIO_get_cipher_status(tmpmem) <= 0)
                 ret = 0;
         }
         BIO_free_all(bread);
@@ -548,7 +548,7 @@ int PKCS7_decrypt(PKCS7 *p7, EVP_PKEY *pkey, X509 *cert, BIO *data, int flags)
         if (i <= 0) {
             ret = 1;
             if (BIO_method_type(tmpmem) == BIO_TYPE_CIPHER) {
-                if (!BIO_get_cipher_status(tmpmem))
+                if (BIO_get_cipher_status(tmpmem) <= 0)
                     ret = 0;
             }
 
diff --git a/crypto/poly1305/asm/poly1305-ia64.S b/crypto/poly1305/asm/poly1305-ia64.S
new file mode 100644
index 000000000000..54d6454f0322
--- /dev/null
+++ b/crypto/poly1305/asm/poly1305-ia64.S
@@ -0,0 +1,365 @@
+// ====================================================================
+// Written by Andy Polyakov, @dot-asm, initially for use in the OpenSSL
+// project.
+// ====================================================================
+//
+// Poly1305 for Itanium.
+//
+// January 2019
+//
+// Performance was reported to be ~2.1 cycles per byte on Itanium 2.
+// With exception for processors in 95xx family, which have higher
+// floating-point instructions' latencies and deliver ~2.6 cpb.
+// Comparison to compiler-generated code is not exactly fair, because
+// of different radixes. But just for reference, it was observed to be
+// >3x faster. Originally it was argued that floating-point base 2^32
+// implementation would be optimal. Upon closer look estimate for below
+// integer base 2^64 implementation turned to be approximately same on
+// Itanium 2. But floating-point code would be larger, and have higher
+// overhead, which would negatively affect small-block performance...
+
+#if defined(_HPUX_SOURCE)
+# if !defined(_LP64)
+#  define ADDP  addp4
+# else
+#  define ADDP  add
+# endif
+# define RUM    rum
+# define SUM    sum
+#else
+# define ADDP   add
+# define RUM    nop
+# define SUM    nop
+#endif
+
+.text
+.explicit
+
+.global	poly1305_init#
+.proc	poly1305_init#
+.align	64
+poly1305_init:
+	.prologue
+	.save		ar.pfs,r2
+{ .mmi;	alloc		r2=ar.pfs,2,0,0,0
+	cmp.eq		p6,p7=0,r33		}	// key == NULL?
+{ .mmi;	ADDP		r9=8,r32
+	ADDP		r10=16,r32
+	ADDP		r32=0,r32		};;
+	.body
+{ .mmi;	st8		[r32]=r0,24			// ctx->h0 = 0
+	st8		[r9]=r0				// ctx->h1 = 0
+(p7)	ADDP		r8=0,r33		}
+{ .mib;	st8		[r10]=r0			// ctx->h2 = 0
+(p6)	mov		r8=0
+(p6)	br.ret.spnt	b0			};;
+
+{ .mmi;	ADDP		r9=1,r33
+	ADDP		r10=2,r33
+	ADDP		r11=3,r33		};;
+{ .mmi;	ld1		r16=[r8],4			// load key, little-endian
+	ld1		r17=[r9],4		}
+{ .mmi;	ld1		r18=[r10],4
+	ld1		r19=[r11],4		};;
+{ .mmi;	ld1		r20=[r8],4
+	ld1		r21=[r9],4		}
+{ .mmi;	ld1		r22=[r10],4
+	ld1		r23=[r11],4
+	and		r19=15,r19		};;
+{ .mmi;	ld1		r24=[r8],4
+	ld1		r25=[r9],4
+	and		r20=-4,r20		}
+{ .mmi;	ld1		r26=[r10],4
+	ld1		r27=[r11],4
+	and		r23=15,r23		};;
+{ .mmi;	ld1		r28=[r8],4
+	ld1		r29=[r9],4
+	and		r24=-4,r24		}
+{ .mmi;	ld1		r30=[r10],4
+	ld1		r31=[r11],4
+	and		r27=15,r27		};;
+
+{ .mii;	and		r28=-4,r28
+	dep		r16=r17,r16,8,8
+	dep		r18=r19,r18,8,8		};;
+{ .mii;	and		r31=15,r31
+	dep		r16=r18,r16,16,16
+	dep		r20=r21,r20,8,8		};;
+{ .mii;	dep		r16=r20,r16,32,16
+	dep		r22=r23,r22,8,8		};;
+{ .mii;	dep		r16=r22,r16,48,16
+	dep		r24=r25,r24,8,8		};;
+{ .mii;	dep		r26=r27,r26,8,8
+	dep		r28=r29,r28,8,8		};;
+{ .mii;	dep		r24=r26,r24,16,16
+	dep		r30=r31,r30,8,8		};;
+{ .mii;	st8		[r32]=r16,8			// ctx->r0
+	dep		r24=r28,r24,32,16;;
+	dep		r24=r30,r24,48,16	};;
+{ .mii;	st8		[r32]=r24,8			// ctx->r1
+	shr.u		r25=r24,2;;
+	add		r25=r25,r24		};;
+{ .mib; st8		[r32]=r25			// ctx->s1
+	mov		r8=0
+	br.ret.sptk	b0			};;
+.endp	poly1305_init#
+
+h0=r17;  h1=r18;  h2=r19;
+i0=r20;  i1=r21;
+HF0=f8;  HF1=f9;  HF2=f10;
+RF0=f11; RF1=f12; SF1=f13;
+
+.global	poly1305_blocks#
+.proc	poly1305_blocks#
+.align	64
+poly1305_blocks:
+	.prologue
+	.save		ar.pfs,r2
+{ .mii;	alloc		r2=ar.pfs,4,1,0,0
+	.save		ar.lc,r3
+	mov		r3=ar.lc
+	.save		pr,r36
+	mov		r36=pr			}
+
+	.body
+{ .mmi;	ADDP		r8=0,r32
+	ADDP		r9=8,r32
+	and		r29=7,r33		};;
+{ .mmi;	ld8		h0=[r8],16
+	ld8		h1=[r9],16
+	and		r33=-8,r33		};;
+{ .mmi;	ld8		h2=[r8],16
+	ldf8		RF0=[r9],16
+	shr.u		r34=r34,4		};;
+{ .mmi;	ldf8		RF1=[r8],-32
+	ldf8		SF1=[r9],-32
+	cmp.ltu		p16,p17=1,r34		};;
+{ .mmi;
+(p16)	add		r34=-2,r34
+(p17)	mov		r34=0
+	ADDP		r10=0,r33		}
+{ .mii;	ADDP		r11=8,r33
+(p16)	mov		ar.ec=2
+(p17)	mov		ar.ec=1			};;
+{ .mib;	RUM		1<<1				// go little-endian
+	mov		ar.lc=r34
+	brp.loop.imp	.Loop,.Lcend-16		}
+
+{ .mmi;	cmp.eq		p8,p7=0,r29
+	cmp.eq		p9,p0=1,r29
+	cmp.eq		p10,p0=2,r29		}
+{ .mmi;	cmp.eq		p11,p0=3,r29
+	cmp.eq		p12,p0=4,r29
+	cmp.eq		p13,p0=5,r29		}
+{ .mmi;	cmp.eq		p14,p0=6,r29
+	cmp.eq		p15,p0=7,r29
+	add		r16=16,r10		};;
+
+{ .mmb;
+(p8)	ld8		i0=[r10],16			// aligned input
+(p8)	ld8		i1=[r11],16
+(p8)	br.cond.sptk	.Loop			};;
+
+	// align first block
+	.pred.rel	"mutex",p8,p9,p10,p11,p12,p13,p14,p15
+{ .mmi;	(p7)	ld8		r14=[r10],24
+	(p7)	ld8		r15=[r11],24		}
+
+{ .mii;	(p7)	ld8		r16=[r16]
+		nop.i		0;;
+	(p15)	shrp		i0=r15,r14,56		}
+{ .mii;	(p15)	shrp		i1=r16,r15,56
+	(p14)	shrp		i0=r15,r14,48		}
+{ .mii;	(p14)	shrp		i1=r16,r15,48
+	(p13)	shrp		i0=r15,r14,40		}
+{ .mii;	(p13)	shrp		i1=r16,r15,40
+	(p12)	shrp		i0=r15,r14,32		}
+{ .mii;	(p12)	shrp		i1=r16,r15,32
+	(p11)	shrp		i0=r15,r14,24		}
+{ .mii;	(p11)	shrp		i1=r16,r15,24
+	(p10)	shrp		i0=r15,r14,16		}
+{ .mii;	(p10)	shrp		i1=r16,r15,16
+	(p9)	shrp		i0=r15,r14,8		}
+{ .mii;	(p9)	shrp		i1=r16,r15,8
+		mov		r14=r16			};;
+
+.Loop:
+		.pred.rel	"mutex",p8,p9,p10,p11,p12,p13,p14,p15
+{ .mmi;		add		h0=h0,i0
+		add		h1=h1,i1
+		add		h2=h2,r35		};;
+{ .mmi;		setf.sig	HF0=h0
+		cmp.ltu		p6,p0=h0,i0
+		cmp.ltu		p7,p0=h1,i1		};;
+{ .mmi;	(p6)	add		h1=1,h1;;
+		setf.sig	HF1=h1
+	(p6)	cmp.eq.or	p7,p0=0,h1		};;
+{ .mmi;	(p7)	add		h2=1,h2;;
+		setf.sig	HF2=h2			};;
+
+{ .mfi;	(p16)	ld8		r15=[r10],16
+		xmpy.lu		f32=HF0,RF0		}
+{ .mfi;	(p16)	ld8		r16=[r11],16
+		xmpy.hu		f33=HF0,RF0		}
+{ .mfi;		xmpy.lu		f36=HF0,RF1		}
+{ .mfi;		xmpy.hu		f37=HF0,RF1		};;
+{ .mfi;		xmpy.lu		f34=HF1,SF1
+	(p15)	shrp		i0=r15,r14,56		}
+{ .mfi;		xmpy.hu		f35=HF1,SF1		}
+{ .mfi;		xmpy.lu		f38=HF1,RF0
+	(p15)	shrp		i1=r16,r15,56		}
+{ .mfi;		xmpy.hu		f39=HF1,RF0		}
+{ .mfi;		xmpy.lu		f40=HF2,SF1
+	(p14)	shrp		i0=r15,r14,48		}
+{ .mfi;		xmpy.lu		f41=HF2,RF0		};;
+
+{ .mmi;		getf.sig	r22=f32
+		getf.sig	r23=f33
+	(p14)	shrp		i1=r16,r15,48		}
+{ .mmi;		getf.sig	r24=f34
+		getf.sig	r25=f35
+	(p13)	shrp		i0=r15,r14,40		}
+{ .mmi;		getf.sig	r26=f36
+		getf.sig	r27=f37
+	(p13)	shrp		i1=r16,r15,40		}
+{ .mmi;		getf.sig	r28=f38
+		getf.sig	r29=f39
+	(p12)	shrp		i0=r15,r14,32		}
+{ .mmi;		getf.sig	r30=f40
+		getf.sig	r31=f41			};;
+
+{ .mmi;		add		h0=r22,r24
+		add		r23=r23,r25
+	(p12)	shrp		i1=r16,r15,32		}
+{ .mmi;		add		h1=r26,r28
+		add		r27=r27,r29
+	(p11)	shrp		i0=r15,r14,24		};;
+{ .mmi;		cmp.ltu		p6,p0=h0,r24
+		cmp.ltu		p7,p0=h1,r28
+		add		r23=r23,r30		};;
+{ .mmi;	(p6)	add		r23=1,r23
+	(p7)	add		r27=1,r27
+	(p11)	shrp		i1=r16,r15,24		};;
+{ .mmi;		add		h1=h1,r23;;
+		cmp.ltu		p6,p7=h1,r23
+	(p10)	shrp		i0=r15,r14,16		};;
+{ .mmi;	(p6)	add		h2=r31,r27,1
+	(p7)	add		h2=r31,r27
+	(p10)	shrp		i1=r16,r15,16		};;
+
+{ .mmi;	(p8)	mov		i0=r15
+		and		r22=-4,h2
+		shr.u		r23=h2,2		};;
+{ .mmi;		add		r22=r22,r23
+		and		h2=3,h2
+	(p9)	shrp		i0=r15,r14,8		};;
+
+{ .mmi;		add		h0=h0,r22;;
+		cmp.ltu		p6,p0=h0,r22
+	(p9)	shrp		i1=r16,r15,8		};;
+{ .mmi;	(p8)	mov		i1=r16
+	(p6)	cmp.eq.unc	p7,p0=-1,h1
+	(p6)	add		h1=1,h1			};;
+{ .mmb;	(p7)	add		h2=1,h2
+		mov		r14=r16
+		br.ctop.sptk	.Loop			};;
+.Lcend:
+
+{ .mii;	SUM		1<<1				// back to big-endian
+	mov		ar.lc=r3		};;
+
+{ .mmi;	st8		[r8]=h0,16
+	st8		[r9]=h1
+	mov		pr=r36,0x1ffff		};;
+{ .mmb;	st8		[r8]=h2
+	rum		1<<5
+	br.ret.sptk	b0			};;
+.endp	poly1305_blocks#
+
+.global	poly1305_emit#
+.proc	poly1305_emit#
+.align	64
+poly1305_emit:
+	.prologue
+	.save		ar.pfs,r2
+{ .mmi;	alloc		r2=ar.pfs,3,0,0,0
+	ADDP		r8=0,r32
+	ADDP		r9=8,r32		};;
+
+	.body
+{ .mmi;	ld8		r16=[r8],16			// load hash
+	ld8		r17=[r9]
+	ADDP		r10=0,r34		};;
+{ .mmi;	ld8		r18=[r8]
+	ld4		r24=[r10],8			// load nonce
+	ADDP		r11=4,r34		};;
+
+{ .mmi;	ld4		r25=[r11],8
+	ld4		r26=[r10]
+	add		r20=5,r16		};;
+
+{ .mmi;	ld4		r27=[r11]
+	cmp.ltu		p6,p7=r20,r16
+	shl		r25=r25,32		};;
+{ .mmi;
+(p6)	add		r21=1,r17
+(p7)	add		r21=0,r17
+(p6)	cmp.eq.or.andcm	p6,p7=-1,r17		};;
+{ .mmi;
+(p6)	add		r22=1,r18
+(p7)	add		r22=0,r18
+	shl		r27=r27,32		};;
+{ .mmi;	or		r24=r24,r25
+	or		r26=r26,r27
+	cmp.leu		p6,p7=4,r22		};;
+{ .mmi;
+(p6)	add		r16=r20,r24
+(p7)	add		r16=r16,r24
+(p6)	add		r17=r21,r26		};;
+{ .mii;
+(p7)	add		r17=r17,r26
+	cmp.ltu		p6,p7=r16,r24;;
+(p6)	add		r17=1,r17		};;
+
+{ .mmi;	ADDP		r8=0,r33
+	ADDP		r9=4,r33
+	shr.u		r20=r16,32		}
+{ .mmi;	ADDP		r10=8,r33
+	ADDP		r11=12,r33
+	shr.u		r21=r17,32		};;
+
+{ .mmi;	st1		[r8]=r16,1			// write mac, little-endian
+	st1		[r9]=r20,1
+	shr.u		r16=r16,8		}
+{ .mii;	st1		[r10]=r17,1
+	shr.u		r20=r20,8
+	shr.u		r17=r17,8		}
+{ .mmi;	st1		[r11]=r21,1
+	shr.u		r21=r21,8		};;
+
+{ .mmi;	st1		[r8]=r16,1
+	st1		[r9]=r20,1
+	shr.u		r16=r16,8		}
+{ .mii;	st1		[r10]=r17,1
+	shr.u		r20=r20,8
+	shr.u		r17=r17,8		}
+{ .mmi;	st1		[r11]=r21,1
+	shr.u		r21=r21,8		};;
+
+{ .mmi;	st1		[r8]=r16,1
+	st1		[r9]=r20,1
+	shr.u		r16=r16,8		}
+{ .mii;	st1		[r10]=r17,1
+	shr.u		r20=r20,8
+	shr.u		r17=r17,8		}
+{ .mmi;	st1		[r11]=r21,1
+	shr.u		r21=r21,8		};;
+
+{ .mmi;	st1		[r8]=r16
+	st1		[r9]=r20		}
+{ .mmb;	st1		[r10]=r17
+	st1		[r11]=r21
+	br.ret.sptk	b0			};;
+.endp	poly1305_emit#
+
+stringz	"Poly1305 for IA64, CRYPTOGAMS by \@dot-asm"
diff --git a/crypto/poly1305/asm/poly1305-ia64.s b/crypto/poly1305/asm/poly1305-ia64.s
deleted file mode 100644
index 54d6454f0322..000000000000
--- a/crypto/poly1305/asm/poly1305-ia64.s
+++ /dev/null
@@ -1,365 +0,0 @@
-// ====================================================================
-// Written by Andy Polyakov, @dot-asm, initially for use in the OpenSSL
-// project.
-// ====================================================================
-//
-// Poly1305 for Itanium.
-//
-// January 2019
-//
-// Performance was reported to be ~2.1 cycles per byte on Itanium 2.
-// With exception for processors in 95xx family, which have higher
-// floating-point instructions' latencies and deliver ~2.6 cpb.
-// Comparison to compiler-generated code is not exactly fair, because
-// of different radixes. But just for reference, it was observed to be
-// >3x faster. Originally it was argued that floating-point base 2^32
-// implementation would be optimal. Upon closer look estimate for below
-// integer base 2^64 implementation turned to be approximately same on
-// Itanium 2. But floating-point code would be larger, and have higher
-// overhead, which would negatively affect small-block performance...
-
-#if defined(_HPUX_SOURCE)
-# if !defined(_LP64)
-#  define ADDP  addp4
-# else
-#  define ADDP  add
-# endif
-# define RUM    rum
-# define SUM    sum
-#else
-# define ADDP   add
-# define RUM    nop
-# define SUM    nop
-#endif
-
-.text
-.explicit
-
-.global	poly1305_init#
-.proc	poly1305_init#
-.align	64
-poly1305_init:
-	.prologue
-	.save		ar.pfs,r2
-{ .mmi;	alloc		r2=ar.pfs,2,0,0,0
-	cmp.eq		p6,p7=0,r33		}	// key == NULL?
-{ .mmi;	ADDP		r9=8,r32
-	ADDP		r10=16,r32
-	ADDP		r32=0,r32		};;
-	.body
-{ .mmi;	st8		[r32]=r0,24			// ctx->h0 = 0
-	st8		[r9]=r0				// ctx->h1 = 0
-(p7)	ADDP		r8=0,r33		}
-{ .mib;	st8		[r10]=r0			// ctx->h2 = 0
-(p6)	mov		r8=0
-(p6)	br.ret.spnt	b0			};;
-
-{ .mmi;	ADDP		r9=1,r33
-	ADDP		r10=2,r33
-	ADDP		r11=3,r33		};;
-{ .mmi;	ld1		r16=[r8],4			// load key, little-endian
-	ld1		r17=[r9],4		}
-{ .mmi;	ld1		r18=[r10],4
-	ld1		r19=[r11],4		};;
-{ .mmi;	ld1		r20=[r8],4
-	ld1		r21=[r9],4		}
-{ .mmi;	ld1		r22=[r10],4
-	ld1		r23=[r11],4
-	and		r19=15,r19		};;
-{ .mmi;	ld1		r24=[r8],4
-	ld1		r25=[r9],4
-	and		r20=-4,r20		}
-{ .mmi;	ld1		r26=[r10],4
-	ld1		r27=[r11],4
-	and		r23=15,r23		};;
-{ .mmi;	ld1		r28=[r8],4
-	ld1		r29=[r9],4
-	and		r24=-4,r24		}
-{ .mmi;	ld1		r30=[r10],4
-	ld1		r31=[r11],4
-	and		r27=15,r27		};;
-
-{ .mii;	and		r28=-4,r28
-	dep		r16=r17,r16,8,8
-	dep		r18=r19,r18,8,8		};;
-{ .mii;	and		r31=15,r31
-	dep		r16=r18,r16,16,16
-	dep		r20=r21,r20,8,8		};;
-{ .mii;	dep		r16=r20,r16,32,16
-	dep		r22=r23,r22,8,8		};;
-{ .mii;	dep		r16=r22,r16,48,16
-	dep		r24=r25,r24,8,8		};;
-{ .mii;	dep		r26=r27,r26,8,8
-	dep		r28=r29,r28,8,8		};;
-{ .mii;	dep		r24=r26,r24,16,16
-	dep		r30=r31,r30,8,8		};;
-{ .mii;	st8		[r32]=r16,8			// ctx->r0
-	dep		r24=r28,r24,32,16;;
-	dep		r24=r30,r24,48,16	};;
-{ .mii;	st8		[r32]=r24,8			// ctx->r1
-	shr.u		r25=r24,2;;
-	add		r25=r25,r24		};;
-{ .mib; st8		[r32]=r25			// ctx->s1
-	mov		r8=0
-	br.ret.sptk	b0			};;
-.endp	poly1305_init#
-
-h0=r17;  h1=r18;  h2=r19;
-i0=r20;  i1=r21;
-HF0=f8;  HF1=f9;  HF2=f10;
-RF0=f11; RF1=f12; SF1=f13;
-
-.global	poly1305_blocks#
-.proc	poly1305_blocks#
-.align	64
-poly1305_blocks:
-	.prologue
-	.save		ar.pfs,r2
-{ .mii;	alloc		r2=ar.pfs,4,1,0,0
-	.save		ar.lc,r3
-	mov		r3=ar.lc
-	.save		pr,r36
-	mov		r36=pr			}
-
-	.body
-{ .mmi;	ADDP		r8=0,r32
-	ADDP		r9=8,r32
-	and		r29=7,r33		};;
-{ .mmi;	ld8		h0=[r8],16
-	ld8		h1=[r9],16
-	and		r33=-8,r33		};;
-{ .mmi;	ld8		h2=[r8],16
-	ldf8		RF0=[r9],16
-	shr.u		r34=r34,4		};;
-{ .mmi;	ldf8		RF1=[r8],-32
-	ldf8		SF1=[r9],-32
-	cmp.ltu		p16,p17=1,r34		};;
-{ .mmi;
-(p16)	add		r34=-2,r34
-(p17)	mov		r34=0
-	ADDP		r10=0,r33		}
-{ .mii;	ADDP		r11=8,r33
-(p16)	mov		ar.ec=2
-(p17)	mov		ar.ec=1			};;
-{ .mib;	RUM		1<<1				// go little-endian
-	mov		ar.lc=r34
-	brp.loop.imp	.Loop,.Lcend-16		}
-
-{ .mmi;	cmp.eq		p8,p7=0,r29
-	cmp.eq		p9,p0=1,r29
-	cmp.eq		p10,p0=2,r29		}
-{ .mmi;	cmp.eq		p11,p0=3,r29
-	cmp.eq		p12,p0=4,r29
-	cmp.eq		p13,p0=5,r29		}
-{ .mmi;	cmp.eq		p14,p0=6,r29
-	cmp.eq		p15,p0=7,r29
-	add		r16=16,r10		};;
-
-{ .mmb;
-(p8)	ld8		i0=[r10],16			// aligned input
-(p8)	ld8		i1=[r11],16
-(p8)	br.cond.sptk	.Loop			};;
-
-	// align first block
-	.pred.rel	"mutex",p8,p9,p10,p11,p12,p13,p14,p15
-{ .mmi;	(p7)	ld8		r14=[r10],24
-	(p7)	ld8		r15=[r11],24		}
-
-{ .mii;	(p7)	ld8		r16=[r16]
-		nop.i		0;;
-	(p15)	shrp		i0=r15,r14,56		}
-{ .mii;	(p15)	shrp		i1=r16,r15,56
-	(p14)	shrp		i0=r15,r14,48		}
-{ .mii;	(p14)	shrp		i1=r16,r15,48
-	(p13)	shrp		i0=r15,r14,40		}
-{ .mii;	(p13)	shrp		i1=r16,r15,40
-	(p12)	shrp		i0=r15,r14,32		}
-{ .mii;	(p12)	shrp		i1=r16,r15,32
-	(p11)	shrp		i0=r15,r14,24		}
-{ .mii;	(p11)	shrp		i1=r16,r15,24
-	(p10)	shrp		i0=r15,r14,16		}
-{ .mii;	(p10)	shrp		i1=r16,r15,16
-	(p9)	shrp		i0=r15,r14,8		}
-{ .mii;	(p9)	shrp		i1=r16,r15,8
-		mov		r14=r16			};;
-
-.Loop:
-		.pred.rel	"mutex",p8,p9,p10,p11,p12,p13,p14,p15
-{ .mmi;		add		h0=h0,i0
-		add		h1=h1,i1
-		add		h2=h2,r35		};;
-{ .mmi;		setf.sig	HF0=h0
-		cmp.ltu		p6,p0=h0,i0
-		cmp.ltu		p7,p0=h1,i1		};;
-{ .mmi;	(p6)	add		h1=1,h1;;
-		setf.sig	HF1=h1
-	(p6)	cmp.eq.or	p7,p0=0,h1		};;
-{ .mmi;	(p7)	add		h2=1,h2;;
-		setf.sig	HF2=h2			};;
-
-{ .mfi;	(p16)	ld8		r15=[r10],16
-		xmpy.lu		f32=HF0,RF0		}
-{ .mfi;	(p16)	ld8		r16=[r11],16
-		xmpy.hu		f33=HF0,RF0		}
-{ .mfi;		xmpy.lu		f36=HF0,RF1		}
-{ .mfi;		xmpy.hu		f37=HF0,RF1		};;
-{ .mfi;		xmpy.lu		f34=HF1,SF1
-	(p15)	shrp		i0=r15,r14,56		}
-{ .mfi;		xmpy.hu		f35=HF1,SF1		}
-{ .mfi;		xmpy.lu		f38=HF1,RF0
-	(p15)	shrp		i1=r16,r15,56		}
-{ .mfi;		xmpy.hu		f39=HF1,RF0		}
-{ .mfi;		xmpy.lu		f40=HF2,SF1
-	(p14)	shrp		i0=r15,r14,48		}
-{ .mfi;		xmpy.lu		f41=HF2,RF0		};;
-
-{ .mmi;		getf.sig	r22=f32
-		getf.sig	r23=f33
-	(p14)	shrp		i1=r16,r15,48		}
-{ .mmi;		getf.sig	r24=f34
-		getf.sig	r25=f35
-	(p13)	shrp		i0=r15,r14,40		}
-{ .mmi;		getf.sig	r26=f36
-		getf.sig	r27=f37
-	(p13)	shrp		i1=r16,r15,40		}
-{ .mmi;		getf.sig	r28=f38
-		getf.sig	r29=f39
-	(p12)	shrp		i0=r15,r14,32		}
-{ .mmi;		getf.sig	r30=f40
-		getf.sig	r31=f41			};;
-
-{ .mmi;		add		h0=r22,r24
-		add		r23=r23,r25
-	(p12)	shrp		i1=r16,r15,32		}
-{ .mmi;		add		h1=r26,r28
-		add		r27=r27,r29
-	(p11)	shrp		i0=r15,r14,24		};;
-{ .mmi;		cmp.ltu		p6,p0=h0,r24
-		cmp.ltu		p7,p0=h1,r28
-		add		r23=r23,r30		};;
-{ .mmi;	(p6)	add		r23=1,r23
-	(p7)	add		r27=1,r27
-	(p11)	shrp		i1=r16,r15,24		};;
-{ .mmi;		add		h1=h1,r23;;
-		cmp.ltu		p6,p7=h1,r23
-	(p10)	shrp		i0=r15,r14,16		};;
-{ .mmi;	(p6)	add		h2=r31,r27,1
-	(p7)	add		h2=r31,r27
-	(p10)	shrp		i1=r16,r15,16		};;
-
-{ .mmi;	(p8)	mov		i0=r15
-		and		r22=-4,h2
-		shr.u		r23=h2,2		};;
-{ .mmi;		add		r22=r22,r23
-		and		h2=3,h2
-	(p9)	shrp		i0=r15,r14,8		};;
-
-{ .mmi;		add		h0=h0,r22;;
-		cmp.ltu		p6,p0=h0,r22
-	(p9)	shrp		i1=r16,r15,8		};;
-{ .mmi;	(p8)	mov		i1=r16
-	(p6)	cmp.eq.unc	p7,p0=-1,h1
-	(p6)	add		h1=1,h1			};;
-{ .mmb;	(p7)	add		h2=1,h2
-		mov		r14=r16
-		br.ctop.sptk	.Loop			};;
-.Lcend:
-
-{ .mii;	SUM		1<<1				// back to big-endian
-	mov		ar.lc=r3		};;
-
-{ .mmi;	st8		[r8]=h0,16
-	st8		[r9]=h1
-	mov		pr=r36,0x1ffff		};;
-{ .mmb;	st8		[r8]=h2
-	rum		1<<5
-	br.ret.sptk	b0			};;
-.endp	poly1305_blocks#
-
-.global	poly1305_emit#
-.proc	poly1305_emit#
-.align	64
-poly1305_emit:
-	.prologue
-	.save		ar.pfs,r2
-{ .mmi;	alloc		r2=ar.pfs,3,0,0,0
-	ADDP		r8=0,r32
-	ADDP		r9=8,r32		};;
-
-	.body
-{ .mmi;	ld8		r16=[r8],16			// load hash
-	ld8		r17=[r9]
-	ADDP		r10=0,r34		};;
-{ .mmi;	ld8		r18=[r8]
-	ld4		r24=[r10],8			// load nonce
-	ADDP		r11=4,r34		};;
-
-{ .mmi;	ld4		r25=[r11],8
-	ld4		r26=[r10]
-	add		r20=5,r16		};;
-
-{ .mmi;	ld4		r27=[r11]
-	cmp.ltu		p6,p7=r20,r16
-	shl		r25=r25,32		};;
-{ .mmi;
-(p6)	add		r21=1,r17
-(p7)	add		r21=0,r17
-(p6)	cmp.eq.or.andcm	p6,p7=-1,r17		};;
-{ .mmi;
-(p6)	add		r22=1,r18
-(p7)	add		r22=0,r18
-	shl		r27=r27,32		};;
-{ .mmi;	or		r24=r24,r25
-	or		r26=r26,r27
-	cmp.leu		p6,p7=4,r22		};;
-{ .mmi;
-(p6)	add		r16=r20,r24
-(p7)	add		r16=r16,r24
-(p6)	add		r17=r21,r26		};;
-{ .mii;
-(p7)	add		r17=r17,r26
-	cmp.ltu		p6,p7=r16,r24;;
-(p6)	add		r17=1,r17		};;
-
-{ .mmi;	ADDP		r8=0,r33
-	ADDP		r9=4,r33
-	shr.u		r20=r16,32		}
-{ .mmi;	ADDP		r10=8,r33
-	ADDP		r11=12,r33
-	shr.u		r21=r17,32		};;
-
-{ .mmi;	st1		[r8]=r16,1			// write mac, little-endian
-	st1		[r9]=r20,1
-	shr.u		r16=r16,8		}
-{ .mii;	st1		[r10]=r17,1
-	shr.u		r20=r20,8
-	shr.u		r17=r17,8		}
-{ .mmi;	st1		[r11]=r21,1
-	shr.u		r21=r21,8		};;
-
-{ .mmi;	st1		[r8]=r16,1
-	st1		[r9]=r20,1
-	shr.u		r16=r16,8		}
-{ .mii;	st1		[r10]=r17,1
-	shr.u		r20=r20,8
-	shr.u		r17=r17,8		}
-{ .mmi;	st1		[r11]=r21,1
-	shr.u		r21=r21,8		};;
-
-{ .mmi;	st1		[r8]=r16,1
-	st1		[r9]=r20,1
-	shr.u		r16=r16,8		}
-{ .mii;	st1		[r10]=r17,1
-	shr.u		r20=r20,8
-	shr.u		r17=r17,8		}
-{ .mmi;	st1		[r11]=r21,1
-	shr.u		r21=r21,8		};;
-
-{ .mmi;	st1		[r8]=r16
-	st1		[r9]=r20		}
-{ .mmb;	st1		[r10]=r17
-	st1		[r11]=r21
-	br.ret.sptk	b0			};;
-.endp	poly1305_emit#
-
-stringz	"Poly1305 for IA64, CRYPTOGAMS by \@dot-asm"
diff --git a/crypto/poly1305/build.info b/crypto/poly1305/build.info
index 212ab8c36c7d..e359a2225df5 100644
--- a/crypto/poly1305/build.info
+++ b/crypto/poly1305/build.info
@@ -2,10 +2,10 @@ LIBS=../../libcrypto
 
 $POLY1305ASM=
 IF[{- !$disabled{asm} -}]
-  $POLY1305ASM_x86=poly1305-x86.s
+  $POLY1305ASM_x86=poly1305-x86.S
   $POLY1305ASM_x86_64=poly1305-x86_64.s
 
-  $POLY1305ASM_ia64=asm/poly1305-ia64.s
+  $POLY1305ASM_ia64=poly1305-ia64.s
 
   $POLY1305ASM_sparcv9=poly1305-sparcv9.S
 
@@ -37,8 +37,9 @@ DEFINE[../../libcrypto]=$POLY1305DEF
 
 GENERATE[poly1305-sparcv9.S]=asm/poly1305-sparcv9.pl
 INCLUDE[poly1305-sparcv9.o]=..
-GENERATE[poly1305-x86.s]=asm/poly1305-x86.pl
+GENERATE[poly1305-x86.S]=asm/poly1305-x86.pl
 GENERATE[poly1305-x86_64.s]=asm/poly1305-x86_64.pl
+GENERATE[poly1305-ia64.s]=asm/poly1305-ia64.S
 GENERATE[poly1305-ppc.s]=asm/poly1305-ppc.pl
 GENERATE[poly1305-ppcfp.s]=asm/poly1305-ppcfp.pl
 GENERATE[poly1305-armv4.S]=asm/poly1305-armv4.pl
diff --git a/crypto/property/property.c b/crypto/property/property.c
index 509191a8936a..83f49d92d5b1 100644
--- a/crypto/property/property.c
+++ b/crypto/property/property.c
@@ -61,10 +61,16 @@ typedef struct {
 
 struct ossl_method_store_st {
     OSSL_LIB_CTX *ctx;
-    size_t nelem;
     SPARSE_ARRAY_OF(ALGORITHM) *algs;
-    int need_flush;
     CRYPTO_RWLOCK *lock;
+
+    /* query cache specific values */
+
+    /* Count of the query cache entries for all algs */
+    size_t cache_nelem;
+
+    /* Flag: 1 if query cache entries for all algs need flushing */
+    int cache_need_flush;
 };
 
 typedef struct {
@@ -82,6 +88,8 @@ typedef struct ossl_global_properties_st {
 #endif
 } OSSL_GLOBAL_PROPERTIES;
 
+static void ossl_method_cache_flush_alg(OSSL_METHOD_STORE *store,
+                                        ALGORITHM *alg);
 static void ossl_method_cache_flush(OSSL_METHOD_STORE *store, int nid);
 
 /* Global properties are stored per library context */
@@ -199,14 +207,24 @@ static void impl_cache_free(QUERY *elem)
     }
 }
 
-static void alg_cleanup(ossl_uintmax_t idx, ALGORITHM *a)
+static void impl_cache_flush_alg(ossl_uintmax_t idx, ALGORITHM *alg)
 {
+    lh_QUERY_doall(alg->cache, &impl_cache_free);
+    lh_QUERY_flush(alg->cache);
+}
+
+static void alg_cleanup(ossl_uintmax_t idx, ALGORITHM *a, void *arg)
+{
+    OSSL_METHOD_STORE *store = arg;
+
     if (a != NULL) {
         sk_IMPLEMENTATION_pop_free(a->impls, &impl_free);
         lh_QUERY_doall(a->cache, &impl_cache_free);
         lh_QUERY_free(a->cache);
         OPENSSL_free(a);
     }
+    if (store != NULL)
+        ossl_sa_ALGORITHM_set(store->algs, idx, NULL);
 }
 
 /*
@@ -236,7 +254,7 @@ OSSL_METHOD_STORE *ossl_method_store_new(OSSL_LIB_CTX *ctx)
 void ossl_method_store_free(OSSL_METHOD_STORE *store)
 {
     if (store != NULL) {
-        ossl_sa_ALGORITHM_doall(store->algs, &alg_cleanup);
+        ossl_sa_ALGORITHM_doall_arg(store->algs, &alg_cleanup, store);
         ossl_sa_ALGORITHM_free(store->algs);
         CRYPTO_THREAD_lock_free(store->lock);
         OPENSSL_free(store);
@@ -326,7 +344,7 @@ int ossl_method_store_add(OSSL_METHOD_STORE *store, const OSSL_PROVIDER *prov,
 
 err:
     ossl_property_unlock(store);
-    alg_cleanup(0, alg);
+    alg_cleanup(0, alg, NULL);
     impl_free(impl);
     return 0;
 }
@@ -368,6 +386,55 @@ int ossl_method_store_remove(OSSL_METHOD_STORE *store, int nid,
     return 0;
 }
 
+struct alg_cleanup_by_provider_data_st {
+    OSSL_METHOD_STORE *store;
+    const OSSL_PROVIDER *prov;
+};
+
+static void
+alg_cleanup_by_provider(ossl_uintmax_t idx, ALGORITHM *alg, void *arg)
+{
+    struct alg_cleanup_by_provider_data_st *data = arg;
+    int i, count;
+
+    /*
+     * We walk the stack backwards, to avoid having to deal with stack shifts
+     * caused by deletion
+     */
+    for (count = 0, i = sk_IMPLEMENTATION_num(alg->impls); i-- > 0;) {
+        IMPLEMENTATION *impl = sk_IMPLEMENTATION_value(alg->impls, i);
+
+        if (impl->provider == data->prov) {
+            impl_free(impl);
+            (void)sk_IMPLEMENTATION_delete(alg->impls, i);
+            count++;
+        }
+    }
+
+    /*
+     * If we removed any implementation, we also clear the whole associated
+     * cache, 'cause that's the sensible thing to do.
+     * There's no point flushing the cache entries where we didn't remove
+     * any implementation, though.
+     */
+    if (count > 0)
+        ossl_method_cache_flush_alg(data->store, alg);
+}
+
+int ossl_method_store_remove_all_provided(OSSL_METHOD_STORE *store,
+                                          const OSSL_PROVIDER *prov)
+{
+    struct alg_cleanup_by_provider_data_st data;
+
+    if (!ossl_property_write_lock(store))
+        return 0;
+    data.prov = prov;
+    data.store = store;
+    ossl_sa_ALGORITHM_doall_arg(store->algs, &alg_cleanup_by_provider, &data);
+    ossl_property_unlock(store);
+    return 1;
+}
+
 static void alg_do_one(ALGORITHM *alg, IMPLEMENTATION *impl,
                        void (*fn)(int id, void *method, void *fnarg),
                        void *fnarg)
@@ -486,41 +553,27 @@ int ossl_method_store_fetch(OSSL_METHOD_STORE *store,
     return ret;
 }
 
-static void impl_cache_flush_alg(ossl_uintmax_t idx, ALGORITHM *alg, void *arg)
+static void ossl_method_cache_flush_alg(OSSL_METHOD_STORE *store,
+                                        ALGORITHM *alg)
 {
-    SPARSE_ARRAY_OF(ALGORITHM) *algs = arg;
-
-    lh_QUERY_doall(alg->cache, &impl_cache_free);
-    if (algs != NULL) {
-        sk_IMPLEMENTATION_pop_free(alg->impls, &impl_free);
-        lh_QUERY_free(alg->cache);
-        OPENSSL_free(alg);
-        ossl_sa_ALGORITHM_set(algs, idx, NULL);
-    } else {
-        lh_QUERY_flush(alg->cache);
-    }
+    store->cache_nelem -= lh_QUERY_num_items(alg->cache);
+    impl_cache_flush_alg(0, alg);
 }
 
 static void ossl_method_cache_flush(OSSL_METHOD_STORE *store, int nid)
 {
     ALGORITHM *alg = ossl_method_store_retrieve(store, nid);
 
-    if (alg != NULL) {
-        ossl_provider_clear_all_operation_bits(store->ctx);
-        store->nelem -= lh_QUERY_num_items(alg->cache);
-        impl_cache_flush_alg(0, alg, NULL);
-    }
+    if (alg != NULL)
+        ossl_method_cache_flush_alg(store, alg);
 }
 
-int ossl_method_store_flush_cache(OSSL_METHOD_STORE *store, int all)
+int ossl_method_store_cache_flush_all(OSSL_METHOD_STORE *store)
 {
-    void *arg = (all != 0 ? store->algs : NULL);
-
     if (!ossl_property_write_lock(store))
         return 0;
-    ossl_provider_clear_all_operation_bits(store->ctx);
-    ossl_sa_ALGORITHM_doall_arg(store->algs, &impl_cache_flush_alg, arg);
-    store->nelem = 0;
+    ossl_sa_ALGORITHM_doall(store->algs, &impl_cache_flush_alg);
+    store->cache_nelem = 0;
     ossl_property_unlock(store);
     return 1;
 }
@@ -583,10 +636,9 @@ static void ossl_method_cache_flush_some(OSSL_METHOD_STORE *store)
     state.nelem = 0;
     if ((state.seed = OPENSSL_rdtsc()) == 0)
         state.seed = 1;
-    ossl_provider_clear_all_operation_bits(store->ctx);
-    store->need_flush = 0;
+    store->cache_need_flush = 0;
     ossl_sa_ALGORITHM_doall_arg(store->algs, &impl_cache_flush_one_alg, &state);
-    store->nelem = state.nelem;
+    store->cache_nelem = state.nelem;
 }
 
 int ossl_method_store_cache_get(OSSL_METHOD_STORE *store, OSSL_PROVIDER *prov,
@@ -637,7 +689,7 @@ int ossl_method_store_cache_set(OSSL_METHOD_STORE *store, OSSL_PROVIDER *prov,
 
     if (!ossl_property_write_lock(store))
         return 0;
-    if (store->need_flush)
+    if (store->cache_need_flush)
         ossl_method_cache_flush_some(store);
     alg = ossl_method_store_retrieve(store, nid);
     if (alg == NULL)
@@ -648,7 +700,7 @@ int ossl_method_store_cache_set(OSSL_METHOD_STORE *store, OSSL_PROVIDER *prov,
         elem.provider = prov;
         if ((old = lh_QUERY_delete(alg->cache, &elem)) != NULL) {
             impl_cache_free(old);
-            store->nelem--;
+            store->cache_nelem--;
         }
         goto end;
     }
@@ -667,8 +719,8 @@ int ossl_method_store_cache_set(OSSL_METHOD_STORE *store, OSSL_PROVIDER *prov,
             goto end;
         }
         if (!lh_QUERY_error(alg->cache)) {
-            if (++store->nelem >= IMPL_CACHE_FLUSH_THRESHOLD)
-                store->need_flush = 1;
+            if (++store->cache_nelem >= IMPL_CACHE_FLUSH_THRESHOLD)
+                store->cache_need_flush = 1;
             goto end;
         }
         ossl_method_free(&p->method);
diff --git a/crypto/provider_child.c b/crypto/provider_child.c
index 977ea4db3bf2..950ba2ef824f 100644
--- a/crypto/provider_child.c
+++ b/crypto/provider_child.c
@@ -279,9 +279,22 @@ void ossl_provider_deinit_child(OSSL_LIB_CTX *ctx)
     gbl->c_provider_deregister_child_cb(gbl->handle);
 }
 
+/*
+ * ossl_provider_up_ref_parent() and ossl_provider_free_parent() do
+ * nothing in "self-referencing" child providers, i.e. when the parent
+ * of the child provider is the same as the provider where this child
+ * provider was created.
+ * This allows the teardown function in the parent provider to be called
+ * at the correct moment.
+ * For child providers in other providers, the reference count is done to
+ * ensure that cross referencing is recorded.  These should be cleared up
+ * through that providers teardown, as part of freeing its child libctx.
+ */
+
 int ossl_provider_up_ref_parent(OSSL_PROVIDER *prov, int activate)
 {
     struct child_prov_globals *gbl;
+    const OSSL_CORE_HANDLE *parent_handle;
 
     gbl = ossl_lib_ctx_get_data(ossl_provider_libctx(prov),
                                 OSSL_LIB_CTX_CHILD_PROVIDER_INDEX,
@@ -289,12 +302,16 @@ int ossl_provider_up_ref_parent(OSSL_PROVIDER *prov, int activate)
     if (gbl == NULL)
         return 0;
 
-    return gbl->c_prov_up_ref(ossl_provider_get_parent(prov), activate);
+    parent_handle = ossl_provider_get_parent(prov);
+    if (parent_handle == gbl->handle)
+        return 1;
+    return gbl->c_prov_up_ref(parent_handle, activate);
 }
 
 int ossl_provider_free_parent(OSSL_PROVIDER *prov, int deactivate)
 {
     struct child_prov_globals *gbl;
+    const OSSL_CORE_HANDLE *parent_handle;
 
     gbl = ossl_lib_ctx_get_data(ossl_provider_libctx(prov),
                                 OSSL_LIB_CTX_CHILD_PROVIDER_INDEX,
@@ -302,5 +319,8 @@ int ossl_provider_free_parent(OSSL_PROVIDER *prov, int deactivate)
     if (gbl == NULL)
         return 0;
 
+    parent_handle = ossl_provider_get_parent(prov);
+    if (parent_handle == gbl->handle)
+        return 1;
     return gbl->c_prov_free(ossl_provider_get_parent(prov), deactivate);
 }
diff --git a/crypto/provider_core.c b/crypto/provider_core.c
index 177358f054ab..04c78a6b9862 100644
--- a/crypto/provider_core.c
+++ b/crypto/provider_core.c
@@ -15,7 +15,10 @@
 #include <openssl/params.h>
 #include <openssl/opensslv.h>
 #include "crypto/cryptlib.h"
-#include "crypto/evp.h" /* evp_method_store_flush */
+#include "crypto/decoder.h" /* ossl_decoder_store_cache_flush */
+#include "crypto/encoder.h" /* ossl_encoder_store_cache_flush */
+#include "crypto/evp.h" /* evp_method_store_cache_flush */
+#include "crypto/store.h" /* ossl_store_loader_store_cache_flush */
 #include "crypto/rand.h"
 #include "internal/nelem.h"
 #include "internal/thread_once.h"
@@ -455,7 +458,15 @@ static OSSL_PROVIDER *provider_new(const char *name,
 #ifndef HAVE_ATOMICS
         || (prov->refcnt_lock = CRYPTO_THREAD_lock_new()) == NULL
 #endif
-        || (prov->opbits_lock = CRYPTO_THREAD_lock_new()) == NULL
+       ) {
+        OPENSSL_free(prov);
+        ERR_raise(ERR_LIB_CRYPTO, ERR_R_MALLOC_FAILURE);
+        return NULL;
+    }
+
+    prov->refcnt = 1; /* 1 One reference to be returned */
+
+    if ((prov->opbits_lock = CRYPTO_THREAD_lock_new()) == NULL
         || (prov->flag_lock = CRYPTO_THREAD_lock_new()) == NULL
         || (prov->name = OPENSSL_strdup(name)) == NULL
         || (prov->parameters = sk_INFOPAIR_deep_copy(parameters,
@@ -466,7 +477,6 @@ static OSSL_PROVIDER *provider_new(const char *name,
         return NULL;
     }
 
-    prov->refcnt = 1; /* 1 One reference to be returned */
     prov->init_function = init_function;
 
     return prov;
@@ -1159,8 +1169,62 @@ static int provider_flush_store_cache(const OSSL_PROVIDER *prov)
     freeing = store->freeing;
     CRYPTO_THREAD_unlock(store->lock);
 
-    if (!freeing)
-        return evp_method_store_flush(prov->libctx);
+    if (!freeing) {
+        int acc
+            = evp_method_store_cache_flush(prov->libctx)
+#ifndef FIPS_MODULE
+            + ossl_encoder_store_cache_flush(prov->libctx)
+            + ossl_decoder_store_cache_flush(prov->libctx)
+            + ossl_store_loader_store_cache_flush(prov->libctx)
+#endif
+            ;
+
+#ifndef FIPS_MODULE
+        return acc == 4;
+#else
+        return acc == 1;
+#endif
+    }
+    return 1;
+}
+
+static int provider_remove_store_methods(OSSL_PROVIDER *prov)
+{
+    struct provider_store_st *store;
+    int freeing;
+
+    if ((store = get_provider_store(prov->libctx)) == NULL)
+        return 0;
+
+    if (!CRYPTO_THREAD_read_lock(store->lock))
+        return 0;
+    freeing = store->freeing;
+    CRYPTO_THREAD_unlock(store->lock);
+
+    if (!freeing) {
+        int acc;
+
+        if (!CRYPTO_THREAD_read_lock(prov->opbits_lock))
+            return 0;
+        OPENSSL_free(prov->operation_bits);
+        prov->operation_bits = NULL;
+        prov->operation_bits_sz = 0;
+        CRYPTO_THREAD_unlock(prov->opbits_lock);
+
+        acc = evp_method_store_remove_all_provided(prov)
+#ifndef FIPS_MODULE
+            + ossl_encoder_store_remove_all_provided(prov)
+            + ossl_decoder_store_remove_all_provided(prov)
+            + ossl_store_loader_store_remove_all_provided(prov)
+#endif
+            ;
+
+#ifndef FIPS_MODULE
+        return acc == 4;
+#else
+        return acc == 1;
+#endif
+    }
     return 1;
 }
 
@@ -1191,7 +1255,7 @@ int ossl_provider_deactivate(OSSL_PROVIDER *prov, int removechildren)
     if (prov == NULL
             || (count = provider_deactivate(prov, 1, removechildren)) < 0)
         return 0;
-    return count == 0 ? provider_flush_store_cache(prov) : 1;
+    return count == 0 ? provider_remove_store_methods(prov) : 1;
 }
 
 void *ossl_provider_ctx(const OSSL_PROVIDER *prov)
@@ -1352,8 +1416,10 @@ int ossl_provider_doall_activated(OSSL_LIB_CTX *ctx,
     for (curr = 0; curr < max; curr++) {
         OSSL_PROVIDER *prov = sk_OSSL_PROVIDER_value(provs, curr);
 
-        if (!cb(prov, cbdata))
+        if (!cb(prov, cbdata)) {
+            curr = -1;
             goto finish;
+        }
     }
     curr = -1;
 
@@ -1500,7 +1566,7 @@ int ossl_provider_self_test(const OSSL_PROVIDER *prov)
         return 1;
     ret = prov->self_test(prov->provctx);
     if (ret == 0)
-        (void)provider_flush_store_cache(prov);
+        (void)provider_remove_store_methods((OSSL_PROVIDER *)prov);
     return ret;
 }
 
@@ -1538,33 +1604,6 @@ void ossl_provider_unquery_operation(const OSSL_PROVIDER *prov,
         prov->unquery_operation(prov->provctx, operation_id, algs);
 }
 
-int ossl_provider_clear_all_operation_bits(OSSL_LIB_CTX *libctx)
-{
-    struct provider_store_st *store;
-    OSSL_PROVIDER *provider;
-    int i, num, res = 1;
-
-    if ((store = get_provider_store(libctx)) != NULL) {
-        if (!CRYPTO_THREAD_read_lock(store->lock))
-            return 0;
-        num = sk_OSSL_PROVIDER_num(store->providers);
-        for (i = 0; i < num; i++) {
-            provider = sk_OSSL_PROVIDER_value(store->providers, i);
-            if (!CRYPTO_THREAD_write_lock(provider->opbits_lock)) {
-                res = 0;
-                continue;
-            }
-            if (provider->operation_bits != NULL)
-                memset(provider->operation_bits, 0,
-                       provider->operation_bits_sz);
-            CRYPTO_THREAD_unlock(provider->opbits_lock);
-        }
-        CRYPTO_THREAD_unlock(store->lock);
-        return res;
-    }
-    return 0;
-}
-
 int ossl_provider_set_operation_bit(OSSL_PROVIDER *provider, size_t bitnum)
 {
     size_t byte = bitnum / 8;
diff --git a/crypto/rand/rand_egd.c b/crypto/rand/rand_egd.c
index 2067ececaf09..c0038d71ef5d 100644
--- a/crypto/rand/rand_egd.c
+++ b/crypto/rand/rand_egd.c
@@ -40,11 +40,7 @@ int RAND_egd_bytes(const char *path, int bytes)
 # include <sys/types.h>
 # include <sys/socket.h>
 # ifndef NO_SYS_UN_H
-#  ifdef OPENSSL_SYS_VXWORKS
-#   include <streams/un.h>
-#  else
-#   include <sys/un.h>
-#  endif
+#  include <sys/un.h>
 # else
 struct sockaddr_un {
     short sun_family;           /* AF_UNIX */
diff --git a/crypto/rc4/build.info b/crypto/rc4/build.info
index c7f17ca5f55b..14ec94f9f2a7 100644
--- a/crypto/rc4/build.info
+++ b/crypto/rc4/build.info
@@ -2,7 +2,7 @@ LIBS=../../libcrypto
 
 $RC4ASM=rc4_enc.c rc4_skey.c
 IF[{- !$disabled{asm} -}]
-  $RC4ASM_x86=rc4-586.s
+  $RC4ASM_x86=rc4-586.S
   $RC4ASM_x86_64=rc4-x86_64.s rc4-md5-x86_64.s
   $RC4ASM_s390x=rc4-s390x.s
   $RC4ASM_parisc11=rc4-parisc.s
@@ -25,8 +25,8 @@ IF[{- $disabled{'deprecated-3.0'} -}]
   SOURCE[../../providers/liblegacy.a]=$RC4ASM
 ENDIF
 
-GENERATE[rc4-586.s]=asm/rc4-586.pl
-DEPEND[rc4-586.s]=../perlasm/x86asm.pl
+GENERATE[rc4-586.S]=asm/rc4-586.pl
+DEPEND[rc4-586.S]=../perlasm/x86asm.pl
 
 GENERATE[rc4-x86_64.s]=asm/rc4-x86_64.pl
 GENERATE[rc4-md5-x86_64.s]=asm/rc4-md5-x86_64.pl
diff --git a/crypto/rc5/build.info b/crypto/rc5/build.info
index 3e2def8a65b5..96ed42d2cbf7 100644
--- a/crypto/rc5/build.info
+++ b/crypto/rc5/build.info
@@ -2,7 +2,7 @@ LIBS=../../libcrypto
 
 $RC5ASM=rc5_enc.c
 IF[{- !$disabled{asm} -}]
-  $RC5ASM_x86=rc5-586.s
+  $RC5ASM_x86=rc5-586.S
 
   # Now that we have defined all the arch specific variables, use the
   # appropriate one, and define the appropriate macros
@@ -22,5 +22,5 @@ IF[{- $disabled{'deprecated-3.0'} -}]
   SOURCE[../../providers/liblegacy.a]=$ALL
 ENDIF
 
-GENERATE[rc5-586.s]=asm/rc5-586.pl
-DEPEND[rc5-586.s]=../perlasm/x86asm.pl ../perlasm/cbc.pl
+GENERATE[rc5-586.S]=asm/rc5-586.pl
+DEPEND[rc5-586.S]=../perlasm/x86asm.pl ../perlasm/cbc.pl
diff --git a/crypto/ripemd/build.info b/crypto/ripemd/build.info
index f1845733a863..03f1f9863285 100644
--- a/crypto/ripemd/build.info
+++ b/crypto/ripemd/build.info
@@ -2,7 +2,7 @@ LIBS=../../libcrypto
 
 $RMD160ASM=
 IF[{- !$disabled{asm} -}]
-  $RMD160ASM_x86=rmd-586.s
+  $RMD160ASM_x86=rmd-586.S
 
   # Now that we have defined all the arch specific variables, use the
   # appropriate one, and define the appropriate macros
@@ -25,5 +25,5 @@ IF[{- $disabled{'deprecated-3.0'} -}]
   DEFINE[../../providers/liblegacy.a]=$RMD160DEF
 ENDIF
 
-GENERATE[rmd-586.s]=asm/rmd-586.pl
-DEPEND[rmd-586.s]=../perlasm/x86asm.pl
+GENERATE[rmd-586.S]=asm/rmd-586.pl
+DEPEND[rmd-586.S]=../perlasm/x86asm.pl
diff --git a/crypto/rsa/rsa_ameth.c b/crypto/rsa/rsa_ameth.c
index aabeb32736ce..6980176b5a7c 100644
--- a/crypto/rsa/rsa_ameth.c
+++ b/crypto/rsa/rsa_ameth.c
@@ -454,7 +454,7 @@ static RSA_PSS_PARAMS *rsa_ctx_to_pss(EVP_PKEY_CTX *pkctx)
         return NULL;
     if (EVP_PKEY_CTX_get_rsa_mgf1_md(pkctx, &mgf1md) <= 0)
         return NULL;
-    if (!EVP_PKEY_CTX_get_rsa_pss_saltlen(pkctx, &saltlen))
+    if (EVP_PKEY_CTX_get_rsa_pss_saltlen(pkctx, &saltlen) <= 0)
         return NULL;
     if (saltlen == -1) {
         saltlen = EVP_MD_get_size(sigmd);
diff --git a/crypto/rsa/rsa_lib.c b/crypto/rsa/rsa_lib.c
index a8a6d6c758e9..e7a3c59e81a9 100644
--- a/crypto/rsa/rsa_lib.c
+++ b/crypto/rsa/rsa_lib.c
@@ -1084,6 +1084,7 @@ int EVP_PKEY_CTX_get_rsa_mgf1_md(EVP_PKEY_CTX *ctx, const EVP_MD **md)
 int EVP_PKEY_CTX_set0_rsa_oaep_label(EVP_PKEY_CTX *ctx, void *label, int llen)
 {
     OSSL_PARAM rsa_params[2], *p = rsa_params;
+    int ret;
 
     if (ctx == NULL || !EVP_PKEY_CTX_IS_ASYM_CIPHER_OP(ctx)) {
         ERR_raise(ERR_LIB_EVP, EVP_R_COMMAND_NOT_SUPPORTED);
@@ -1100,8 +1101,9 @@ int EVP_PKEY_CTX_set0_rsa_oaep_label(EVP_PKEY_CTX *ctx, void *label, int llen)
                                              (void *)label, (size_t)llen);
     *p++ = OSSL_PARAM_construct_end();
 
-    if (!evp_pkey_ctx_set_params_strict(ctx, rsa_params))
-        return 0;
+    ret = evp_pkey_ctx_set_params_strict(ctx, rsa_params);
+    if (ret <= 0)
+        return ret;
 
     /* Ownership is supposed to be transfered to the callee. */
     OPENSSL_free(label);
diff --git a/crypto/sha/build.info b/crypto/sha/build.info
index 5d988e7ab51b..f3e38284ad35 100644
--- a/crypto/sha/build.info
+++ b/crypto/sha/build.info
@@ -2,7 +2,7 @@ LIBS=../../libcrypto
 
 $SHA1ASM=
 IF[{- !$disabled{asm} -}]
-  $SHA1ASM_x86=sha1-586.s sha256-586.s sha512-586.s
+  $SHA1ASM_x86=sha1-586.S sha256-586.S sha512-586.S
   $SHA1DEF_x86=SHA1_ASM SHA256_ASM SHA512_ASM
   $SHA1ASM_x86_64=\
         sha1-x86_64.s sha256-x86_64.s sha512-x86_64.s sha1-mb-x86_64.s \
@@ -83,12 +83,12 @@ SOURCE[../../providers/libfips.a]= $COMMON
 DEFINE[../../libcrypto]=$SHA1DEF $KECCAK1600DEF
 DEFINE[../../providers/libfips.a]=$SHA1DEF $KECCAK1600DEF
 
-GENERATE[sha1-586.s]=asm/sha1-586.pl
-DEPEND[sha1-586.s]=../perlasm/x86asm.pl
-GENERATE[sha256-586.s]=asm/sha256-586.pl
-DEPEND[sha256-586.s]=../perlasm/x86asm.pl
-GENERATE[sha512-586.s]=asm/sha512-586.pl
-DEPEND[sha512-586.s]=../perlasm/x86asm.pl
+GENERATE[sha1-586.S]=asm/sha1-586.pl
+DEPEND[sha1-586.S]=../perlasm/x86asm.pl
+GENERATE[sha256-586.S]=asm/sha256-586.pl
+DEPEND[sha256-586.S]=../perlasm/x86asm.pl
+GENERATE[sha512-586.S]=asm/sha512-586.pl
+DEPEND[sha512-586.S]=../perlasm/x86asm.pl
 
 GENERATE[sha1-ia64.s]=asm/sha1-ia64.pl
 GENERATE[sha256-ia64.s]=asm/sha512-ia64.pl
diff --git a/crypto/store/store_meth.c b/crypto/store/store_meth.c
index db13f62c66ea..a472b15bb662 100644
--- a/crypto/store/store_meth.c
+++ b/crypto/store/store_meth.c
@@ -395,6 +395,25 @@ OSSL_STORE_LOADER *ossl_store_loader_fetch_by_number(OSSL_LIB_CTX *libctx,
     return method;
 }
 
+int ossl_store_loader_store_cache_flush(OSSL_LIB_CTX *libctx)
+{
+    OSSL_METHOD_STORE *store = get_loader_store(libctx);
+
+    if (store != NULL)
+        return ossl_method_store_cache_flush_all(store);
+    return 1;
+}
+
+int ossl_store_loader_store_remove_all_provided(const OSSL_PROVIDER *prov)
+{
+    OSSL_LIB_CTX *libctx = ossl_provider_libctx(prov);
+    OSSL_METHOD_STORE *store = get_loader_store(libctx);
+
+    if (store != NULL)
+        return ossl_method_store_remove_all_provided(store, prov);
+    return 1;
+}
+
 /*
  * Library of basic method functions
  */
diff --git a/crypto/ui/ui_util.c b/crypto/ui/ui_util.c
index 54fa43f0cc2e..80297969ab1d 100644
--- a/crypto/ui/ui_util.c
+++ b/crypto/ui/ui_util.c
@@ -153,7 +153,7 @@ UI_METHOD *UI_UTIL_wrap_read_pem_callback(pem_password_cb *cb, int rwflag)
         || UI_method_set_writer(ui_method, ui_write) < 0
         || UI_method_set_closer(ui_method, ui_close) < 0
         || !RUN_ONCE(&get_index_once, ui_method_data_index_init)
-        || UI_method_set_ex_data(ui_method, ui_method_data_index, data) < 0) {
+        || !UI_method_set_ex_data(ui_method, ui_method_data_index, data)) {
         UI_destroy_method(ui_method);
         OPENSSL_free(data);
         return NULL;
diff --git a/crypto/whrlpool/build.info b/crypto/whrlpool/build.info
index ab6cef294568..137f6dc6c674 100644
--- a/crypto/whrlpool/build.info
+++ b/crypto/whrlpool/build.info
@@ -3,7 +3,7 @@ LIBS=../../libcrypto
 $WPASM=wp_block.c
 IF[{- !$disabled{asm} -}]
   IF[{- $config{processor} ne "386" -}]
-    $WPASM_x86=wp_block.c wp-mmx.s
+    $WPASM_x86=wp_block.c wp-mmx.S
     $WPDEF_x86=WHIRLPOOL_ASM
   ENDIF
   $WPASM_x86_64=wp-x86_64.s
@@ -27,7 +27,7 @@ IF[{- $disabled{'deprecated-3.0'} -}]
   DEFINE[../../providers/liblegacy.a]=$WPDEF
 ENDIF
 
-GENERATE[wp-mmx.s]=asm/wp-mmx.pl
-DEPEND[wp-mmx.s]=../perlasm/x86asm.pl
+GENERATE[wp-mmx.S]=asm/wp-mmx.pl
+DEPEND[wp-mmx.S]=../perlasm/x86asm.pl
 
 GENERATE[wp-x86_64.s]=asm/wp-x86_64.pl
diff --git a/crypto/x509/v3_addr.c b/crypto/x509/v3_addr.c
index 8bb35bd8a350..feefb9c3dff4 100644
--- a/crypto/x509/v3_addr.c
+++ b/crypto/x509/v3_addr.c
@@ -1099,7 +1099,7 @@ static int addr_contains(IPAddressOrRanges *parent,
     for (c = 0; c < sk_IPAddressOrRange_num(child); c++) {
         if (!extract_min_max(sk_IPAddressOrRange_value(child, c),
                              c_min, c_max, length))
-            return -1;
+            return 0;
         for (;; p++) {
             if (p >= sk_IPAddressOrRange_num(parent))
                 return 0;
diff --git a/crypto/x509/x509_cmp.c b/crypto/x509/x509_cmp.c
index f3d58cdfa613..9f5b9403f225 100644
--- a/crypto/x509/x509_cmp.c
+++ b/crypto/x509/x509_cmp.c
@@ -39,7 +39,7 @@ unsigned long X509_issuer_and_serial_hash(X509 *a)
     unsigned long ret = 0;
     EVP_MD_CTX *ctx = EVP_MD_CTX_new();
     unsigned char md[16];
-    char *f;
+    char *f = NULL;
     EVP_MD *digest = NULL;
 
     if (ctx == NULL)
@@ -55,7 +55,6 @@ unsigned long X509_issuer_and_serial_hash(X509 *a)
         goto err;
     if (!EVP_DigestUpdate(ctx, (unsigned char *)f, strlen(f)))
         goto err;
-    OPENSSL_free(f);
     if (!EVP_DigestUpdate
         (ctx, (unsigned char *)a->cert_info.serialNumber.data,
          (unsigned long)a->cert_info.serialNumber.length))
@@ -66,6 +65,7 @@ unsigned long X509_issuer_and_serial_hash(X509 *a)
            ((unsigned long)md[2] << 16L) | ((unsigned long)md[3] << 24L)
         ) & 0xffffffffL;
  err:
+    OPENSSL_free(f);
     EVP_MD_free(digest);
     EVP_MD_CTX_free(ctx);
     return ret;
diff --git a/crypto/x509/x_crl.c b/crypto/x509/x_crl.c
index d77746a2b2d7..3e358a4096fd 100644
--- a/crypto/x509/x_crl.c
+++ b/crypto/x509/x_crl.c
@@ -103,13 +103,17 @@ static int crl_set_issuers(X509_CRL *crl)
 
         if (gtmp) {
             gens = gtmp;
-            if (!crl->issuers) {
+            if (crl->issuers == NULL) {
                 crl->issuers = sk_GENERAL_NAMES_new_null();
-                if (!crl->issuers)
+                if (crl->issuers == NULL) {
+                    GENERAL_NAMES_free(gtmp);
                     return 0;
+                }
             }
-            if (!sk_GENERAL_NAMES_push(crl->issuers, gtmp))
+            if (!sk_GENERAL_NAMES_push(crl->issuers, gtmp)) {
+                GENERAL_NAMES_free(gtmp);
                 return 0;
+            }
         }
         rev->issuer = gens;
 
@@ -255,7 +259,7 @@ static int crl_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
         break;
 
     case ASN1_OP_FREE_POST:
-        if (crl->meth->crl_free) {
+        if (crl->meth != NULL && crl->meth->crl_free != NULL) {
             if (!crl->meth->crl_free(crl))
                 return 0;
         }
diff --git a/doc/internal/man3/OSSL_METHOD_STORE.pod b/doc/internal/man3/OSSL_METHOD_STORE.pod
index 49b3459ab254..70f6eb520ff3 100644
--- a/doc/internal/man3/OSSL_METHOD_STORE.pod
+++ b/doc/internal/man3/OSSL_METHOD_STORE.pod
@@ -4,9 +4,10 @@
 
 OSSL_METHOD_STORE, ossl_method_store_new, ossl_method_store_free,
 ossl_method_store_init, ossl_method_store_cleanup,
-ossl_method_store_add, ossl_method_store_remove, ossl_method_store_fetch,
+ossl_method_store_add, ossl_method_store_fetch,
+ossl_method_store_remove, ossl_method_store_remove_all_provided, 
 ossl_method_store_cache_get, ossl_method_store_cache_set,
-ossl_method_store_flush_cache
+ossl_method_store_cache_flush_all
 - implementation method store and query
 
 =head1 SYNOPSIS
@@ -28,13 +29,16 @@ ossl_method_store_flush_cache
  int ossl_method_store_fetch(OSSL_METHOD_STORE *store,
                              int nid, const char *properties,
                              void **method, const OSSL_PROVIDER **prov_rw);
+ int ossl_method_store_remove_all_provided(OSSL_METHOD_STORE *store,
+                                           const OSSL_PROVIDER *prov);
+
  int ossl_method_store_cache_get(OSSL_METHOD_STORE *store, OSSL_PROVIDER *prov,
                                  int nid, const char *prop_query, void **method);
  int ossl_method_store_cache_set(OSSL_METHOD_STORE *store, OSSL_PROVIDER *prov,
                                  int nid, const char *prop_query, void *method,
                                  int (*method_up_ref)(void *),
                                  void (*method_destruct)(void *));
- void ossl_method_store_flush_cache(OSSL_METHOD_STORE *store, int all);
+ void ossl_method_store_cache_flush_all(OSSL_METHOD_STORE *store);
 
 =head1 DESCRIPTION
 
@@ -83,8 +87,9 @@ I<*prop> may be a pointer to a provider, which will narrow the search
 to methods from that provider.
 The result, if any, is returned in I<*method>, and its provider in I<*prov>.
 
-ossl_method_store_flush_cache() flushes all cached entries associated with
-I<store>.
+ossl_method_store_remove_all_provided() removes all methods from I<store>
+that are provided by I<prov>.
+When doing so, it also flushes the corresponding cache entries.
 
 =head2 Cache Functions
 
@@ -102,6 +107,9 @@ The I<method_up_ref> function is called to increment the
 reference count of the method and the I<method_destruct> function is called
 to decrement it.
 
+ossl_method_store_cache_flush_all() flushes all cached entries associated with
+I<store>.
+
 =head1 NOTES
 
 The I<prop_query> argument to ossl_method_store_cache_get() and
diff --git a/doc/internal/man3/ossl_provider_new.pod b/doc/internal/man3/ossl_provider_new.pod
index 0cf51a163f61..3abcfc695d24 100644
--- a/doc/internal/man3/ossl_provider_new.pod
+++ b/doc/internal/man3/ossl_provider_new.pod
@@ -16,7 +16,7 @@ ossl_provider_name, ossl_provider_dso,
 ossl_provider_module_name, ossl_provider_module_path,
 ossl_provider_libctx,
 ossl_provider_teardown, ossl_provider_gettable_params,
-ossl_provider_get_params, ossl_provider_clear_all_operation_bits,
+ossl_provider_get_params,
 ossl_provider_query_operation, ossl_provider_unquery_operation,
 ossl_provider_set_operation_bit, ossl_provider_test_operation_bit,
 ossl_provider_get_capabilities
@@ -94,7 +94,6 @@ ossl_provider_get_capabilities
  int ossl_provider_set_operation_bit(OSSL_PROVIDER *provider, size_t bitnum);
  int ossl_provider_test_operation_bit(OSSL_PROVIDER *provider, size_t bitnum,
                                       int *result);
- int ossl_provider_clear_all_operation_bits(OSSL_LIB_CTX *libctx);
 
  int ossl_provider_init_as_child(OSSL_LIB_CTX *ctx,
                                  const OSSL_CORE_HANDLE *handle,
@@ -300,9 +299,6 @@ ossl_provider_test_operation_bit() checks if the bit operation I<bitnum>
 is set (1) or not (0) in the internal I<provider> bitstring, and sets
 I<*result> to 1 or 0 accorddingly.
 
-ossl_provider_clear_all_operation_bits() clears all of the operation bits
-to (0) for all providers in the library context I<libctx>.
-
 ossl_provider_init_as_child() stores in the library context I<ctx> references to
 the necessary upcalls for managing child providers. The I<handle> and I<in>
 parameters are the B<OSSL_CORE_HANDLE> and B<OSSL_DISPATCH> pointers that were
@@ -380,8 +376,6 @@ If this function isn't available in the provider, 0 is returned.
 ossl_provider_set_operation_bit() and ossl_provider_test_operation_bit()
 return 1 on success, or 0 on error.
 
-ossl_provider_clear_all_operation_bits() returns 1 on success, or 0 on error.
-
 ossl_provider_get_capabilities() returns 1 on success, or 0 on error.
 If this function isn't available in the provider or the provider does not
 support the requested capability then 0 is returned.
diff --git a/doc/man1/openssl-s_client.pod.in b/doc/man1/openssl-s_client.pod.in
index 6328cd07d977..f2a5a3a8edd8 100644
--- a/doc/man1/openssl-s_client.pod.in
+++ b/doc/man1/openssl-s_client.pod.in
@@ -85,6 +85,7 @@ B<openssl> B<s_client>
 [B<-no_comp>]
 [B<-brief>]
 [B<-legacy_server_connect>]
+[B<-no_legacy_server_connect>]
 [B<-allow_no_dhe_kex>]
 [B<-sigalgs> I<sigalglist>]
 [B<-curves> I<curvelist>]
diff --git a/doc/man1/openssl-s_server.pod.in b/doc/man1/openssl-s_server.pod.in
index 115eceb0e32a..ce2c46cf53f2 100644
--- a/doc/man1/openssl-s_server.pod.in
+++ b/doc/man1/openssl-s_server.pod.in
@@ -98,7 +98,6 @@ B<openssl> B<s_server>
 [B<-legacy_renegotiation>]
 [B<-no_renegotiation>]
 [B<-no_resumption_on_reneg>]
-[B<-no_legacy_server_connect>]
 [B<-allow_no_dhe_kex>]
 [B<-prioritize_chacha>]
 [B<-strict>]
diff --git a/doc/man3/BIO_ctrl.pod b/doc/man3/BIO_ctrl.pod
index 84efd23746bb..d07d8db61484 100644
--- a/doc/man3/BIO_ctrl.pod
+++ b/doc/man3/BIO_ctrl.pod
@@ -77,9 +77,9 @@ return a size_t type and are functions, BIO_pending() and BIO_wpending() are
 macros which call BIO_ctrl().
 
 BIO_get_ktls_send() returns 1 if the BIO is using the Kernel TLS data-path for
-sending. Otherwise, it returns zero. It also returns negative values for failure.
+sending. Otherwise, it returns zero.
 BIO_get_ktls_recv() returns 1 if the BIO is using the Kernel TLS data-path for
-receiving. Otherwise, it returns zero. It also returns negative values for failure.
+receiving. Otherwise, it returns zero.
 
 =head1 RETURN VALUES
 
@@ -141,8 +141,8 @@ the case of BIO_seek() on a file BIO for a successful operation.
 
 =head1 HISTORY
 
-The BIO_get_ktls_send() and BIO_get_ktls_recv() functions were added in
-OpenSSL 3.0.
+The BIO_get_ktls_send() and BIO_get_ktls_recv() macros were added in
+OpenSSL 3.0. They were modified to never return -1 in OpenSSL 3.0.4.
 
 =head1 COPYRIGHT
 
diff --git a/doc/man3/DSA_sign.pod b/doc/man3/DSA_sign.pod
index ad5f108c9096..dadd6d5cbf55 100644
--- a/doc/man3/DSA_sign.pod
+++ b/doc/man3/DSA_sign.pod
@@ -58,7 +58,7 @@ L<ERR_get_error(3)>.
 
 =head1 CONFORMING TO
 
-US Federal Information Processing Standard FIPS 186 (Digital Signature
+US Federal Information Processing Standard FIPS186-4 (Digital Signature
 Standard, DSS), ANSI X9.30
 
 =head1 SEE ALSO
diff --git a/doc/man3/ECDSA_SIG_new.pod b/doc/man3/ECDSA_SIG_new.pod
index 12f0d4af8db0..d66deab385f4 100644
--- a/doc/man3/ECDSA_SIG_new.pod
+++ b/doc/man3/ECDSA_SIG_new.pod
@@ -46,7 +46,7 @@ hidden entirely by defining B<OPENSSL_API_COMPAT> with a suitable version value,
 =head1 DESCRIPTION
 
 B<ECDSA_SIG> is an opaque structure consisting of two BIGNUMs for the
-I<r> and I<s> value of an ECDSA signature (see X9.62 or FIPS 186-2).
+I<r> and I<s> value of an ECDSA signature (see X9.62 or FIPS186-2).
 
 ECDSA_SIG_new() allocates an empty B<ECDSA_SIG> structure. Note: before
 OpenSSL 1.1.0 the: the I<r> and I<s> components were initialised.
@@ -191,7 +191,7 @@ Second step: compute the ECDSA signature of a SHA-256 hash value
 
 =head1 CONFORMING TO
 
-ANSI X9.62, US Federal Information Processing Standard FIPS 186-2
+ANSI X9.62, US Federal Information Processing Standard FIPS186-2
 (Digital Signature Standard, DSS)
 
 =head1 SEE ALSO
diff --git a/doc/man3/EC_GROUP_copy.pod b/doc/man3/EC_GROUP_copy.pod
index 3702f7368cef..2f776cc8c55d 100644
--- a/doc/man3/EC_GROUP_copy.pod
+++ b/doc/man3/EC_GROUP_copy.pod
@@ -159,9 +159,10 @@ The function EC_GROUP_check_discriminant() calculates the discriminant for the c
 For a curve defined over Fp the discriminant is given by the formula 4*a^3 + 27*b^2 whilst for F2^m curves the discriminant is
 simply b. In either case for the curve to be valid the discriminant must be non zero.
 
-The function EC_GROUP_check() performs a number of checks on a curve to verify that it is valid. Checks performed include
+The function EC_GROUP_check() behaves in the following way:
+For the OpenSSL default provider it performs a number of checks on a curve to verify that it is valid. Checks performed include
 verifying that the discriminant is non zero; that a generator has been defined; that the generator is on the curve and has
-the correct order.
+the correct order. For the OpenSSL FIPS provider it uses EC_GROUP_check_named_curve() to conform to SP800-56Ar3.
 
 The function EC_GROUP_check_named_curve() determines if the group's domain parameters match one of the built-in curves supported by the library.
 The curve name is returned as a B<NID> if it matches. If the group's domain parameters have been modified then no match will be found.
diff --git a/doc/man3/EVP_DigestSignInit.pod b/doc/man3/EVP_DigestSignInit.pod
index 228e9d1c5f80..f770631c5c24 100644
--- a/doc/man3/EVP_DigestSignInit.pod
+++ b/doc/man3/EVP_DigestSignInit.pod
@@ -42,9 +42,9 @@ be used for the actual signing. See L<provider(7)/Implicit fetch> for
 more information about implicit fetches.
 
 The OpenSSL default and legacy providers support fetching digests and can fetch
-those digests from any available provider. The OpenSSL fips provider also
+those digests from any available provider. The OpenSSL FIPS provider also
 supports fetching digests but will only fetch digests that are themselves
-implemented inside the fips provider.
+implemented inside the FIPS provider.
 
 I<ctx> must be created with EVP_MD_CTX_new() before calling this function. If
 I<pctx> is not NULL, the EVP_PKEY_CTX of the signing operation will be written
diff --git a/doc/man3/EVP_DigestVerifyInit.pod b/doc/man3/EVP_DigestVerifyInit.pod
index 398146b5b8ed..d83c2ba52476 100644
--- a/doc/man3/EVP_DigestVerifyInit.pod
+++ b/doc/man3/EVP_DigestVerifyInit.pod
@@ -41,9 +41,9 @@ be used for the actual signing. See L<provider(7)/Implicit fetch> for
 more information about implicit fetches.
 
 The OpenSSL default and legacy providers support fetching digests and can fetch
-those digests from any available provider. The OpenSSL fips provider also
+those digests from any available provider. The OpenSSL FIPS provider also
 supports fetching digests but will only fetch digests that are themselves
-implemented inside the fips provider.
+implemented inside the FIPS provider.
 
 B<ctx> must be created with EVP_MD_CTX_new() before calling this function. If
 B<pctx> is not NULL, the EVP_PKEY_CTX of the verification operation will be
diff --git a/doc/man3/EVP_PKEY_check.pod b/doc/man3/EVP_PKEY_check.pod
index 1ba656fd221c..485d350529ee 100644
--- a/doc/man3/EVP_PKEY_check.pod
+++ b/doc/man3/EVP_PKEY_check.pod
@@ -48,6 +48,13 @@ EVP_PKEY_check() is an alias for the EVP_PKEY_pairwise_check() function.
 
 =head1 NOTES
 
+Key validation used by the OpenSSL FIPS provider complies with the rules
+within SP800-56A and SP800-56B. For backwards compatibility reasons the OpenSSL
+default provider may use checks that are not as restrictive for certain key types.
+For further information see L<EVP_PKEY-DSA(7)/DSA key validation>,
+L<EVP_PKEY-DH(7)/DH key validation>, L<EVP_PKEY-EC(7)/EC key validation> and
+L<EVP_PKEY-RSA(7)/RSA key validation>.
+
 Refer to SP800-56A and SP800-56B for rules relating to when these functions
 should be called during key establishment.
 It is not necessary to call these functions after locally calling an approved key
@@ -63,6 +70,11 @@ They return -2 if the operation is not supported for the specific algorithm.
 
 L<EVP_PKEY_CTX_new(3)>,
 L<EVP_PKEY_fromdata(3)>,
+L<EVP_PKEY-DH(7)>,
+L<EVP_PKEY-FFC(7)>,
+L<EVP_PKEY-DSA(7)>,
+L<EVP_PKEY-EC(7)>,
+L<EVP_PKEY-RSA(7)>,
 
 =head1 HISTORY
 
diff --git a/doc/man3/EVP_PKEY_decrypt.pod b/doc/man3/EVP_PKEY_decrypt.pod
index e85541ba81f3..b624600cd240 100644
--- a/doc/man3/EVP_PKEY_decrypt.pod
+++ b/doc/man3/EVP_PKEY_decrypt.pod
@@ -71,7 +71,7 @@ algorithm.
      /* Error occurred */
  if (EVP_PKEY_decrypt_init(ctx) <= 0)
      /* Error */
- if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_OAEP_PADDING) <= 0)
+ if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_OAEP_PADDING) <= 0)
      /* Error */
 
  /* Determine buffer length */
diff --git a/doc/man3/EVP_PKEY_encrypt.pod b/doc/man3/EVP_PKEY_encrypt.pod
index 9ff6ed6cae86..c5d91e1c18b9 100644
--- a/doc/man3/EVP_PKEY_encrypt.pod
+++ b/doc/man3/EVP_PKEY_encrypt.pod
@@ -74,7 +74,7 @@ L<d2i_X509(3)> for means to load a public key. You may also simply
      /* Error occurred */
  if (EVP_PKEY_encrypt_init(ctx) <= 0)
      /* Error */
- if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_OAEP_PADDING) <= 0)
+ if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_OAEP_PADDING) <= 0)
      /* Error */
 
  /* Determine buffer length */
diff --git a/doc/man3/EVP_PKEY_gettable_params.pod b/doc/man3/EVP_PKEY_gettable_params.pod
index f7884af86fef..c3dfe4e30dc6 100644
--- a/doc/man3/EVP_PKEY_gettable_params.pod
+++ b/doc/man3/EVP_PKEY_gettable_params.pod
@@ -79,7 +79,7 @@ These functions only work for B<EVP_PKEY>s that contain a provider side key.
 
 =head1 RETURN VALUES
 
-EVP_PKEY_gettable_params() returns NULL on error or if it is not supported,
+EVP_PKEY_gettable_params() returns NULL on error or if it is not supported.
 
 All other methods return 1 if a value associated with the key's I<key_name> was
 successfully returned, or 0 if there was an error.
diff --git a/doc/man3/OSSL_CRMF_MSG_set0_validity.pod b/doc/man3/OSSL_CRMF_MSG_set0_validity.pod
index 6489645e5666..5984abe51b54 100644
--- a/doc/man3/OSSL_CRMF_MSG_set0_validity.pod
+++ b/doc/man3/OSSL_CRMF_MSG_set0_validity.pod
@@ -62,11 +62,13 @@ OSSL_CRMF_MSG_push0_extension() pushes the X509 extension I<ext> to the
 extensions in the certTemplate of I<crm>.  Consumes I<ext>.
 
 OSSL_CRMF_MSG_create_popo() creates and sets the Proof-of-Possession (POPO)
-according to the method I<meth> in I<crm>.<
+according to the method I<meth> in I<crm>.
 The library context I<libctx> and property query string I<propq>,
 may be NULL to select the defaults.
 In case the method is OSSL_CRMF_POPO_SIGNATURE the POPO is calculated
-using the private key I<pkey> and the digest method I<digest>.
+using the private key I<pkey> and the digest method I<digest>,
+where the I<digest> argument is ignored if I<pkey> is of a type (such as
+Ed25519 and Ed448) that is implicitly associated with a digest alorithm.
 
 I<meth> can be one of the following:
 
diff --git a/doc/man3/OSSL_PARAM_BLD.pod b/doc/man3/OSSL_PARAM_BLD.pod
index 114ce44489cd..1fdea24f3de2 100644
--- a/doc/man3/OSSL_PARAM_BLD.pod
+++ b/doc/man3/OSSL_PARAM_BLD.pod
@@ -170,7 +170,7 @@ public key.
 
     if (nld == NULL
         || !OSSL_PARAM_BLD_push_BN(bld, "n", n)
-        || !OSSL_PARAM_BLD_push_BN(bld, "d", d)
+        || !OSSL_PARAM_BLD_push_BN(bld, "e", e)
         || (params = OSSL_PARAM_BLD_to_param(bld)) == NULL)
         goto err;
     OSSL_PARAM_BLD_free(bld);
diff --git a/doc/man3/X509_STORE_CTX_get_error.pod b/doc/man3/X509_STORE_CTX_get_error.pod
index 04005f3ecdb3..a8f3977445e8 100644
--- a/doc/man3/X509_STORE_CTX_get_error.pod
+++ b/doc/man3/X509_STORE_CTX_get_error.pod
@@ -212,7 +212,7 @@ and it is not self-signed and the B<X509_V_FLAG_PARTIAL_CHAIN> flag is not set.
 
 =item B<X509_V_ERR_CERT_CHAIN_TOO_LONG: certificate chain too long>
 
-The certificate chain length is greater than the supplied maximum depth. Unused.
+The certificate chain length is greater than the supplied maximum depth.
 
 =item B<X509_V_ERR_CERT_REVOKED: certificate revoked>
 
diff --git a/doc/man7/EVP_KDF-PBKDF2.pod b/doc/man7/EVP_KDF-PBKDF2.pod
index b0b7ac1d65f6..79af4be220e9 100644
--- a/doc/man7/EVP_KDF-PBKDF2.pod
+++ b/doc/man7/EVP_KDF-PBKDF2.pod
@@ -56,7 +56,7 @@ Setting the mode to 0 enables the compliance checks.
 =back
 
 The default provider uses a default mode of 1 for backwards compatibility,
-and the fips provider uses a default mode of 0.
+and the FIPS provider uses a default mode of 0.
 
 The value string is expected to be a decimal number 0 or 1.
 
diff --git a/doc/man7/EVP_PKEY-DH.pod b/doc/man7/EVP_PKEY-DH.pod
index cd34d323ee11..1662b152ed52 100644
--- a/doc/man7/EVP_PKEY-DH.pod
+++ b/doc/man7/EVP_PKEY-DH.pod
@@ -2,30 +2,25 @@
 
 =head1 NAME
 
-EVP_PKEY-DH, EVP_PKEY-DHX, EVP_KEYMGMT-DH
+EVP_PKEY-DH, EVP_PKEY-DHX, EVP_KEYMGMT-DH, EVP_KEYMGMT-DHX
 - EVP_PKEY DH and DHX keytype and algorithm support
 
 =head1 DESCRIPTION
 
 For B<DH> FFC key agreement, two classes of domain parameters can be used:
 "safe" domain parameters that are associated with approved named safe-prime
-groups, and a class of "FIPS 186-type" domain parameters. FIPS 186-type domain
+groups, and a class of "FIPS186-type" domain parameters. FIPS186-type domain
 parameters should only be used for backward compatibility with existing
 applications that cannot be upgraded to use the approved safe-prime groups.
 
 See L<EVP_PKEY-FFC(7)> for more information about FFC keys.
 
-The B<DH> key type uses PKCS#3 format which saves p and g, but not the 'q' value.
-The B<DHX> key type uses X9.42 format which saves the value of 'q' and this
-must be used for FIPS186-4.
-
-For B<DHX> that is not a named group the FIPS186-4 standard specifies that the
-values used for FFC parameter generation are also required for parameter
-validation. This means that optional FFC domain parameter values for
-I<seed>, I<pcounter> and I<gindex> or I<hindex> may need to be stored for
-validation purposes.
-For B<DHX> the I<seed> and I<pcounter> can be stored in ASN1 data
-(but the I<gindex> or I<hindex> can not be stored).
+The B<DH> key type uses PKCS#3 format which saves I<p> and I<g>, but not the
+I<q> value.
+The B<DHX> key type uses X9.42 format which saves the value of I<q> and this
+must be used for FIPS186-4. If key validation is required, users should be aware
+of the nuances associated with FIPS186-4 style parameters as discussed in
+L</DH key validation>.
 
 =head2 DH and DHX domain parameters
 
@@ -134,6 +129,44 @@ Where s is the security strength of the key which has values of
 
 =back
 
+=head2 DH key validation
+
+For B<DHX> that is not a named group the FIPS186-4 standard specifies that the
+values used for FFC parameter generation are also required for parameter
+validation. This means that optional FFC domain parameter values for
+I<seed>, I<pcounter> and I<gindex> or I<hindex> may need to be stored for
+validation purposes.
+For B<DHX> the I<seed> and I<pcounter> can be stored in ASN1 data
+(but the I<gindex> or I<hindex> cannot be stored). It is recommended to use a
+named safe prime group instead.
+
+For DH keys, L<EVP_PKEY_param_check(3)> behaves in the following way:
+The OpenSSL FIPS provider tests if the parameters are either an approved safe
+prime group OR that the FFC parameters conform to FIPS186-4 as defined in
+SP800-56Ar3 I<Assurances of Domain-Parameter Validity>.
+The OpenSSL default provider uses simpler checks that allows there to be no I<q>
+value for backwards compatibility.
+
+For DH keys, L<EVP_PKEY_param_check_quick(3)> is equivalent to
+L<EVP_PKEY_param_check(3)>.
+
+For DH keys, L<EVP_PKEY_public_check(3)> conforms to
+SP800-56Ar3 I<FFC Full Public-Key Validation>.
+
+For DH keys, L<EVP_PKEY_public_check_quick(3)> conforms to
+SP800-56Ar3 I<FFC Partial Public-Key Validation> when the
+DH key is an approved named safe prime group, otherwise it is the same as
+L<EVP_PKEY_public_check(3)>.
+
+For DH Keys, L<EVP_PKEY_private_check(3)> tests that the private key is in the
+correct range according to SP800-56Ar3. The OpenSSL FIPS provider requires the
+value of I<q> to be set (note that this is set for named safe prime groups).
+For backwards compatibility the OpenSSL default provider only requires I<p> to
+be set.
+
+For DH keys, L<EVP_PKEY_pairwise_check(3)> conforms to
+SP800-56Ar3 I<Owner Assurance of Pair-wise Consistency>.
+
 =head1 EXAMPLES
 
 An B<EVP_PKEY> context can be obtained by calling:
@@ -159,7 +192,7 @@ Where s is the security strength of the key which has values of
     EVP_PKEY_free(pkey);
     EVP_PKEY_CTX_free(pctx);
 
-B<DHX> domain parameters can be generated according to B<FIPS 186-4> by calling:
+B<DHX> domain parameters can be generated according to B<FIPS186-4> by calling:
 
     int gindex = 2;
     unsigned int pbits = 2048;
@@ -198,7 +231,7 @@ Where s is the security strength of the key which has values of
     EVP_PKEY_free(key);
     EVP_PKEY_CTX_free(gctx);
 
-To validate B<FIPS 186-4> B<DHX> domain parameters decoded from B<PEM> or
+To validate B<FIPS186-4> B<DHX> domain parameters decoded from B<PEM> or
 B<DER> data, additional values used during generation may be required to
 be set into the key.
 
@@ -270,7 +303,7 @@ the actual validation. In production code the return values should be checked.
 
 =back
 
-The following sections of FIPS 186-4:
+The following sections of FIPS186-4:
 
 =over 4
 
diff --git a/doc/man7/EVP_PKEY-DSA.pod b/doc/man7/EVP_PKEY-DSA.pod
index 6a335510d31d..f51b43b2a613 100644
--- a/doc/man7/EVP_PKEY-DSA.pod
+++ b/doc/man7/EVP_PKEY-DSA.pod
@@ -29,6 +29,22 @@ For "fips186_4" this must be either 2048 or 3072.
 For "fips186_2" this must be 1024.
 For "group" this can be any one of 2048, 3072, 4096, 6144 or 8192.
 
+=head2 DSA key validation
+
+For DSA keys, L<EVP_PKEY_param_check(3)> behaves in the following way:
+The OpenSSL FIPS provider conforms to the rules within the FIPS186-4
+standard for FFC parameter validation. For backwards compatibility the OpenSSL
+default provider uses a much simpler check (see below) for parameter validation,
+unless the seed parameter is set.
+
+For DSA keys, L<EVP_PKEY_param_check_quick(3)> behaves in the following way:
+A simple check of L and N and partial g is performed. The default provider
+also supports validation of legacy "fips186_2" keys.
+
+For DSA keys, L<EVP_PKEY_public_check(3)>, L<EVP_PKEY_private_check(3)> and
+L<EVP_PKEY_pairwise_check(3)> the OpenSSL default and FIPS providers conform to
+the rules within SP800-56Ar3 for public, private and pairwise tests respectively.
+
 =head1 EXAMPLES
 
 An B<EVP_PKEY> context can be obtained by calling:
@@ -73,7 +89,7 @@ For "group" this can be any one of 2048, 3072, 4096, 6144 or 8192.
 
 =head1 CONFORMING TO
 
-The following sections of FIPS 186-4:
+The following sections of FIPS186-4:
 
 =over 4
 
diff --git a/doc/man7/EVP_PKEY-EC.pod b/doc/man7/EVP_PKEY-EC.pod
index a3c3ccb70561..0255a5bc6598 100644
--- a/doc/man7/EVP_PKEY-EC.pod
+++ b/doc/man7/EVP_PKEY-EC.pod
@@ -97,7 +97,7 @@ Valid values are "default", "named" and "named-nist".
 The "named" type checks that the domain parameters match the inbuilt curve parameters,
 "named-nist" is similiar but also checks that the named curve is a nist curve.
 The "default" type does domain parameter validation for the OpenSSL default provider,
-but is equivalent to "named-nist" for the OpenSSL fips provider.
+but is equivalent to "named-nist" for the OpenSSL FIPS provider.
 
 =item "include-public" (B<OSSL_PKEY_PARAM_EC_INCLUDE_PUBLIC>) <integer>
 
@@ -167,6 +167,26 @@ that m > k3 > k2 > k1 > 0
 
 =back
 
+=head2 EC key validation
+
+For EC keys, L<EVP_PKEY_param_check(3)> behaves in the following way:
+For the OpenSSL default provider it uses either
+L<EC_GROUP_check(3)> or L<EC_GROUP_check_named_curve(3)> depending on the flag
+EC_FLAG_CHECK_NAMED_GROUP.
+The OpenSSL FIPS provider uses L<EC_GROUP_check_named_curve(3)> in order to
+conform to SP800-56Ar3 I<Assurances of Domain-Parameter Validity>.
+
+For EC keys, L<EVP_PKEY_param_check_quick(3)> is equivalent to
+L<EVP_PKEY_param_check(3)>.
+
+For EC keys, L<EVP_PKEY_public_check(3)> and L<EVP_PKEY_public_check_quick(3)>
+conform to SP800-56Ar3 I<ECC Full Public-Key Validation> and
+I<ECC Partial Public-Key Validation> respectively.
+
+For EC Keys, L<EVP_PKEY_private_check(3)> and L<EVP_PKEY_pairwise_check(3)>
+conform to SP800-56Ar3 I<Private key validity> and
+I<Owner Assurance of Pair-wise Consistency> respectively.
+
 =head1 EXAMPLES
 
 An B<EVP_PKEY> context can be obtained by calling:
diff --git a/doc/man7/EVP_PKEY-FFC.pod b/doc/man7/EVP_PKEY-FFC.pod
index dab7380fc2df..7c9848676b8c 100644
--- a/doc/man7/EVP_PKEY-FFC.pod
+++ b/doc/man7/EVP_PKEY-FFC.pod
@@ -196,7 +196,7 @@ These types are described above.
 
 =back
 
-The following sections of FIPS 186-4:
+The following sections of FIPS186-4:
 
 =over 4
 
diff --git a/doc/man7/EVP_PKEY-RSA.pod b/doc/man7/EVP_PKEY-RSA.pod
index 784d5a39b8f2..51103b8b29ab 100644
--- a/doc/man7/EVP_PKEY-RSA.pod
+++ b/doc/man7/EVP_PKEY-RSA.pod
@@ -179,6 +179,26 @@ The auxiliary probable primes.
 
 =back
 
+=head2 RSA key validation
+
+For RSA keys, L<EVP_PKEY_param_check(3)> and L<EVP_PKEY_param_check_quick(3)>
+both return 1 unconditionally.
+
+For RSA keys, L<EVP_PKEY_public_check(3)> conforms to the SP800-56Br1 I<public key
+check> when the OpenSSL FIPS provider is used. The OpenSSL default provider
+performs similiar tests but relaxes the keysize restrictions for backwards
+compatibility.
+
+For RSA keys, L<EVP_PKEY_public_check_quick(3)> is the same as
+L<EVP_PKEY_public_check(3)>.
+
+For RSA keys, L<EVP_PKEY_private_check(3)> conforms to the SP800-56Br1
+I<private key test>.
+
+For RSA keys, L<EVP_PKEY_pairwise_check(3)> conforms to the
+SP800-56Br1 I<KeyPair Validation check> for the OpenSSL FIPS provider. The
+OpenSSL default provider allows testing of the validity of multi-primes.
+
 =head1 CONFORMING TO
 
 =over 4
diff --git a/doc/man7/OSSL_PROVIDER-FIPS.pod b/doc/man7/OSSL_PROVIDER-FIPS.pod
index 00ab7977f487..899185974ee8 100644
--- a/doc/man7/OSSL_PROVIDER-FIPS.pod
+++ b/doc/man7/OSSL_PROVIDER-FIPS.pod
@@ -34,7 +34,7 @@ make sure to get implementations of this provider and none other.
 
 The "fips=yes" property can be use to make sure only FIPS approved
 implementations are used for crypto operations.  This may also include
-other non-crypto support operations that are not in the fips provider,
+other non-crypto support operations that are not in the FIPS provider,
 such as asymmetric key encoders,
 see L<OSSL_PROVIDER-default(7)/Asymmetric Key Management>.
 
@@ -160,10 +160,18 @@ see L<OSSL_PROVIDER-default(7)/Asymmetric Key Management>.
 
 =item DH, see L<EVP_KEYMGMT-DH(7)>
 
+=item DHX, see L<EVP_KEYMGMT-DHX(7)>
+
 =item DSA, see L<EVP_KEYMGMT-DSA(7)>
 
 =item RSA, see L<EVP_KEYMGMT-RSA(7)>
 
+=item EC, see L<EVP_KEYMGMT-EC(7)>
+
+=item X25519, see L<EVP_KEYMGMT-X25519(7)>
+
+=item X448, see L<EVP_KEYMGMT-X448(7)>
+
 =back
 
 =head1 SELF TESTING
diff --git a/doc/man7/OSSL_PROVIDER-default.pod b/doc/man7/OSSL_PROVIDER-default.pod
index 14d590cbdec6..23acbc37f707 100644
--- a/doc/man7/OSSL_PROVIDER-default.pod
+++ b/doc/man7/OSSL_PROVIDER-default.pod
@@ -200,6 +200,8 @@ listed below
 
 =item DH, see L<EVP_KEYMGMT-DH(7)>
 
+=item DHX, see L<EVP_KEYMGMT-DHX(7)>
+
 =item DSA, see L<EVP_KEYMGMT-DSA(7)>
 
 =item RSA, see L<EVP_KEYMGMT-RSA(7)>
diff --git a/doc/man7/fips_module.pod b/doc/man7/fips_module.pod
index e374651fa57e..f37b3831c897 100644
--- a/doc/man7/fips_module.pod
+++ b/doc/man7/fips_module.pod
@@ -273,7 +273,7 @@ file. The encoder and decoder algorithms are not in the FIPS module itself but
 are allowed to be used in conjunction with the FIPS algorithms.
 
 It is possible to specify default properties within a config file. For example
-the following config file automatically loads the default and fips providers and
+the following config file automatically loads the default and FIPS providers and
 sets the default property value to be C<fips=yes>. Note that this config file
 does not load the "base" provider. All supporting algorithms that are in "base"
 are also in "default", so it is unnecessary in this case:
diff --git a/doc/man7/migration_guide.pod b/doc/man7/migration_guide.pod
index 67e102fa4c18..f8d84ad7c15e 100644
--- a/doc/man7/migration_guide.pod
+++ b/doc/man7/migration_guide.pod
@@ -350,7 +350,7 @@ The Miller-Rabin test now uses 64 rounds, which is used for all prime generation
 including RSA key generation. This affects the time for larger keys sizes.
 
 The default key generation method for the regular 2-prime RSA keys was changed
-to the FIPS 186-4 B.3.6 method (Generation of Probable Primes with Conditions
+to the FIPS186-4 B.3.6 method (Generation of Probable Primes with Conditions
 Based on Auxiliary Probable Primes). This method is slower than the original
 method.
 
@@ -359,7 +359,7 @@ method.
 This checks that the salt length is at least 128 bits, the derived key length is
 at least 112 bits, and that the iteration count is at least 1000.
 For backwards compatibility these checks are disabled by default in the
-default provider, but are enabled by default in the fips provider.
+default provider, but are enabled by default in the FIPS provider.
 
 To enable or disable the checks see B<OSSL_KDF_PARAM_PKCS5> in
 L<EVP_KDF-PBKDF2(7)>. The parameter can be set using L<EVP_KDF_derive(3)>.
diff --git a/doc/man7/provider-keymgmt.pod b/doc/man7/provider-keymgmt.pod
index fc8d995f4440..17d8d4b3380a 100644
--- a/doc/man7/provider-keymgmt.pod
+++ b/doc/man7/provider-keymgmt.pod
@@ -46,9 +46,9 @@ provider-keymgmt - The KEYMGMT library E<lt>-E<gt> provider functions
  const char *OSSL_FUNC_keymgmt_query_operation_name(int operation_id);
 
  /* Key object import and export functions */
- int OSSL_FUNC_keymgmt_import(int selection, void *keydata, const OSSL_PARAM params[]);
+ int OSSL_FUNC_keymgmt_import(void *keydata, int selection, const OSSL_PARAM params[]);
  const OSSL_PARAM *OSSL_FUNC_keymgmt_import_types(int selection);
- int OSSL_FUNC_keymgmt_export(int selection, void *keydata,
+ int OSSL_FUNC_keymgmt_export(void *keydata, int selection,
                               OSSL_CALLBACK *param_cb, void *cbarg);
  const OSSL_PARAM *OSSL_FUNC_keymgmt_export_types(int selection);
 
diff --git a/e_os.h b/e_os.h
index 514de967a95d..9e2f14072f6c 100644
--- a/e_os.h
+++ b/e_os.h
@@ -409,4 +409,24 @@ inline int nssgetpid();
 #   endif
 # endif
 
+/*
+ * str[n]casecmp_l is defined in POSIX 2008-01. Value is taken accordingly
+ * https://www.gnu.org/software/libc/manual/html_node/Feature-Test-Macros.html
+ * There are also equivalent functions on Windows.
+ * There is no locale_t on NONSTOP.
+ */
+# if defined(OPENSSL_SYS_WINDOWS)
+#  define locale_t _locale_t
+#  define freelocale _free_locale
+#  define strcasecmp_l _stricmp_l
+#  define strncasecmp_l _strnicmp_l
+#  define strcasecmp _stricmp
+#  define strncasecmp _strnicmp
+# elif !defined(_POSIX_C_SOURCE) || _POSIX_C_SOURCE < 200809L \
+     || defined(OPENSSL_SYS_TANDEM)
+#  ifndef OPENSSL_NO_LOCALE
+#   define OPENSSL_NO_LOCALE
+#  endif
+# endif
+
 #endif
diff --git a/engines/build.info b/engines/build.info
index cae014ecc6aa..19e3eab0c184 100644
--- a/engines/build.info
+++ b/engines/build.info
@@ -1,7 +1,7 @@
 IF[{- !$disabled{"engine"} -}]
   $PADLOCKASM=
   IF[{- !$disabled{asm} -}]
-    $PADLOCKASM_x86=e_padlock-x86.s
+    $PADLOCKASM_x86=e_padlock-x86.S
     $PADLOCKASM_x86_64=e_padlock-x86_64.s
 
     # Now that we have defined all the arch specific variables, use the
@@ -98,6 +98,6 @@ IF[{- !$disabled{"engine"} -}]
       GENERATE[ossltest.ld]=../util/engines.num
     ENDIF
   ENDIF
-  GENERATE[e_padlock-x86.s]=asm/e_padlock-x86.pl
+  GENERATE[e_padlock-x86.S]=asm/e_padlock-x86.pl
   GENERATE[e_padlock-x86_64.s]=asm/e_padlock-x86_64.pl
 ENDIF
diff --git a/engines/e_loader_attic.c b/engines/e_loader_attic.c
index 050593975d60..eba7ab14b8e3 100644
--- a/engines/e_loader_attic.c
+++ b/engines/e_loader_attic.c
@@ -73,8 +73,8 @@ static char *file_get_pass(const UI_METHOD *ui_method, char *pass,
     if ((prompt = UI_construct_prompt(ui, desc, info)) == NULL) {
         ATTICerr(0, ERR_R_MALLOC_FAILURE);
         pass = NULL;
-    } else if (!UI_add_input_string(ui, prompt, UI_INPUT_FLAG_DEFAULT_PWD,
-                                    pass, 0, maxsize - 1)) {
+    } else if (UI_add_input_string(ui, prompt, UI_INPUT_FLAG_DEFAULT_PWD,
+                                    pass, 0, maxsize - 1) <= 0) {
         ATTICerr(0, ERR_R_UI_LIB);
         pass = NULL;
     } else {
diff --git a/include/crypto/ctype.h b/include/crypto/ctype.h
index 16f135df3b58..22f6922183b5 100644
--- a/include/crypto/ctype.h
+++ b/include/crypto/ctype.h
@@ -22,6 +22,8 @@
 # define OSSL_CRYPTO_CTYPE_H
 # pragma once
 
+# include <openssl/e_os2.h>
+
 # define CTYPE_MASK_lower       0x1
 # define CTYPE_MASK_upper       0x2
 # define CTYPE_MASK_digit       0x4
@@ -55,10 +57,15 @@ int ossl_fromascii(int c);
 #  define ossl_fromascii(c)     (c)
 # endif
 int ossl_ctype_check(int c, unsigned int mask);
+
 int ossl_tolower(int c);
 int ossl_toupper(int c);
 
-int ossl_ascii_isdigit(const char inchar);
+int ossl_isdigit(int c);
+int ossl_islower(int c);
+int ossl_isupper(int c);
+
+int ossl_ascii_isdigit(int c);
 
 # define ossl_isalnum(c)        (ossl_ctype_check((c), CTYPE_MASK_alnum))
 # define ossl_isalpha(c)        (ossl_ctype_check((c), CTYPE_MASK_alpha))
@@ -69,17 +76,11 @@ int ossl_ascii_isdigit(const char inchar);
 # endif
 # define ossl_isblank(c)        (ossl_ctype_check((c), CTYPE_MASK_blank))
 # define ossl_iscntrl(c)        (ossl_ctype_check((c), CTYPE_MASK_cntrl))
-# define ossl_isdigit(c)        (ossl_ctype_check((c), CTYPE_MASK_digit))
 # define ossl_isgraph(c)        (ossl_ctype_check((c), CTYPE_MASK_graph))
-# define ossl_islower(c)        (ossl_ctype_check((c), CTYPE_MASK_lower))
 # define ossl_isprint(c)        (ossl_ctype_check((c), CTYPE_MASK_print))
 # define ossl_ispunct(c)        (ossl_ctype_check((c), CTYPE_MASK_punct))
 # define ossl_isspace(c)        (ossl_ctype_check((c), CTYPE_MASK_space))
-# define ossl_isupper(c)        (ossl_ctype_check((c), CTYPE_MASK_upper))
 # define ossl_isxdigit(c)       (ossl_ctype_check((c), CTYPE_MASK_xdigit))
 # define ossl_isbase64(c)       (ossl_ctype_check((c), CTYPE_MASK_base64))
 # define ossl_isasn1print(c)    (ossl_ctype_check((c), CTYPE_MASK_asn1print))
-
-int ossl_init_casecmp(void);
-void ossl_deinit_casecmp(void);
 #endif
diff --git a/include/crypto/decoder.h b/include/crypto/decoder.h
index cc06ef29261b..95afd25b0bcb 100644
--- a/include/crypto/decoder.h
+++ b/include/crypto/decoder.h
@@ -38,5 +38,7 @@ int ossl_decoder_ctx_setup_for_pkey(OSSL_DECODER_CTX *ctx,
                                     const char *propquery);
 
 int ossl_decoder_get_number(const OSSL_DECODER *encoder);
+int ossl_decoder_store_cache_flush(OSSL_LIB_CTX *libctx);
+int ossl_decoder_store_remove_all_provided(const OSSL_PROVIDER *prov);
 
 #endif
diff --git a/include/crypto/encoder.h b/include/crypto/encoder.h
index 09d445d21039..ae56131eb34e 100644
--- a/include/crypto/encoder.h
+++ b/include/crypto/encoder.h
@@ -7,8 +7,16 @@
  * https://www.openssl.org/source/license.html
  */
 
-#include <openssl/types.h>
+#ifndef OSSL_CRYPTO_ENCODER_H
+# define OSSL_CRYPTO_ENCODER_H
+# pragma once
+
+# include <openssl/types.h>
 
 OSSL_ENCODER *ossl_encoder_fetch_by_number(OSSL_LIB_CTX *libctx, int id,
                                            const char *properties);
 int ossl_encoder_get_number(const OSSL_ENCODER *encoder);
+int ossl_encoder_store_cache_flush(OSSL_LIB_CTX *libctx);
+int ossl_encoder_store_remove_all_provided(const OSSL_PROVIDER *prov);
+
+#endif
diff --git a/include/crypto/evp.h b/include/crypto/evp.h
index 206ac2633766..9db5d89430c9 100644
--- a/include/crypto/evp.h
+++ b/include/crypto/evp.h
@@ -893,7 +893,9 @@ int evp_pkey_ctx_get1_id_len_prov(EVP_PKEY_CTX *ctx, size_t *id_len);
 int evp_pkey_ctx_use_cached_data(EVP_PKEY_CTX *ctx);
 # endif /* !defined(FIPS_MODULE) */
 
-int evp_method_store_flush(OSSL_LIB_CTX *libctx);
+int evp_method_store_cache_flush(OSSL_LIB_CTX *libctx);
+int evp_method_store_remove_all_provided(const OSSL_PROVIDER *prov);
+
 int evp_default_properties_enable_fips_int(OSSL_LIB_CTX *libctx, int enable,
                                            int loadconfig);
 int evp_set_default_properties_int(OSSL_LIB_CTX *libctx, const char *propq,
diff --git a/include/crypto/store.h b/include/crypto/store.h
index 13d2646bba46..9b7be71acd6f 100644
--- a/include/crypto/store.h
+++ b/include/crypto/store.h
@@ -17,5 +17,7 @@
 
 void ossl_store_cleanup_int(void);
 int ossl_store_loader_get_number(const OSSL_STORE_LOADER *loader);
+int ossl_store_loader_store_cache_flush(OSSL_LIB_CTX *libctx);
+int ossl_store_loader_store_remove_all_provided(const OSSL_PROVIDER *prov);
 
 #endif
diff --git a/include/internal/core.h b/include/internal/core.h
index 274e368aaaad..48e1ba465a69 100644
--- a/include/internal/core.h
+++ b/include/internal/core.h
@@ -49,7 +49,7 @@ void *ossl_method_construct(OSSL_LIB_CTX *ctx, int operation_id,
 void ossl_algorithm_do_all(OSSL_LIB_CTX *libctx, int operation_id,
                            OSSL_PROVIDER *provider,
                            int (*pre)(OSSL_PROVIDER *, int operation_id,
-                                      void *data, int *result),
+                                      int no_store, void *data, int *result),
                            void (*fn)(OSSL_PROVIDER *provider,
                                       const OSSL_ALGORITHM *algo,
                                       int no_store, void *data),
@@ -62,7 +62,4 @@ __owur int ossl_lib_ctx_write_lock(OSSL_LIB_CTX *ctx);
 __owur int ossl_lib_ctx_read_lock(OSSL_LIB_CTX *ctx);
 int ossl_lib_ctx_unlock(OSSL_LIB_CTX *ctx);
 int ossl_lib_ctx_is_child(OSSL_LIB_CTX *ctx);
-
-void *ossl_c_locale(void);
-
 #endif
diff --git a/include/internal/property.h b/include/internal/property.h
index 8211974595de..db08c33cc37e 100644
--- a/include/internal/property.h
+++ b/include/internal/property.h
@@ -64,6 +64,8 @@ void ossl_method_store_do_all(OSSL_METHOD_STORE *store,
 int ossl_method_store_fetch(OSSL_METHOD_STORE *store,
                             int nid, const char *prop_query,
                             const OSSL_PROVIDER **prov, void **method);
+int ossl_method_store_remove_all_provided(OSSL_METHOD_STORE *store,
+                                          const OSSL_PROVIDER *prov);
 
 /* Get the global properties associate with the specified library context */
 OSSL_PROPERTY_LIST **ossl_ctx_global_properties(OSSL_LIB_CTX *ctx,
@@ -77,7 +79,7 @@ int ossl_method_store_cache_set(OSSL_METHOD_STORE *store, OSSL_PROVIDER *prov,
                                 int (*method_up_ref)(void *),
                                 void (*method_destruct)(void *));
 
-__owur int ossl_method_store_flush_cache(OSSL_METHOD_STORE *store, int all);
+__owur int ossl_method_store_cache_flush_all(OSSL_METHOD_STORE *store);
 
 /* Merge two property queries together */
 OSSL_PROPERTY_LIST *ossl_property_merge(const OSSL_PROPERTY_LIST *a,
diff --git a/include/internal/provider.h b/include/internal/provider.h
index d09829d05e17..987e1a464d6d 100644
--- a/include/internal/provider.h
+++ b/include/internal/provider.h
@@ -95,11 +95,14 @@ void ossl_provider_unquery_operation(const OSSL_PROVIDER *prov,
                                      int operation_id,
                                      const OSSL_ALGORITHM *algs);
 
-/* Cache of bits to see if we already queried an operation */
+/*
+ * Cache of bits to see if we already added methods for an operation in
+ * the "permanent" method store.
+ * They should never be called for temporary method stores!
+ */
 int ossl_provider_set_operation_bit(OSSL_PROVIDER *provider, size_t bitnum);
 int ossl_provider_test_operation_bit(OSSL_PROVIDER *provider, size_t bitnum,
                                      int *result);
-int ossl_provider_clear_all_operation_bits(OSSL_LIB_CTX *libctx);
 
 /* Configuration */
 void ossl_provider_add_conf_module(void);
diff --git a/include/openssl/bio.h.in b/include/openssl/bio.h.in
index 9c3a868aae62..651843b62970 100644
--- a/include/openssl/bio.h.in
+++ b/include/openssl/bio.h.in
@@ -174,9 +174,9 @@ extern "C" {
 
 # ifndef OPENSSL_NO_KTLS
 #  define BIO_get_ktls_send(b)         \
-     BIO_ctrl(b, BIO_CTRL_GET_KTLS_SEND, 0, NULL)
+     (BIO_ctrl(b, BIO_CTRL_GET_KTLS_SEND, 0, NULL) > 0)
 #  define BIO_get_ktls_recv(b)         \
-     BIO_ctrl(b, BIO_CTRL_GET_KTLS_RECV, 0, NULL)
+     (BIO_ctrl(b, BIO_CTRL_GET_KTLS_RECV, 0, NULL) > 0)
 # else
 #  define BIO_get_ktls_send(b)  (0)
 #  define BIO_get_ktls_recv(b)  (0)
diff --git a/providers/build.info b/providers/build.info
index a70fa1a24c09..3b211bbb2fe7 100644
--- a/providers/build.info
+++ b/providers/build.info
@@ -118,6 +118,12 @@ IF[{- !$disabled{fips} -}]
   GENERATE[fipsmodule.cnf]=../util/mk-fipsmodule-cnf.pl \
           -module $(FIPSMODULE) -section_name fips_sect -key $(FIPSKEY)
   DEPEND[fipsmodule.cnf]=$FIPSGOAL
+
+  # Add VERSIONINFO resource for windows
+  IF[{- $config{target} =~ /^(?:Cygwin|mingw|VC-|BC-)/ -}]
+    GENERATE[fips.rc]=../util/mkrc.pl fips
+    SOURCE[$FIPSGOAL]=fips.rc
+  ENDIF
 ENDIF
 
 #
@@ -146,6 +152,13 @@ IF[{- !$disabled{legacy} -}]
       SOURCE[legacy]=legacy.ld
       GENERATE[legacy.ld]=../util/providers.num
     ENDIF
+
+    # Add VERSIONINFO resource for windows
+    IF[{- $config{target} =~ /^(?:Cygwin|mingw|VC-|BC-)/ -}]
+      GENERATE[legacy.rc]=../util/mkrc.pl legacy
+      SOURCE[$LEGACYGOAL]=legacy.rc
+    ENDIF
+
     SOURCE[$LIBLEGACY]=prov_running.c
   ENDIF
 
diff --git a/providers/fips/fipsprov.c b/providers/fips/fipsprov.c
index 9fbd5c8cb9d9..6a88039423d9 100644
--- a/providers/fips/fipsprov.c
+++ b/providers/fips/fipsprov.c
@@ -36,22 +36,6 @@ static OSSL_FUNC_provider_gettable_params_fn fips_gettable_params;
 static OSSL_FUNC_provider_get_params_fn fips_get_params;
 static OSSL_FUNC_provider_query_operation_fn fips_query;
 
-/* Locale object accessor functions */
-#ifdef OPENSSL_SYS_MACOSX
-# include <xlocale.h>
-#else
-# include <locale.h>
-#endif
-
-#if defined OPENSSL_SYS_WINDOWS
-# define locale_t _locale_t
-# define freelocale _free_locale
-#endif
-static locale_t loc;
-
-static int fips_init_casecmp(void);
-static void fips_deinit_casecmp(void);
-
 #define ALGC(NAMES, FUNC, CHECK) { { NAMES, FIPS_DEFAULT_PROPERTIES, FUNC }, CHECK }
 #define ALG(NAMES, FUNC) ALGC(NAMES, FUNC, NULL)
 
@@ -503,23 +487,6 @@ static const OSSL_ALGORITHM *fips_query(void *provctx, int operation_id,
     return NULL;
 }
 
-void *ossl_c_locale() {
-    return (void *)loc;
-}
-
-static int fips_init_casecmp(void) {
-# ifdef OPENSSL_SYS_WINDOWS
-    loc = _create_locale(LC_COLLATE, "C");
-# else
-    loc = newlocale(LC_COLLATE_MASK, "C", (locale_t) 0);
-# endif
-    return (loc == (locale_t) 0) ? 0 : 1;
-}
-
-static void fips_deinit_casecmp(void) {
-    freelocale(loc);
-}
-
 static void fips_teardown(void *provctx)
 {
     OSSL_LIB_CTX_free(PROV_LIBCTX_OF(provctx));
@@ -532,7 +499,6 @@ static void fips_intern_teardown(void *provctx)
      * We know that the library context is the same as for the outer provider,
      * so no need to destroy it here.
      */
-    fips_deinit_casecmp();
     ossl_prov_ctx_free(provctx);
 }
 
@@ -582,10 +548,8 @@ int OSSL_provider_init_int(const OSSL_CORE_HANDLE *handle,
 
     memset(&selftest_params, 0, sizeof(selftest_params));
 
-    if (!fips_init_casecmp())
-        return 0;
     if (!ossl_prov_seeding_from_dispatch(in))
-        return 0;
+        goto err;
     for (; in->function_id != 0; in++) {
         /*
          * We do not support the scenario of an application linked against
diff --git a/providers/fips/self_test_kats.c b/providers/fips/self_test_kats.c
index 94a0cf842c0c..3a7d095c7b6a 100644
--- a/providers/fips/self_test_kats.c
+++ b/providers/fips/self_test_kats.c
@@ -72,10 +72,10 @@ static int cipher_init(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
         in_tag = (unsigned char *)t->tag;
 
     return EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, enc)
-           && EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, t->iv_len, NULL)
+           && (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, t->iv_len, NULL) > 0)
            && (in_tag == NULL
                || EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, t->tag_len,
-                                      in_tag))
+                                      in_tag) > 0)
            && EVP_CipherInit_ex(ctx, NULL, NULL, t->key, t->iv, enc)
            && EVP_CIPHER_CTX_set_padding(ctx, pad)
            && EVP_CipherUpdate(ctx, NULL, &tmp, t->aad, t->aad_len);
@@ -117,8 +117,8 @@ static int self_test_cipher(const ST_KAT_CIPHER *t, OSSL_SELF_TEST *st,
         if (t->tag != NULL) {
             unsigned char tag[16] = { 0 };
 
-            if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, t->tag_len,
-                                     tag)
+            if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, t->tag_len,
+                                     tag) <= 0
                 || memcmp(tag, t->tag, t->tag_len) != 0)
                 goto err;
         }
diff --git a/providers/implementations/ciphers/cipher_blowfish.c b/providers/implementations/ciphers/cipher_blowfish.c
index 9566f044a4ea..e3b08ddbe4d6 100644
--- a/providers/implementations/ciphers/cipher_blowfish.c
+++ b/providers/implementations/ciphers/cipher_blowfish.c
@@ -55,6 +55,6 @@ IMPLEMENT_var_keylen_cipher(blowfish, BLOWFISH, ecb, ECB, BF_FLAGS, 128, 64, 0,
 /* bf_cbc_functions */
 IMPLEMENT_var_keylen_cipher(blowfish, BLOWFISH, cbc, CBC, BF_FLAGS, 128, 64, 64, block)
 /* bf_ofb_functions */
-IMPLEMENT_var_keylen_cipher(blowfish, BLOWFISH, ofb64, OFB, BF_FLAGS, 64, 8, 64, stream)
+IMPLEMENT_var_keylen_cipher(blowfish, BLOWFISH, ofb64, OFB, BF_FLAGS, 128, 8, 64, stream)
 /* bf_cfb_functions */
-IMPLEMENT_var_keylen_cipher(blowfish, BLOWFISH, cfb64,  CFB, BF_FLAGS, 64, 8, 64, stream)
+IMPLEMENT_var_keylen_cipher(blowfish, BLOWFISH, cfb64,  CFB, BF_FLAGS, 128, 8, 64, stream)
diff --git a/providers/implementations/include/prov/implementations.h b/providers/implementations/include/prov/implementations.h
index 30e5e4cd775a..e0122a97ac2c 100644
--- a/providers/implementations/include/prov/implementations.h
+++ b/providers/implementations/include/prov/implementations.h
@@ -152,8 +152,8 @@ extern const OSSL_DISPATCH ossl_camellia128ctr_functions[];
 #ifndef OPENSSL_NO_BF
 extern const OSSL_DISPATCH ossl_blowfish128ecb_functions[];
 extern const OSSL_DISPATCH ossl_blowfish128cbc_functions[];
-extern const OSSL_DISPATCH ossl_blowfish64ofb64_functions[];
-extern const OSSL_DISPATCH ossl_blowfish64cfb64_functions[];
+extern const OSSL_DISPATCH ossl_blowfish128ofb64_functions[];
+extern const OSSL_DISPATCH ossl_blowfish128cfb64_functions[];
 #endif /* OPENSSL_NO_BF */
 #ifndef OPENSSL_NO_IDEA
 extern const OSSL_DISPATCH ossl_idea128ecb_functions[];
diff --git a/providers/implementations/kdfs/krb5kdf.c b/providers/implementations/kdfs/krb5kdf.c
index 2c887f0eb993..4000703ca9a0 100644
--- a/providers/implementations/kdfs/krb5kdf.c
+++ b/providers/implementations/kdfs/krb5kdf.c
@@ -336,8 +336,10 @@ static int cipher_init(EVP_CIPHER_CTX *ctx,
     klen = EVP_CIPHER_CTX_get_key_length(ctx);
     if (key_len != (size_t)klen) {
         ret = EVP_CIPHER_CTX_set_key_length(ctx, key_len);
-        if (!ret)
+        if (ret <= 0) {
+            ret = 0;
             goto out;
+        }
     }
     /* we never want padding, either the length requested is a multiple of
      * the cipher block size or we are passed a cipher that can cope with
diff --git a/providers/implementations/macs/gmac_prov.c b/providers/implementations/macs/gmac_prov.c
index ad189d9c1464..3dd38ecd7ca7 100644
--- a/providers/implementations/macs/gmac_prov.c
+++ b/providers/implementations/macs/gmac_prov.c
@@ -235,8 +235,8 @@ static int gmac_set_ctx_params(void *vmacctx, const OSSL_PARAM params[])
         if (p->data_type != OSSL_PARAM_OCTET_STRING)
             return 0;
 
-        if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN,
-                                 p->data_size, NULL)
+        if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN,
+                                 p->data_size, NULL) <= 0
             || !EVP_EncryptInit_ex(ctx, NULL, NULL, NULL, p->data))
             return 0;
     }
diff --git a/providers/legacyprov.c b/providers/legacyprov.c
index a5999c5f8b2f..7db32d072b25 100644
--- a/providers/legacyprov.c
+++ b/providers/legacyprov.c
@@ -95,8 +95,8 @@ static const OSSL_ALGORITHM legacy_ciphers[] = {
 #ifndef OPENSSL_NO_BF
     ALG(PROV_NAMES_BF_ECB, ossl_blowfish128ecb_functions),
     ALG(PROV_NAMES_BF_CBC, ossl_blowfish128cbc_functions),
-    ALG(PROV_NAMES_BF_OFB, ossl_blowfish64ofb64_functions),
-    ALG(PROV_NAMES_BF_CFB, ossl_blowfish64cfb64_functions),
+    ALG(PROV_NAMES_BF_OFB, ossl_blowfish128ofb64_functions),
+    ALG(PROV_NAMES_BF_CFB, ossl_blowfish128cfb64_functions),
 #endif /* OPENSSL_NO_BF */
 #ifndef OPENSSL_NO_IDEA
     ALG(PROV_NAMES_IDEA_ECB, ossl_idea128ecb_functions),
diff --git a/ssl/record/rec_layer_d1.c b/ssl/record/rec_layer_d1.c
index 336ebc8b7980..532413e4d324 100644
--- a/ssl/record/rec_layer_d1.c
+++ b/ssl/record/rec_layer_d1.c
@@ -285,7 +285,7 @@ int dtls1_process_buffered_records(SSL *s)
             if (!replayok || !dtls1_process_record(s, bitmap)) {
                 if (ossl_statem_in_error(s)) {
                     /* dtls1_process_record called SSLfatal() */
-                    return -1;
+                    return 0;
                 }
                 /* dump this record */
                 rr->length = 0;
@@ -535,7 +535,7 @@ int dtls1_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,
          */
         if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
             s->d1->shutdown_received
-            && !BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s))) {
+            && BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)) <= 0) {
             s->shutdown |= SSL_RECEIVED_SHUTDOWN;
             return 0;
         }
@@ -596,7 +596,7 @@ int dtls1_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf,
                  * that nothing gets discarded.
                  */
                 if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
-                    BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s))) {
+                    BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)) > 0) {
                     s->d1->shutdown_received = 1;
                     s->rwstate = SSL_READING;
                     BIO_clear_retry_flags(SSL_get_rbio(s));
diff --git a/ssl/record/ssl3_record.c b/ssl/record/ssl3_record.c
index d8ef018741a1..dcaaeef951aa 100644
--- a/ssl/record/ssl3_record.c
+++ b/ssl/record/ssl3_record.c
@@ -1550,7 +1550,7 @@ int dtls1_process_record(SSL *s, DTLS1_BITMAP *bitmap)
             imac_size = EVP_MD_get_size(tmpmd);
             if (!ossl_assert(imac_size >= 0 && imac_size <= EVP_MAX_MD_SIZE)) {
                     SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
-                    return -1;
+                    return 0;
             }
             mac_size = (size_t)imac_size;
         }
diff --git a/ssl/record/tls_pad.c b/ssl/record/tls_pad.c
index e559350461a2..7311c8266ace 100644
--- a/ssl/record/tls_pad.c
+++ b/ssl/record/tls_pad.c
@@ -207,6 +207,7 @@ static int ssl3_cbc_copy_mac(size_t *reclen,
 #if defined(CBC_MAC_ROTATE_IN_PLACE)
     unsigned char rotated_mac_buf[64 + EVP_MAX_MD_SIZE];
     unsigned char *rotated_mac;
+    char aux1, aux2, aux3, mask;
 #else
     unsigned char rotated_mac[EVP_MAX_MD_SIZE];
 #endif
@@ -288,12 +289,19 @@ static int ssl3_cbc_copy_mac(size_t *reclen,
 #if defined(CBC_MAC_ROTATE_IN_PLACE)
     j = 0;
     for (i = 0; i < mac_size; i++) {
-        /* in case cache-line is 32 bytes, touch second line */
-        ((volatile unsigned char *)rotated_mac)[rotate_offset ^ 32];
+        /*
+         * in case cache-line is 32 bytes,
+         * load from both lines and select appropriately
+         */
+        aux1 = rotated_mac[rotate_offset & ~32];
+        aux2 = rotated_mac[rotate_offset | 32];
+        mask = constant_time_eq_8(rotate_offset & ~32, rotate_offset);
+        aux3 = constant_time_select_8(mask, aux1, aux2);
+        rotate_offset++;
 
         /* If the padding wasn't good we emit a random MAC */
         out[j++] = constant_time_select_8((unsigned char)(good & 0xff),
-                                          rotated_mac[rotate_offset++],
+                                          aux3,
                                           randmac[i]);
         rotate_offset &= constant_time_lt_s(rotate_offset, mac_size);
     }
diff --git a/ssl/s3_lib.c b/ssl/s3_lib.c
index e4eee647df0d..f530c5066d6b 100644
--- a/ssl/s3_lib.c
+++ b/ssl/s3_lib.c
@@ -4709,7 +4709,7 @@ EVP_PKEY *ssl_generate_pkey_group(SSL *s, uint16_t id)
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
         goto err;
     }
-    if (!EVP_PKEY_CTX_set_group_name(pctx, ginf->realname)) {
+    if (EVP_PKEY_CTX_set_group_name(pctx, ginf->realname) <= 0) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
         goto err;
     }
@@ -4743,7 +4743,7 @@ EVP_PKEY *ssl_generate_param_group(SSL *s, uint16_t id)
         goto err;
     if (EVP_PKEY_paramgen_init(pctx) <= 0)
         goto err;
-    if (!EVP_PKEY_CTX_set_group_name(pctx, ginf->realname)) {
+    if (EVP_PKEY_CTX_set_group_name(pctx, ginf->realname) <= 0) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
         goto err;
     }
diff --git a/ssl/ssl_conf.c b/ssl/ssl_conf.c
index f49b2e5a3750..5146cedb96ec 100644
--- a/ssl/ssl_conf.c
+++ b/ssl/ssl_conf.c
@@ -384,6 +384,8 @@ static int cmd_Options(SSL_CONF_CTX *cctx, const char *value)
         SSL_FLAG_TBL_SRV("ECDHSingle", SSL_OP_SINGLE_ECDH_USE),
         SSL_FLAG_TBL("UnsafeLegacyRenegotiation",
                      SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION),
+        SSL_FLAG_TBL("UnsafeLegacyServerConnect",
+                     SSL_OP_LEGACY_SERVER_CONNECT),
         SSL_FLAG_TBL("ClientRenegotiation",
                      SSL_OP_ALLOW_CLIENT_RENEGOTIATION),
         SSL_FLAG_TBL_INV("EncryptThenMac", SSL_OP_NO_ENCRYPT_THEN_MAC),
@@ -700,7 +702,7 @@ static const ssl_conf_cmd_tbl ssl_conf_cmds[] = {
     SSL_CONF_CMD_SWITCH("legacy_server_connect", SSL_CONF_FLAG_CLIENT),
     SSL_CONF_CMD_SWITCH("no_renegotiation", 0),
     SSL_CONF_CMD_SWITCH("no_resumption_on_reneg", SSL_CONF_FLAG_SERVER),
-    SSL_CONF_CMD_SWITCH("no_legacy_server_connect", SSL_CONF_FLAG_SERVER),
+    SSL_CONF_CMD_SWITCH("no_legacy_server_connect", SSL_CONF_FLAG_CLIENT),
     SSL_CONF_CMD_SWITCH("allow_no_dhe_kex", 0),
     SSL_CONF_CMD_SWITCH("prioritize_chacha", SSL_CONF_FLAG_SERVER),
     SSL_CONF_CMD_SWITCH("strict", 0),
diff --git a/ssl/ssl_init.c b/ssl/ssl_init.c
index 2948c3071305..b31188edea0d 100644
--- a/ssl/ssl_init.c
+++ b/ssl/ssl_init.c
@@ -46,7 +46,7 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_ssl_base)
 }
 
 static CRYPTO_ONCE ssl_strings = CRYPTO_ONCE_STATIC_INIT;
-static int ssl_strings_inited = 0;
+
 DEFINE_RUN_ONCE_STATIC(ossl_init_load_ssl_strings)
 {
     /*
@@ -56,7 +56,6 @@ DEFINE_RUN_ONCE_STATIC(ossl_init_load_ssl_strings)
 #if !defined(OPENSSL_NO_ERR) && !defined(OPENSSL_NO_AUTOERRINIT)
     OSSL_TRACE(INIT, "ossl_init_load_ssl_strings: ossl_err_load_SSL_strings()\n");
     ossl_err_load_SSL_strings();
-    ssl_strings_inited = 1;
 #endif
     return 1;
 }
@@ -82,17 +81,6 @@ static void ssl_library_stop(void)
         ssl_comp_free_compression_methods_int();
 #endif
     }
-
-    if (ssl_strings_inited) {
-        OSSL_TRACE(INIT, "ssl_library_stop: err_free_strings_int()\n");
-        /*
-         * If both crypto and ssl error strings are inited we will end up
-         * calling err_free_strings_int() twice - but that's ok. The second
-         * time will be a no-op. It's easier to do that than to try and track
-         * between the two libraries whether they have both been inited.
-         */
-        err_free_strings_int();
-    }
 }
 
 /*
diff --git a/ssl/ssl_rsa.c b/ssl/ssl_rsa.c
index cf410d6d871e..a43b9bddcd34 100644
--- a/ssl/ssl_rsa.c
+++ b/ssl/ssl_rsa.c
@@ -920,11 +920,17 @@ static int ssl_set_cert_and_key(SSL *ssl, SSL_CTX *ctx, X509 *x509, EVP_PKEY *pr
                 goto out;
             } else {
                 /* copy to privatekey from pubkey */
-                EVP_PKEY_copy_parameters(privatekey, pubkey);
+                if (!EVP_PKEY_copy_parameters(privatekey, pubkey)) {
+                    ERR_raise(ERR_LIB_SSL, SSL_R_COPY_PARAMETERS_FAILED);
+                    goto out;
+                }
             }
         } else if (EVP_PKEY_missing_parameters(pubkey)) {
             /* copy to pubkey from privatekey */
-            EVP_PKEY_copy_parameters(pubkey, privatekey);
+            if (!EVP_PKEY_copy_parameters(pubkey, privatekey)) {
+                ERR_raise(ERR_LIB_SSL, SSL_R_COPY_PARAMETERS_FAILED);
+                goto out;
+            }
         } /* else both have parameters */
 
         /* check that key <-> cert match */
diff --git a/ssl/statem/statem_clnt.c b/ssl/statem/statem_clnt.c
index 2f68b15d92be..b59eddae332a 100644
--- a/ssl/statem/statem_clnt.c
+++ b/ssl/statem/statem_clnt.c
@@ -3156,7 +3156,8 @@ static int tls_construct_cke_gost18(SSL *s, WPACKET *pkt)
 {
 #ifndef OPENSSL_NO_GOST
     /* GOST 2018 key exchange message creation */
-    unsigned char rnd_dgst[32], tmp[255];
+    unsigned char rnd_dgst[32];
+    unsigned char *encdata = NULL;
     EVP_PKEY_CTX *pkey_ctx = NULL;
     X509 *peer_cert;
     unsigned char *pms = NULL;
@@ -3221,18 +3222,19 @@ static int tls_construct_cke_gost18(SSL *s, WPACKET *pkt)
         goto err;
     }
 
-    msglen = 255;
-    if (EVP_PKEY_encrypt(pkey_ctx, tmp, &msglen, pms, pmslen) <= 0) {
-        SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_LIBRARY_BUG);
+    if (EVP_PKEY_encrypt(pkey_ctx, NULL, &msglen, pms, pmslen) <= 0) {
+        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
         goto err;
     }
 
-    if (!WPACKET_memcpy(pkt, tmp, msglen)) {
-        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
+    if (!WPACKET_allocate_bytes(pkt, msglen, &encdata)
+            || EVP_PKEY_encrypt(pkey_ctx, encdata, &msglen, pms, pmslen) <= 0) {
+        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
         goto err;
     }
 
     EVP_PKEY_CTX_free(pkey_ctx);
+    pkey_ctx = NULL;
     s->s3.tmp.pms = pms;
     s->s3.tmp.pmslen = pmslen;
 
diff --git a/ssl/t1_enc.c b/ssl/t1_enc.c
index 237a19cd9367..91238e6457b8 100644
--- a/ssl/t1_enc.c
+++ b/ssl/t1_enc.c
@@ -393,8 +393,8 @@ int tls1_change_cipher_state(SSL *s, int which)
 
     if (EVP_CIPHER_get_mode(c) == EVP_CIPH_GCM_MODE) {
         if (!EVP_CipherInit_ex(dd, c, NULL, key, NULL, (which & SSL3_CC_WRITE))
-            || !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, (int)k,
-                                    iv)) {
+            || EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, (int)k,
+                                    iv) <= 0) {
             SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
             goto err;
         }
@@ -406,9 +406,9 @@ int tls1_change_cipher_state(SSL *s, int which)
         else
             taglen = EVP_CCM_TLS_TAG_LEN;
         if (!EVP_CipherInit_ex(dd, c, NULL, NULL, NULL, (which & SSL3_CC_WRITE))
-            || !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_AEAD_SET_IVLEN, 12, NULL)
-            || !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_AEAD_SET_TAG, taglen, NULL)
-            || !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_CCM_SET_IV_FIXED, (int)k, iv)
+            || (EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_AEAD_SET_IVLEN, 12, NULL) <= 0)
+            || (EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_AEAD_SET_TAG, taglen, NULL) <= 0)
+            || (EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_CCM_SET_IV_FIXED, (int)k, iv) <= 0)
             || !EVP_CipherInit_ex(dd, NULL, NULL, key, NULL, -1)) {
             SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
             goto err;
@@ -422,8 +422,8 @@ int tls1_change_cipher_state(SSL *s, int which)
     /* Needed for "composite" AEADs, such as RC4-HMAC-MD5 */
     if ((EVP_CIPHER_get_flags(c) & EVP_CIPH_FLAG_AEAD_CIPHER)
         && *mac_secret_size
-        && !EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_AEAD_SET_MAC_KEY,
-                                (int)*mac_secret_size, mac_secret)) {
+        && EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_AEAD_SET_MAC_KEY,
+                                (int)*mac_secret_size, mac_secret) <= 0) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);
         goto err;
     }
diff --git a/ssl/t1_lib.c b/ssl/t1_lib.c
index 41fddf22a727..27e8f04ea3d2 100644
--- a/ssl/t1_lib.c
+++ b/ssl/t1_lib.c
@@ -2815,22 +2815,20 @@ int tls1_check_chain(SSL *s, X509 *x, EVP_PKEY *pk, STACK_OF(X509) *chain,
 
         ca_dn = s->s3.tmp.peer_ca_names;
 
-        if (!sk_X509_NAME_num(ca_dn))
+        if (ca_dn == NULL
+            || sk_X509_NAME_num(ca_dn) == 0
+            || ssl_check_ca_name(ca_dn, x))
             rv |= CERT_PKEY_ISSUER_NAME;
-
-        if (!(rv & CERT_PKEY_ISSUER_NAME)) {
-            if (ssl_check_ca_name(ca_dn, x))
-                rv |= CERT_PKEY_ISSUER_NAME;
-        }
-        if (!(rv & CERT_PKEY_ISSUER_NAME)) {
+        else
             for (i = 0; i < sk_X509_num(chain); i++) {
                 X509 *xtmp = sk_X509_value(chain, i);
+
                 if (ssl_check_ca_name(ca_dn, xtmp)) {
                     rv |= CERT_PKEY_ISSUER_NAME;
                     break;
                 }
             }
-        }
+
         if (!check_flags && !(rv & CERT_PKEY_ISSUER_NAME))
             goto end;
     } else
@@ -3010,6 +3008,8 @@ int ssl_security_cert_chain(SSL *s, STACK_OF(X509) *sk, X509 *x, int vfy)
     int rv, start_idx, i;
     if (x == NULL) {
         x = sk_X509_value(sk, 0);
+        if (x == NULL)
+            return ERR_R_INTERNAL_ERROR;
         start_idx = 1;
     } else
         start_idx = 0;
diff --git a/ssl/tls13_enc.c b/ssl/tls13_enc.c
index 12388922e339..d7db82e5e26e 100644
--- a/ssl/tls13_enc.c
+++ b/ssl/tls13_enc.c
@@ -385,9 +385,9 @@ static int derive_secret_key_and_iv(SSL *s, int sending, const EVP_MD *md,
     }
 
     if (EVP_CipherInit_ex(ciph_ctx, ciph, NULL, NULL, NULL, sending) <= 0
-        || !EVP_CIPHER_CTX_ctrl(ciph_ctx, EVP_CTRL_AEAD_SET_IVLEN, ivlen, NULL)
-        || (taglen != 0 && !EVP_CIPHER_CTX_ctrl(ciph_ctx, EVP_CTRL_AEAD_SET_TAG,
-                                                taglen, NULL))
+        || EVP_CIPHER_CTX_ctrl(ciph_ctx, EVP_CTRL_AEAD_SET_IVLEN, ivlen, NULL) <= 0
+        || (taglen != 0 && EVP_CIPHER_CTX_ctrl(ciph_ctx, EVP_CTRL_AEAD_SET_TAG,
+                                                taglen, NULL) <= 0)
         || EVP_CipherInit_ex(ciph_ctx, NULL, NULL, key, NULL, -1) <= 0) {
         SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB);
         return 0;
diff --git a/ssl/tls_srp.c b/ssl/tls_srp.c
index 0ce3290dc4aa..e69ddfe9d589 100644
--- a/ssl/tls_srp.c
+++ b/ssl/tls_srp.c
@@ -301,7 +301,7 @@ int SSL_set_srp_server_param(SSL *s, const BIGNUM *N, const BIGNUM *g,
 int srp_generate_server_master_secret(SSL *s)
 {
     BIGNUM *K = NULL, *u = NULL;
-    int ret = -1, tmp_len = 0;
+    int ret = 0, tmp_len = 0;
     unsigned char *tmp = NULL;
 
     if (!SRP_Verify_A_mod_N(s->srp_ctx.A, s->srp_ctx.N))
@@ -331,7 +331,7 @@ int srp_generate_server_master_secret(SSL *s)
 int srp_generate_client_master_secret(SSL *s)
 {
     BIGNUM *x = NULL, *u = NULL, *K = NULL;
-    int ret = -1, tmp_len = 0;
+    int ret = 0, tmp_len = 0;
     char *passwd = NULL;
     unsigned char *tmp = NULL;
 
diff --git a/test/acvp_test.c b/test/acvp_test.c
index bbc77d0ae610..b451cafcd9ec 100644
--- a/test/acvp_test.c
+++ b/test/acvp_test.c
@@ -734,10 +734,10 @@ static int aes_ccm_enc_dec(const char *alg,
     if (!TEST_ptr(ctx = EVP_CIPHER_CTX_new())
         || !TEST_ptr(cipher = EVP_CIPHER_fetch(libctx, alg, ""))
         || !TEST_true(EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, enc))
-        || !TEST_true(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, iv_len,
-                                          NULL))
-        || !TEST_true(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, tag_len,
-                                          enc ? NULL : (void *)tag))
+        || !TEST_int_gt(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, iv_len,
+                                          NULL), 0)
+        || !TEST_int_gt(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, tag_len,
+                                          enc ? NULL : (void *)tag), 0)
         || !TEST_true(EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, enc))
         || !TEST_true(EVP_CIPHER_CTX_set_padding(ctx, 0))
         || !TEST_true(EVP_CipherUpdate(ctx, NULL, &len, NULL, pt_len))
@@ -753,8 +753,8 @@ static int aes_ccm_enc_dec(const char *alg,
         goto err;
     if (enc) {
         out_len += len;
-        if (!TEST_true(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG,
-                                           tag_len, out + out_len))
+        if (!TEST_int_gt(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG,
+                                           tag_len, out + out_len), 0)
             || !TEST_mem_eq(out, out_len, ct, ct_len)
             || !TEST_mem_eq(out + out_len, tag_len, tag, tag_len))
             goto err;
@@ -821,13 +821,13 @@ static int aes_gcm_enc_dec(const char *alg,
     if (!TEST_ptr(ctx = EVP_CIPHER_CTX_new())
         || !TEST_ptr(cipher = EVP_CIPHER_fetch(libctx, alg, ""))
         || !TEST_true(EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, enc))
-        || !TEST_true(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, iv_len,
-                                          NULL)))
+        || !TEST_int_gt(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_IVLEN, iv_len,
+                                          NULL), 0))
         goto err;
 
     if (!enc) {
-        if (!TEST_true(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, tag_len,
-                                           (void *)tag)))
+        if (!TEST_int_gt(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG, tag_len,
+                                           (void *)tag), 0))
             goto err;
     }
     /*
@@ -850,8 +850,8 @@ static int aes_gcm_enc_dec(const char *alg,
     out_len += len;
     if (enc) {
         if (!TEST_mem_eq(out, out_len, ct, ct_len)
-            || !TEST_true(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG,
-                                              tag_len, out + out_len))
+            || !TEST_int_gt(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG,
+                                              tag_len, out + out_len), 0)
             || !TEST_mem_eq(out + out_len, tag_len, tag, tag_len))
                     goto err;
     } else {
@@ -1091,9 +1091,9 @@ static int rsa_keygen_test(int id)
     if (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(libctx, "RSA", NULL))
         || !TEST_ptr(e_bn = BN_bin2bn(tst->e, tst->e_len, NULL))
         || !TEST_int_gt(EVP_PKEY_keygen_init(ctx), 0)
-        || !TEST_true(EVP_PKEY_CTX_set_params(ctx, params))
-        || !TEST_true(EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, tst->mod))
-        || !TEST_true(EVP_PKEY_CTX_set1_rsa_keygen_pubexp(ctx, e_bn))
+        || !TEST_int_gt(EVP_PKEY_CTX_set_params(ctx, params), 0)
+        || !TEST_int_gt(EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, tst->mod), 0)
+        || !TEST_int_gt(EVP_PKEY_CTX_set1_rsa_keygen_pubexp(ctx, e_bn), 0)
         || !TEST_int_gt(EVP_PKEY_keygen(ctx, &pkey), 0)
         || !TEST_true(pkey_get_bn_bytes(pkey, OSSL_PKEY_PARAM_RSA_TEST_P1,
                                         &p1, &p1_len))
diff --git a/test/aesgcmtest.c b/test/aesgcmtest.c
index c371f4754ef5..119d316a269d 100644
--- a/test/aesgcmtest.c
+++ b/test/aesgcmtest.c
@@ -111,7 +111,7 @@ static int badkeylen_test(void)
     ret = TEST_ptr(cipher = EVP_aes_192_gcm())
           && TEST_ptr(ctx = EVP_CIPHER_CTX_new())
           && TEST_true(EVP_EncryptInit_ex(ctx, cipher, NULL, NULL, NULL))
-          && TEST_false(EVP_CIPHER_CTX_set_key_length(ctx, 2));
+          && TEST_int_le(EVP_CIPHER_CTX_set_key_length(ctx, 2), 0);
     EVP_CIPHER_CTX_free(ctx);
     return ret;
 }
diff --git a/test/bad_dtls_test.c b/test/bad_dtls_test.c
index f8c6b142d84b..027ce8266dfc 100644
--- a/test/bad_dtls_test.c
+++ b/test/bad_dtls_test.c
@@ -331,7 +331,7 @@ static int send_record(BIO *rbio, unsigned char type, uint64_t seqnr,
     } while (len % 16);
 
     /* Generate IV, and encrypt */
-    if (!TEST_true(RAND_bytes(iv, sizeof(iv)))
+    if (!TEST_int_gt(RAND_bytes(iv, sizeof(iv)), 0)
             || !TEST_ptr(enc_ctx = EVP_CIPHER_CTX_new())
             || !TEST_true(EVP_CipherInit_ex(enc_ctx, EVP_aes_128_cbc(), NULL,
                                             enc_key, iv, 1))
diff --git a/test/certs/embeddedSCTs1.pem b/test/certs/embeddedSCTs1.pem
index d2a111fb8235..c9c649071646 100644
--- a/test/certs/embeddedSCTs1.pem
+++ b/test/certs/embeddedSCTs1.pem
@@ -1,5 +1,5 @@
 -----BEGIN CERTIFICATE-----
-MIIDeDCCAuGgAwIBAgIBAjANBgkqhkiG9w0BAQsFADBVMQswCQYDVQQGEwJHQjEk
+MIID+TCCAuGgAwIBAgIBAjANBgkqhkiG9w0BAQsFADBVMQswCQYDVQQGEwJHQjEk
 MCIGA1UEChMbQ2VydGlmaWNhdGUgVHJhbnNwYXJlbmN5IENBMQ4wDAYDVQQIEwVX
 YWxlczEQMA4GA1UEBxMHRXJ3IFdlbjAgFw0yMDAxMjUxMTUwMTNaGA8yMTIwMDEy
 NjExNTAxM1owGTEXMBUGA1UEAwwOc2VydmVyLmV4YW1wbGUwggEiMA0GCSqGSIb3
@@ -12,10 +12,13 @@ wuN7dH2TSsZrlxrt1cCf1TKkoqnbnHg1emeMZfm3FURh82+pAgMBAAGjggEMMIIB
 CDAdBgNVHQ4EFgQUtMa8XD5ylrF9AqCdnPEhXa63H2owHwYDVR0jBBgwFoAUX52I
 Dchz5lTU+A3Y5rDBJLRHw1UwCQYDVR0TBAIwADATBgNVHSUEDDAKBggrBgEFBQcD
 ATCBigYKKwYBBAHWeQIEAgR8BHoAeAB2AN8cLsEVAJRSR6lhaDJd3Fx5Wej3xtOI
-/AAuC70/dNdkAAABb15m6AAAAAQDAEcwRQIgfDPo8RArm/vcSEZ608Q1u+XQ55QB
-u67SZEuZxLpbUM0CIQDRsgcTud4PDy8Cgg+lHeAS7UxgSKBbWAznYOuorwNewzAZ
-BgNVHREEEjAQgg5zZXJ2ZXIuZXhhbXBsZTANBgkqhkiG9w0BAQsFAAOBgQCWFKKR
-RNkDRzB25NK07OLkbzebhnpKtbP4i3blRx1HAvTSamf/3uuHI7kfiPJorJymJpT1
-IuJvSVKyMu1qONWBimiBfiyGL7+le1izHEJIP5lVTbddfzSIBIvrlHHcWIOL3H+W
-YT6yTEIzJuO07Xp61qnB1CE2TrinUWlyC46Zkw==
+/AAuC70/dNdkAAABb15m6AAAAAQDAEcwRQIgVVLvhQAex2omlFnb+MczYTjvUETM
+SW6EeAIxPuicWWcCIQCYJYPr1uLeBMcq2RJCtoWgs/F0BsfUFnhJk/lav8NoNDAZ
+BgNVHREEEjAQgg5zZXJ2ZXIuZXhhbXBsZTANBgkqhkiG9w0BAQsFAAOCAQEATRog
+ZfvqRl9hMgYODL8VVRJNgqQqKVLCGME4ksBudWKPO0ulfD+de81WCFEHINBu2sPa
+NSs3YHv/5eaw0tJAd4lPGGhGCl/qEIqQxN6wKcenIWu2M4QzsH6V4D7IuR+OUZCC
+vNN//NpdIH1KbNGViQCw7o5ClL1+ow0MT+PuzGCI7LkdHTJzyoftzGSHqF/DzDDd
+uO4ez6fQR4aj/CvQ6UZAy8ihYc2B+dz6NR/nGdCkIs7eEWISOxCgmH8NAJLgPOaU
+Odw3qk4hXEyTiPkMsSjl9QSfQi5s6d9rbEuQ22ow6H092n7Du15AZS4kKlHxDa5s
+G8vj2f3xch0fyx+c+w==
 -----END CERTIFICATE-----
diff --git a/test/certs/embeddedSCTs1.sct b/test/certs/embeddedSCTs1.sct
index 9e413e3dc7b9..475d7b8f770c 100644
--- a/test/certs/embeddedSCTs1.sct
+++ b/test/certs/embeddedSCTs1.sct
@@ -5,8 +5,8 @@
     Timestamp : Jan  1 00:00:00.000 2020 GMT
     Extensions: none
     Signature : ecdsa-with-SHA256
-                30:45:02:20:7C:33:E8:F1:10:2B:9B:FB:DC:48:46:7A:
-                D3:C4:35:BB:E5:D0:E7:94:01:BB:AE:D2:64:4B:99:C4:
-                BA:5B:50:CD:02:21:00:D1:B2:07:13:B9:DE:0F:0F:2F:
-                02:82:0F:A5:1D:E0:12:ED:4C:60:48:A0:5B:58:0C:E7:
-                60:EB:A8:AF:03:5E:C3
+                30:45:02:20:55:52:EF:85:00:1E:C7:6A:26:94:59:DB:
+                F8:C7:33:61:38:EF:50:44:CC:49:6E:84:78:02:31:3E:
+                E8:9C:59:67:02:21:00:98:25:83:EB:D6:E2:DE:04:C7:
+                2A:D9:12:42:B6:85:A0:B3:F1:74:06:C7:D4:16:78:49:
+                93:F9:5A:BF:C3:68:34
diff --git a/test/certs/embeddedSCTs1_issuer-key.pem b/test/certs/embeddedSCTs1_issuer-key.pem
index 9326e38b1eb7..0cb59e43cb95 100644
--- a/test/certs/embeddedSCTs1_issuer-key.pem
+++ b/test/certs/embeddedSCTs1_issuer-key.pem
@@ -1,15 +1,27 @@
 -----BEGIN RSA PRIVATE KEY-----
-MIICXAIBAAKBgQDVimhTYhCicRmTbneDIRgcKkATxtB7jHbrkVfT0PtLO1FuzsvR
-yY2RxS90P6tjXVUJnNE6uvMa5UFEJFGnTHgW8iQ8+EjPKDHM5nugSlojgZ88ujfm
-JNnDvbKZuDnd/iYx0ss6hPx7srXFL8/BT/9Ab1zURmnLsvfP34b7arnRsQIDAQAB
-AoGAJLR6xEJp+5IXRFlLn7WTkFvO0ddtxJ7bXhiIkTctyruyfqp7LF9Jv1G2m3PK
-QPUtBc73w/GYkfnwIwdfJbOmPHL7XyEGHZYmEXgIgEtw6LXvAv0G5JpUnNwsSBfL
-GfSQqI5Z5ytyzlJXkMcTGA2kTgNAYc73h4EnU+pwUnDPdAECQQD2aj+4LtYk1XPq
-r3gjgI6MoGvgYJfPmAtZhxxVbhXQKciFUCAcBiwlQdHIdLWE9j65ctmZRWidKifr
-4O4nz+TBAkEA3djNW/rTQq5fKZy+mCF1WYnIU/3yhJaptzRqLm7AHqe7+hdrGXJw
-+mCtU8T3L/Ms8bH1yFBZhmkp1PbR8gl48QJAQo70YyWThiN5yfxXcQ96cZWrTdIJ
-b3NcLXSHPLQdhDqlBQ1dfvRT3ERpC8IqfZ2d162kBPhwh3MpkVcSPQK0gQJAC/dY
-xGBYKt2a9nSk9zG+0bCT5Kvq++ngh6hFHfINXNnxUsEWns3EeEzkrIMQTj7QqszN
-lBt5aL2dawZRNrv6EQJBAOo4STF9KEwQG0HLC/ryh1FeB0OBA5yIepXze+eJVKei
-T0cCECOQJKfWHEzYJYDJhyEFF/sYp9TXwKSDjOifrsU=
+MIIEogIBAAKCAQEAwckj9DNhinn9gUivB5TNOW8vsn8Kn5UXms8V3TlYQx9I37mW
+kabOB5meZ6221is1oANJkQk9MZv3Jlap/8P3Vt4yAmslclbuT7oOoZdpX8x5yoED
+L3PoSNARLj25PvWR7Djtd9O9pTuZcUEbd5guJddw5Pj3HA0Q7a+5tHOSWG63p3pF
+ZONyticwBVWfvBkMHbWkA8g6EDvAbKmz26r5FQlfsOw/0U6CP0oJKkhJHSchFYG8
+IsjfkV3LXNbCwV4n9vOCx4cZNUznjaF0uUsOj0kmvP0bprVSEXMIGxitl4Z/vUru
+WaR3mN2/Od/TnicxyMohAKqeeG16QK2Z4uXe8wIDAQABAoIBADYYp1/JZCZbDaik
+mK/eGzg4ULFcg6Ou5CsEOk9Kbdg3CInj7iN01DkM6kp5FPxOjabApC3HzXxm1KSw
+Nr6+fvKSDpXcQVTc7aP2BZWYhgMHOsyMHU6G5cZFxzYIZwkrVnQCJFB6HIveymPy
+T++f3OoVbV+OHLWI9DvV/VphlO34ZaWHtDjor4+ycNSkdpH2t1ecmob/zs/5lt+T
+5xfQ38qpuWWJiXstd6O4THgTU9u8/E6CIAdS5CiYORoW/EqRMlV8lt10dfG75feF
+WvZD+w/DHgFi1izLaSRsHqHHT1hc3h1tFl1c1XDvkTFPgTqbk01VK9IvsPn9QKcc
++Sw7o0ECgYEA8ghy34lSSbGrvk+djU+vwQ7VEPE5+gicp4Dl2E0tEeZyRt3q4Vt5
+QF60D7Q6E6NjzIEVsm7Ic/qo12klOSMJ4NB5r+oMTJ6R+09/9gzyWx9sYb1rzgYh
+FtOex6fzYQnqPydb06u/crdL7lbxmYlK09rr/wcqzMx7gmkqMBmtS9MCgYEAzPfv
+Uc+wN8ZPzpRbGabenoyTf+v4+f+VfIGMUw9TKQZozsGVypZeAy++l9sAymaty3FH
+oob5P8i9dwFHhaaXmWCBZyWxRJbQ+tTYAulQd/FZoaGX8SdENPmcLnTTXnDPXJTT
+YyDQwpYFl2Qv6n0DPY0HvtR3iG/0VoM9Rt7wzGECgYApYYJqb6sPCH6JokkYsQgm
+pOeO5v93nWNTTDl/+un6xoDBVw3ii+Y2ODrm+HR5iRT2ERfpkwFYuwGFGugPVctJ
+kbtMdWK28uGYqyYApoQFSmEYcO9uoSOlKHdcQX3eGHjhZVRQ42tvLKGh1WGnU47k
+m+h/iPUrYMa5LEvXP3yemwKBgDhWCSxGVlvuIO9ZrXRufg+7+aqWVDd6fT7caJJH
+ywaioVn6sU4eaDad/9fDNQNsl2Yse5D7YjSa2yCDdIISmOZqNQcBwChm/4eByuF5
++UkOSCF5xcZdkYyx8rB+Ib56aTQ8H6HGWjqxe1XyDo130NUxFyjnQvd4NgM1TTlW
+e37hAoGAGj8eUtfqyChkIYFqnDZM/cH9a/hISTXItFwMVltY46s+IoxrQK9xG8Ke
+K1pGSiKs3m0L/qKLmKGThBdR1DjFw6Y7qajg0JZtzdcnyWRQpOrTC7mxtjSkcQ3e
+56h1nvYF3IgtobIOyxoO05oiQHv1fn8hK5PjdBMdeDxkWJT/a2s=
 -----END RSA PRIVATE KEY-----
diff --git a/test/certs/embeddedSCTs1_issuer.pem b/test/certs/embeddedSCTs1_issuer.pem
index 1fa449d5a098..ebcd4b4861e2 100644
--- a/test/certs/embeddedSCTs1_issuer.pem
+++ b/test/certs/embeddedSCTs1_issuer.pem
@@ -1,18 +1,23 @@
 -----BEGIN CERTIFICATE-----
-MIIC0DCCAjmgAwIBAgIBADANBgkqhkiG9w0BAQUFADBVMQswCQYDVQQGEwJHQjEk
+MIID1zCCAr+gAwIBAgIBADANBgkqhkiG9w0BAQsFADBVMQswCQYDVQQGEwJHQjEk
 MCIGA1UEChMbQ2VydGlmaWNhdGUgVHJhbnNwYXJlbmN5IENBMQ4wDAYDVQQIEwVX
-YWxlczEQMA4GA1UEBxMHRXJ3IFdlbjAeFw0xMjA2MDEwMDAwMDBaFw0yMjA2MDEw
-MDAwMDBaMFUxCzAJBgNVBAYTAkdCMSQwIgYDVQQKExtDZXJ0aWZpY2F0ZSBUcmFu
-c3BhcmVuY3kgQ0ExDjAMBgNVBAgTBVdhbGVzMRAwDgYDVQQHEwdFcncgV2VuMIGf
-MA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDVimhTYhCicRmTbneDIRgcKkATxtB7
-jHbrkVfT0PtLO1FuzsvRyY2RxS90P6tjXVUJnNE6uvMa5UFEJFGnTHgW8iQ8+EjP
-KDHM5nugSlojgZ88ujfmJNnDvbKZuDnd/iYx0ss6hPx7srXFL8/BT/9Ab1zURmnL
-svfP34b7arnRsQIDAQABo4GvMIGsMB0GA1UdDgQWBBRfnYgNyHPmVNT4DdjmsMEk
-tEfDVTB9BgNVHSMEdjB0gBRfnYgNyHPmVNT4DdjmsMEktEfDVaFZpFcwVTELMAkG
-A1UEBhMCR0IxJDAiBgNVBAoTG0NlcnRpZmljYXRlIFRyYW5zcGFyZW5jeSBDQTEO
-MAwGA1UECBMFV2FsZXMxEDAOBgNVBAcTB0VydyBXZW6CAQAwDAYDVR0TBAUwAwEB
-/zANBgkqhkiG9w0BAQUFAAOBgQAGCMxKbWTyIF4UbASydvkrDvqUpdryOvw4BmBt
-OZDQoeojPUApV2lGOwRmYef6HReZFSCa6i4Kd1F2QRIn18ADB8dHDmFYT9czQiRy
-f1HWkLxHqd81TbD26yWVXeGJPE3VICskovPkQNJ0tU4b03YmnKliibduyqQQkOFP
-OwqULg==
+YWxlczEQMA4GA1UEBxMHRXJ3IFdlbjAgFw0yMjA2MDExMDM4MDJaGA8yMTIyMDUw
+ODEwMzgwMlowVTELMAkGA1UEBhMCR0IxJDAiBgNVBAoTG0NlcnRpZmljYXRlIFRy
+YW5zcGFyZW5jeSBDQTEOMAwGA1UECBMFV2FsZXMxEDAOBgNVBAcTB0VydyBXZW4w
+ggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDBySP0M2GKef2BSK8HlM05
+by+yfwqflReazxXdOVhDH0jfuZaRps4HmZ5nrbbWKzWgA0mRCT0xm/cmVqn/w/dW
+3jICayVyVu5Pug6hl2lfzHnKgQMvc+hI0BEuPbk+9ZHsOO13072lO5lxQRt3mC4l
+13Dk+PccDRDtr7m0c5JYbrenekVk43K2JzAFVZ+8GQwdtaQDyDoQO8BsqbPbqvkV
+CV+w7D/RToI/SgkqSEkdJyEVgbwiyN+RXctc1sLBXif284LHhxk1TOeNoXS5Sw6P
+SSa8/RumtVIRcwgbGK2Xhn+9Su5ZpHeY3b8539OeJzHIyiEAqp54bXpArZni5d7z
+AgMBAAGjga8wgawwHQYDVR0OBBYEFF+diA3Ic+ZU1PgN2OawwSS0R8NVMH0GA1Ud
+IwR2MHSAFF+diA3Ic+ZU1PgN2OawwSS0R8NVoVmkVzBVMQswCQYDVQQGEwJHQjEk
+MCIGA1UEChMbQ2VydGlmaWNhdGUgVHJhbnNwYXJlbmN5IENBMQ4wDAYDVQQIEwVX
+YWxlczEQMA4GA1UEBxMHRXJ3IFdlboIBADAMBgNVHRMEBTADAQH/MA0GCSqGSIb3
+DQEBCwUAA4IBAQAx4nGkweUG9fE1IpAsRSNoW+OzxWmzhLXHWFslPHe8P7OODW+y
+t5nUWdAwPej7vGo/y2nF9Y2WbRKwJrAcNFn6rLnrA5nuzH+mOJt5EckajWWU2MqF
+9nLfQiNsds85//r3ENQ3wfh6hZojvh98o+5mC5AV8JzORyj5NxzDXp5zdf8dt00s
+D612d/RTFMPPzVK5vYBOoCusafV5qI/c4DYi02B00xtkUj3lFZc5afGpWIbJIarc
+ESlqR3J66UetqbK4bP/nwQlW3PgZCpJXSHVPuwK3V+4ZTSVd5+FbYVp1DXp/qbq8
+P6RD7n+MnBgdEH0AFtgQ28effUXaSWDTXxze
 -----END CERTIFICATE-----
diff --git a/test/drbgtest.c b/test/drbgtest.c
index a6fd46595aa9..8af64d23b0ca 100644
--- a/test/drbgtest.c
+++ b/test/drbgtest.c
@@ -531,7 +531,7 @@ static int test_rand_fork_safety(int i)
         success = 0;
 
     /* request a single byte from each of the DRBGs before the next run */
-    if (!TEST_true(RAND_bytes(random, 1) && RAND_priv_bytes(random, 1)))
+    if (!TEST_int_gt(RAND_bytes(random, 1), 0) || !TEST_int_gt(RAND_priv_bytes(random, 1), 0))
         success = 0;
 
     return success;
diff --git a/test/ecdsatest.c b/test/ecdsatest.c
index 282b9660d315..0baeb8923046 100644
--- a/test/ecdsatest.c
+++ b/test/ecdsatest.c
@@ -223,7 +223,7 @@ static int test_builtin(int n, int as)
 
     if (!TEST_ptr(mctx = EVP_MD_CTX_new())
         /* get some random message data */
-        || !TEST_true(RAND_bytes(tbs, sizeof(tbs)))
+        || !TEST_int_gt(RAND_bytes(tbs, sizeof(tbs)), 0)
         /* real key */
         || !TEST_ptr(eckey = EC_KEY_new_by_curve_name(nid))
         || !TEST_true(EC_KEY_generate_key(eckey))
diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c
index 3b597617791a..e78edeb23763 100644
--- a/test/evp_extra_test.c
+++ b/test/evp_extra_test.c
@@ -1759,8 +1759,8 @@ static int test_EC_keygen_with_enc(int idx)
     /* Create key parameters */
     if (!TEST_ptr(pctx = EVP_PKEY_CTX_new_from_name(testctx, "EC", NULL))
         || !TEST_int_gt(EVP_PKEY_paramgen_init(pctx), 0)
-        || !TEST_true(EVP_PKEY_CTX_set_group_name(pctx, "P-256"))
-        || !TEST_true(EVP_PKEY_CTX_set_ec_param_enc(pctx, enc))
+        || !TEST_int_gt(EVP_PKEY_CTX_set_group_name(pctx, "P-256"), 0)
+        || !TEST_int_gt(EVP_PKEY_CTX_set_ec_param_enc(pctx, enc), 0)
         || !TEST_true(EVP_PKEY_paramgen(pctx, &params))
         || !TEST_ptr(params))
         goto done;
@@ -1897,7 +1897,7 @@ static int test_EVP_SM2(void)
     if (!TEST_true(EVP_PKEY_paramgen_init(pctx) == 1))
         goto done;
 
-    if (!TEST_true(EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx, NID_sm2)))
+    if (!TEST_int_gt(EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx, NID_sm2), 0))
         goto done;
 
     if (!TEST_true(EVP_PKEY_paramgen(pctx, &pkeyparams)))
@@ -3267,6 +3267,31 @@ static int test_evp_iv_des(int idx)
 }
 #endif
 
+#ifndef OPENSSL_NO_BF
+static int test_evp_bf_default_keylen(int idx)
+{
+    int ret = 0;
+    static const char *algos[4] = {
+        "bf-ecb", "bf-cbc", "bf-cfb", "bf-ofb"
+    };
+    int ivlen[4] = { 0, 8, 8, 8 };
+    EVP_CIPHER *cipher = NULL;
+
+    if (lgcyprov == NULL)
+        return TEST_skip("Test requires legacy provider to be loaded");
+
+    if (!TEST_ptr(cipher = EVP_CIPHER_fetch(testctx, algos[idx], testpropq))
+            || !TEST_int_eq(EVP_CIPHER_get_key_length(cipher), 16)
+            || !TEST_int_eq(EVP_CIPHER_get_iv_length(cipher), ivlen[idx]))
+        goto err;
+
+    ret = 1;
+err:
+    EVP_CIPHER_free(cipher);
+    return ret;
+}
+#endif
+
 #ifndef OPENSSL_NO_EC
 static int ecpub_nids[] = {
     NID_brainpoolP256r1, NID_X9_62_prime256v1,
@@ -3300,7 +3325,7 @@ static int test_ecpub(int idx)
     ctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL);
     if (!TEST_ptr(ctx)
         || !TEST_int_gt(EVP_PKEY_keygen_init(ctx), 0)
-        || !TEST_true(EVP_PKEY_CTX_set_ec_paramgen_curve_nid(ctx, nid))
+        || !TEST_int_gt(EVP_PKEY_CTX_set_ec_paramgen_curve_nid(ctx, nid), 0)
         || !TEST_true(EVP_PKEY_keygen(ctx, &pkey)))
         goto done;
     len = i2d_PublicKey(pkey, NULL);
@@ -3352,10 +3377,10 @@ static int test_EVP_rsa_pss_with_keygen_bits(void)
 
     md = EVP_MD_fetch(testctx, "sha256", testpropq);
     ret = TEST_ptr(md)
-        && TEST_ptr((ctx = EVP_PKEY_CTX_new_from_name(testctx, "RSA", testpropq)))
+        && TEST_ptr((ctx = EVP_PKEY_CTX_new_from_name(testctx, "RSA-PSS", testpropq)))
         && TEST_int_gt(EVP_PKEY_keygen_init(ctx), 0)
         && TEST_int_gt(EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 512), 0)
-        && TEST_true(EVP_PKEY_CTX_set_rsa_pss_keygen_md(ctx, md))
+        && TEST_int_gt(EVP_PKEY_CTX_set_rsa_pss_keygen_md(ctx, md), 0)
         && TEST_true(EVP_PKEY_keygen(ctx, &pkey));
 
     EVP_MD_free(md);
@@ -3379,8 +3404,8 @@ static int test_EVP_rsa_pss_set_saltlen(void)
         && TEST_ptr(sha256_ctx = EVP_MD_CTX_new())
         && TEST_true(EVP_DigestSignInit(sha256_ctx, &pkey_ctx, sha256, NULL, pkey))
         && TEST_true(EVP_PKEY_CTX_set_rsa_padding(pkey_ctx, RSA_PKCS1_PSS_PADDING))
-        && TEST_true(EVP_PKEY_CTX_set_rsa_pss_saltlen(pkey_ctx, test_value))
-        && TEST_true(EVP_PKEY_CTX_get_rsa_pss_saltlen(pkey_ctx, &saltlen))
+        && TEST_int_gt(EVP_PKEY_CTX_set_rsa_pss_saltlen(pkey_ctx, test_value), 0)
+        && TEST_int_gt(EVP_PKEY_CTX_get_rsa_pss_saltlen(pkey_ctx, &saltlen), 0)
         && TEST_int_eq(saltlen, test_value);
 
     EVP_MD_CTX_free(sha256_ctx);
@@ -3506,7 +3531,7 @@ static int evp_init_seq_set_iv(EVP_CIPHER_CTX *ctx, const EVP_INIT_TEST_st *t)
     int res = 0;
     
     if (t->ivlen != 0) {
-        if (!TEST_true(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, t->ivlen, NULL)))
+        if (!TEST_int_gt(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, t->ivlen, NULL), 0))
             goto err;
     }
     if (!TEST_true(EVP_CipherInit_ex(ctx, NULL, NULL, NULL, t->iv, -1)))
@@ -3572,8 +3597,8 @@ static int test_evp_init_seq(int idx)
     }
     if (t->finalenc == 0 && t->tag != NULL) {
         /* Set expected tag */
-        if (!TEST_true(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG,
-                                           t->taglen, (void *)t->tag))) {
+        if (!TEST_int_gt(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG,
+                                           t->taglen, (void *)t->tag), 0)) {
             errmsg = "SET_TAG";
             goto err;
         }
@@ -3587,7 +3612,7 @@ static int test_evp_init_seq(int idx)
         goto err;
     }
     if (t->finalenc != 0 && t->tag != NULL) {
-        if (!TEST_true(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, taglen, tag))) {
+        if (!TEST_int_gt(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, taglen, tag), 0)) {
             errmsg = "GET_TAG";
             goto err;
         }
@@ -3848,7 +3873,7 @@ static int test_gcm_reinit(int idx)
         errmsg = "ENC_INIT";
         goto err;
     }
-    if (!TEST_true(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, t->ivlen1, NULL))) {
+    if (!TEST_int_gt(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, t->ivlen1, NULL), 0)) {
         errmsg = "SET_IVLEN1";
         goto err;
     }
@@ -3874,7 +3899,7 @@ static int test_gcm_reinit(int idx)
         errmsg = "WRONG_RESULT1";
         goto err;
     }
-    if (!TEST_true(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, taglen, tag))) {
+    if (!TEST_int_gt(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, taglen, tag), 0)) {
         errmsg = "GET_TAG1";
         goto err;
     }
@@ -3883,7 +3908,7 @@ static int test_gcm_reinit(int idx)
         goto err;
     }
     /* Now reinit */
-    if (!TEST_true(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, t->ivlen2, NULL))) {
+    if (!TEST_int_gt(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, t->ivlen2, NULL), 0)) {
         errmsg = "SET_IVLEN2";
         goto err;
     }
@@ -3908,7 +3933,7 @@ static int test_gcm_reinit(int idx)
         errmsg = "WRONG_RESULT2";
         goto err;
     }
-    if (!TEST_true(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, taglen, tag))) {
+    if (!TEST_int_gt(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG, taglen, tag), 0)) {
         errmsg = "GET_TAG2";
         goto err;
     }
@@ -4557,6 +4582,9 @@ int setup_tests(void)
     ADD_ALL_TESTS(test_evp_iv_aes, 12);
 #ifndef OPENSSL_NO_DES
     ADD_ALL_TESTS(test_evp_iv_des, 6);
+#endif
+#ifndef OPENSSL_NO_BF
+    ADD_ALL_TESTS(test_evp_bf_default_keylen, 4);
 #endif
     ADD_TEST(test_EVP_rsa_pss_with_keygen_bits);
     ADD_TEST(test_EVP_rsa_pss_set_saltlen);
diff --git a/test/evp_extra_test2.c b/test/evp_extra_test2.c
index 55a18c2f5471..0021c4434140 100644
--- a/test/evp_extra_test2.c
+++ b/test/evp_extra_test2.c
@@ -512,6 +512,42 @@ static int test_alternative_default(void)
     return ok;
 }
 
+static int test_provider_unload_effective(int testid)
+{
+    EVP_MD *sha256 = NULL;
+    OSSL_PROVIDER *provider = NULL;
+    int ok = 0;
+
+    if (!TEST_ptr(provider = OSSL_PROVIDER_load(NULL, "default"))
+        || !TEST_ptr(sha256 = EVP_MD_fetch(NULL, "SHA2-256", NULL)))
+        goto err;
+
+    if (testid > 0) {
+        OSSL_PROVIDER_unload(provider);
+        provider = NULL;
+        EVP_MD_free(sha256);
+        sha256 = NULL;
+    } else {
+        EVP_MD_free(sha256);
+        sha256 = NULL;
+        OSSL_PROVIDER_unload(provider);
+        provider = NULL;
+    }
+
+    /*
+     * setup_tests() loaded the "null" provider in the current default, and
+     * we unloaded it above after the load so we know this fetch should fail.
+     */
+    if (!TEST_ptr_null(sha256 = EVP_MD_fetch(NULL, "SHA2-256", NULL)))
+        goto err;
+
+    ok = 1;
+ err:
+    EVP_MD_free(sha256);
+    OSSL_PROVIDER_unload(provider);
+    return ok;
+}
+
 static int test_d2i_PrivateKey_ex(int testid)
 {
     int ok = 0;
@@ -1048,6 +1084,7 @@ int setup_tests(void)
     ADD_ALL_TESTS(test_PEM_read_bio_negative, OSSL_NELEM(keydata));
     ADD_TEST(test_rsa_pss_sign);
     ADD_TEST(test_evp_md_ctx_copy);
+    ADD_ALL_TESTS(test_provider_unload_effective, 2);
     return 1;
 }
 
diff --git a/test/evp_libctx_test.c b/test/evp_libctx_test.c
index 65f5f694bfdf..2448c35a149f 100644
--- a/test/evp_libctx_test.c
+++ b/test/evp_libctx_test.c
@@ -576,7 +576,7 @@ static int test_cipher_tdes_randkey(void)
           && TEST_int_ne(EVP_CIPHER_get_flags(tdes_cipher) & EVP_CIPH_RAND_KEY, 0)
           && TEST_ptr(ctx = EVP_CIPHER_CTX_new())
           && TEST_true(EVP_CipherInit_ex(ctx, tdes_cipher, NULL, NULL, NULL, 1))
-          && TEST_true(EVP_CIPHER_CTX_rand_key(ctx, key));
+          && TEST_int_gt(EVP_CIPHER_CTX_rand_key(ctx, key), 0);
 
     EVP_CIPHER_CTX_free(ctx);
     EVP_CIPHER_free(tdes_cipher);
diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c
index 87d3e826e33e..8faf0838d03f 100644
--- a/test/evp_pkey_provided_test.c
+++ b/test/evp_pkey_provided_test.c
@@ -396,10 +396,10 @@ static int test_fromdata_rsa(void)
         if (!TEST_ptr(key_ctx = EVP_PKEY_CTX_new_from_pkey(NULL, pk, "")))
             goto err;
 
-        if (!TEST_true(EVP_PKEY_check(key_ctx))
-            || !TEST_true(EVP_PKEY_public_check(key_ctx))
-            || !TEST_true(EVP_PKEY_private_check(key_ctx))
-            || !TEST_true(EVP_PKEY_pairwise_check(key_ctx)))
+        if (!TEST_int_gt(EVP_PKEY_check(key_ctx), 0)
+            || !TEST_int_gt(EVP_PKEY_public_check(key_ctx), 0)
+            || !TEST_int_gt(EVP_PKEY_private_check(key_ctx), 0)
+            || !TEST_int_gt(EVP_PKEY_pairwise_check(key_ctx), 0))
             goto err;
 
         /* EVP_PKEY_copy_parameters() should fail for RSA */
@@ -660,10 +660,10 @@ static int test_fromdata_dh_named_group(void)
         if (!TEST_ptr(key_ctx = EVP_PKEY_CTX_new_from_pkey(NULL, pk, "")))
             goto err;
 
-        if (!TEST_true(EVP_PKEY_check(key_ctx))
-            || !TEST_true(EVP_PKEY_public_check(key_ctx))
-            || !TEST_true(EVP_PKEY_private_check(key_ctx))
-            || !TEST_true(EVP_PKEY_pairwise_check(key_ctx)))
+        if (!TEST_int_gt(EVP_PKEY_check(key_ctx), 0)
+            || !TEST_int_gt(EVP_PKEY_public_check(key_ctx), 0)
+            || !TEST_int_gt(EVP_PKEY_private_check(key_ctx), 0)
+            || !TEST_int_gt(EVP_PKEY_pairwise_check(key_ctx), 0))
             goto err;
         EVP_PKEY_CTX_free(key_ctx);
         key_ctx = NULL;
@@ -841,10 +841,10 @@ static int test_fromdata_dh_fips186_4(void)
         if (!TEST_ptr(key_ctx = EVP_PKEY_CTX_new_from_pkey(NULL, pk, "")))
             goto err;
 
-        if (!TEST_true(EVP_PKEY_check(key_ctx))
-            || !TEST_true(EVP_PKEY_public_check(key_ctx))
-            || !TEST_true(EVP_PKEY_private_check(key_ctx))
-            || !TEST_true(EVP_PKEY_pairwise_check(key_ctx)))
+        if (!TEST_int_gt(EVP_PKEY_check(key_ctx), 0)
+            || !TEST_int_gt(EVP_PKEY_public_check(key_ctx), 0)
+            || !TEST_int_gt(EVP_PKEY_private_check(key_ctx), 0)
+            || !TEST_int_gt(EVP_PKEY_pairwise_check(key_ctx), 0))
             goto err;
         EVP_PKEY_CTX_free(key_ctx);
         key_ctx = NULL;
@@ -1096,7 +1096,7 @@ static int test_fromdata_ecx(int tst)
         if (!TEST_ptr(ctx2 = EVP_PKEY_CTX_new_from_pkey(NULL, pk, NULL)))
             goto err;
         if (tst <= 7) {
-            if (!TEST_true(EVP_PKEY_check(ctx2)))
+            if (!TEST_int_gt(EVP_PKEY_check(ctx2), 0))
                 goto err;
             if (!TEST_true(EVP_PKEY_get_octet_string_param(
                                pk, orig_fromdata_params[PRIV_KEY].key,
@@ -1113,9 +1113,9 @@ static int test_fromdata_ecx(int tst)
                 goto err;
         } else {
             /* The private key check should fail if there is only a public key */
-            if (!TEST_true(EVP_PKEY_public_check(ctx2))
-                || !TEST_false(EVP_PKEY_private_check(ctx2))
-                || !TEST_false(EVP_PKEY_check(ctx2)))
+            if (!TEST_int_gt(EVP_PKEY_public_check(ctx2), 0)
+                || !TEST_int_le(EVP_PKEY_private_check(ctx2), 0)
+                || !TEST_int_le(EVP_PKEY_check(ctx2), 0))
                 goto err;
         }
         EVP_PKEY_CTX_free(ctx2);
@@ -1606,10 +1606,10 @@ static int test_fromdata_dsa_fips186_4(void)
         if (!TEST_ptr(key_ctx = EVP_PKEY_CTX_new_from_pkey(NULL, pk, "")))
             goto err;
 
-        if (!TEST_true(EVP_PKEY_check(key_ctx))
-            || !TEST_true(EVP_PKEY_public_check(key_ctx))
-            || !TEST_true(EVP_PKEY_private_check(key_ctx))
-            || !TEST_true(EVP_PKEY_pairwise_check(key_ctx)))
+        if (!TEST_int_gt(EVP_PKEY_check(key_ctx), 0)
+            || !TEST_int_gt(EVP_PKEY_public_check(key_ctx), 0)
+            || !TEST_int_gt(EVP_PKEY_private_check(key_ctx), 0)
+            || !TEST_int_gt(EVP_PKEY_pairwise_check(key_ctx), 0))
             goto err;
         EVP_PKEY_CTX_free(key_ctx);
         key_ctx = NULL;
@@ -1660,10 +1660,10 @@ static int test_check_dsa(void)
     EVP_PKEY_CTX *ctx = NULL;
 
     if (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(NULL, "DSA", NULL))
-        || !TEST_false(EVP_PKEY_check(ctx))
-        || !TEST_false(EVP_PKEY_public_check(ctx))
-        || !TEST_false(EVP_PKEY_private_check(ctx))
-        || !TEST_false(EVP_PKEY_pairwise_check(ctx)))
+        || !TEST_int_le(EVP_PKEY_check(ctx), 0)
+        || !TEST_int_le(EVP_PKEY_public_check(ctx), 0)
+        || !TEST_int_le(EVP_PKEY_private_check(ctx), 0)
+        || !TEST_int_le(EVP_PKEY_pairwise_check(ctx), 0))
        goto err;
 
     ret = 1;
diff --git a/test/evp_test.c b/test/evp_test.c
index ef6fc0965a94..768329bd8280 100644
--- a/test/evp_test.c
+++ b/test/evp_test.c
@@ -755,8 +755,8 @@ static int cipher_test_enc(EVP_TEST *t, int enc,
     }
     if (expected->iv) {
         if (expected->aead) {
-            if (!EVP_CIPHER_CTX_ctrl(ctx_base, EVP_CTRL_AEAD_SET_IVLEN,
-                                     expected->iv_len, 0)) {
+            if (EVP_CIPHER_CTX_ctrl(ctx_base, EVP_CTRL_AEAD_SET_IVLEN,
+                                     expected->iv_len, 0) <= 0) {
                 t->err = "INVALID_IV_LENGTH";
                 goto err;
             }
@@ -779,8 +779,8 @@ static int cipher_test_enc(EVP_TEST *t, int enc,
             tag = expected->tag;
         }
         if (tag || expected->aead != EVP_CIPH_GCM_MODE) {
-            if (!EVP_CIPHER_CTX_ctrl(ctx_base, EVP_CTRL_AEAD_SET_TAG,
-                                     expected->tag_len, tag))
+            if (EVP_CIPHER_CTX_ctrl(ctx_base, EVP_CTRL_AEAD_SET_TAG,
+                                     expected->tag_len, tag) <= 0)
                 goto err;
         }
     }
@@ -788,7 +788,7 @@ static int cipher_test_enc(EVP_TEST *t, int enc,
     if (expected->rounds > 0) {
         int  rounds = (int)expected->rounds;
 
-        if (!EVP_CIPHER_CTX_ctrl(ctx_base, EVP_CTRL_SET_RC5_ROUNDS, rounds, NULL)) {
+        if (EVP_CIPHER_CTX_ctrl(ctx_base, EVP_CTRL_SET_RC5_ROUNDS, rounds, NULL) <= 0) {
             t->err = "INVALID_ROUNDS";
             goto err;
         }
@@ -801,7 +801,7 @@ static int cipher_test_enc(EVP_TEST *t, int enc,
     if (expected->key_bits > 0) {
         int bits = (int)expected->key_bits;
 
-        if (!EVP_CIPHER_CTX_ctrl(ctx_base, EVP_CTRL_SET_RC2_KEY_BITS, bits, NULL)) {
+        if (EVP_CIPHER_CTX_ctrl(ctx_base, EVP_CTRL_SET_RC2_KEY_BITS, bits, NULL) <= 0) {
             t->err = "INVALID KEY BITS";
             goto err;
         }
@@ -836,9 +836,9 @@ static int cipher_test_enc(EVP_TEST *t, int enc,
     ERR_pop_to_mark();
 
     if (expected->mac_key != NULL
-        && !EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_MAC_KEY,
+        && EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_MAC_KEY,
                                 (int)expected->mac_key_len,
-                                (void *)expected->mac_key)) {
+                                (void *)expected->mac_key) <= 0) {
         t->err = "SET_MAC_KEY_ERROR";
         goto err;
     }
@@ -914,8 +914,8 @@ static int cipher_test_enc(EVP_TEST *t, int enc,
         OPENSSL_free(tls_aad);
     } else if (!enc && (expected->aead == EVP_CIPH_OCB_MODE
                         || expected->tag_late)) {
-        if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG,
-                                 expected->tag_len, expected->tag)) {
+        if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG,
+                                 expected->tag_len, expected->tag) <= 0) {
             t->err = "TAG_SET_ERROR";
             goto err;
         }
@@ -977,8 +977,8 @@ static int cipher_test_enc(EVP_TEST *t, int enc,
             t->err = "TAG_LENGTH_INTERNAL_ERROR";
             goto err;
         }
-        if (!EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG,
-                                 expected->tag_len, rtag)) {
+        if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_GET_TAG,
+                                 expected->tag_len, rtag) <= 0) {
             t->err = "TAG_RETRIEVE_ERROR";
             goto err;
         }
diff --git a/test/exptest.c b/test/exptest.c
index 84d972afe3e9..c2acc40bcd4a 100644
--- a/test/exptest.c
+++ b/test/exptest.c
@@ -144,21 +144,21 @@ static int test_mod_exp(int round)
         || !TEST_ptr(m = BN_new()))
         goto err;
 
-    if (!TEST_true(RAND_bytes(&c, 1)))
+    if (!TEST_int_gt(RAND_bytes(&c, 1), 0))
         goto err;
     c = (c % BN_BITS) - BN_BITS2;
     if (!TEST_true(BN_rand(a, NUM_BITS + c, BN_RAND_TOP_ONE,
                            BN_RAND_BOTTOM_ANY)))
         goto err;
 
-    if (!TEST_true(RAND_bytes(&c, 1)))
+    if (!TEST_int_gt(RAND_bytes(&c, 1), 0))
         goto err;
     c = (c % BN_BITS) - BN_BITS2;
     if (!TEST_true(BN_rand(b, NUM_BITS + c, BN_RAND_TOP_ONE,
                            BN_RAND_BOTTOM_ANY)))
         goto err;
 
-    if (!TEST_true(RAND_bytes(&c, 1)))
+    if (!TEST_int_gt(RAND_bytes(&c, 1), 0))
         goto err;
     c = (c % BN_BITS) - BN_BITS2;
     if (!TEST_true(BN_rand(m, NUM_BITS + c, BN_RAND_TOP_ONE,
diff --git a/test/fake_rsaprov.c b/test/fake_rsaprov.c
index e4833a6a9968..d2503320f4cb 100644
--- a/test/fake_rsaprov.c
+++ b/test/fake_rsaprov.c
@@ -93,6 +93,41 @@ static const OSSL_PARAM *fake_rsa_keymgmt_imptypes(int selection)
     return fake_rsa_import_key_types;
 }
 
+static void *fake_rsa_gen_init(void *provctx, int selection,
+                               const OSSL_PARAM params[])
+{
+    unsigned char *gctx = NULL;
+
+    if (!TEST_ptr(gctx = OPENSSL_malloc(1)))
+        return NULL;
+
+    *gctx = 1;
+
+    return gctx;
+}
+
+static void *fake_rsa_gen(void *genctx, OSSL_CALLBACK *osslcb, void *cbarg)
+{
+    unsigned char *gctx = genctx;
+    static const unsigned char inited[] = { 1 };
+    unsigned char *keydata;
+
+    if (!TEST_ptr(gctx)
+        || !TEST_mem_eq(gctx, sizeof(*gctx), inited, sizeof(inited)))
+        return NULL;
+
+    if (!TEST_ptr(keydata = fake_rsa_keymgmt_new(NULL)))
+        return NULL;
+
+    *keydata = 2;
+    return keydata;
+}
+
+static void fake_rsa_gen_cleanup(void *genctx)
+{
+   OPENSSL_free(genctx);
+}
+
 static const OSSL_DISPATCH fake_rsa_keymgmt_funcs[] = {
     { OSSL_FUNC_KEYMGMT_NEW, (void (*)(void))fake_rsa_keymgmt_new },
     { OSSL_FUNC_KEYMGMT_FREE, (void (*)(void))fake_rsa_keymgmt_free} ,
@@ -102,6 +137,9 @@ static const OSSL_DISPATCH fake_rsa_keymgmt_funcs[] = {
     { OSSL_FUNC_KEYMGMT_IMPORT, (void (*)(void))fake_rsa_keymgmt_import },
     { OSSL_FUNC_KEYMGMT_IMPORT_TYPES,
         (void (*)(void))fake_rsa_keymgmt_imptypes },
+    { OSSL_FUNC_KEYMGMT_GEN_INIT, (void (*)(void))fake_rsa_gen_init },
+    { OSSL_FUNC_KEYMGMT_GEN, (void (*)(void))fake_rsa_gen },
+    { OSSL_FUNC_KEYMGMT_GEN_CLEANUP, (void (*)(void))fake_rsa_gen_cleanup },
     { 0, NULL }
 };
 
diff --git a/test/localetest.c b/test/localetest.c
index ea80039b3b88..9df90ed901ea 100644
--- a/test/localetest.c
+++ b/test/localetest.c
@@ -1,18 +1,25 @@
+/*
+ * Copyright 2022 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the Apache License 2.0 (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
 
+#include "../e_os.h"
 #include <stdio.h>
 #include <string.h>
+#include <stdlib.h>
 #include <openssl/x509.h>
 #include "testutil.h"
 #include "testutil/output.h"
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <locale.h>
-#ifdef OPENSSL_SYS_WINDOWS
-# define strcasecmp _stricmp
-#else
-# include <strings.h>
-#endif
+#ifndef OPENSSL_NO_LOCALE
+# include <locale.h>
+# ifdef OPENSSL_SYS_MACOSX
+#  include <xlocale.h>
+# endif
 
 int setup_tests(void)
 {
@@ -118,7 +125,12 @@ int setup_tests(void)
     X509_free(cert);
     return 1;
 }
-
+#else
+int setup_tests(void)
+{
+    return TEST_skip("Locale support not available");
+}
+#endif /* OPENSSL_NO_LOCALE */
 void cleanup_tests(void)
 {
 }
diff --git a/test/provider_pkey_test.c b/test/provider_pkey_test.c
index d360c0cf3047..dc59326182ed 100644
--- a/test/provider_pkey_test.c
+++ b/test/provider_pkey_test.c
@@ -115,6 +115,66 @@ static int test_pkey_sig(void)
     return ret;
 }
 
+static int test_alternative_keygen_init(void)
+{
+    EVP_PKEY_CTX *ctx = NULL;
+    OSSL_PROVIDER *deflt = NULL;
+    OSSL_PROVIDER *fake_rsa = NULL;
+    const OSSL_PROVIDER *provider;
+    const char *provname;
+    int ret = 0;
+
+    if (!TEST_ptr(deflt = OSSL_PROVIDER_load(libctx, "default")))
+        goto end;
+
+    /* first try without the fake RSA provider loaded */
+    if (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(libctx, "RSA", NULL)))
+        goto end;
+
+    if (!TEST_int_gt(EVP_PKEY_keygen_init(ctx), 0))
+        goto end;
+
+    if (!TEST_ptr(provider = EVP_PKEY_CTX_get0_provider(ctx)))
+        goto end;
+
+    if (!TEST_ptr(provname = OSSL_PROVIDER_get0_name(provider)))
+        goto end;
+
+    if (!TEST_str_eq(provname, "default"))
+        goto end;
+
+    EVP_PKEY_CTX_free(ctx);
+    ctx = NULL;
+
+    /* now load fake RSA and try again */
+    if (!TEST_ptr(fake_rsa = fake_rsa_start(libctx)))
+        return 0;
+
+    if (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(libctx, "RSA",
+                                                   "?provider=fake-rsa")))
+        goto end;
+
+    if (!TEST_int_gt(EVP_PKEY_keygen_init(ctx), 0))
+        goto end;
+
+    if (!TEST_ptr(provider = EVP_PKEY_CTX_get0_provider(ctx)))
+        goto end;
+
+    if (!TEST_ptr(provname = OSSL_PROVIDER_get0_name(provider)))
+        goto end;
+
+    if (!TEST_str_eq(provname, "fake-rsa"))
+        goto end;
+
+    ret = 1;
+
+end:
+    fake_rsa_finish(fake_rsa);
+    OSSL_PROVIDER_unload(deflt);
+    EVP_PKEY_CTX_free(ctx);
+    return ret;
+}
+
 int setup_tests(void)
 {
     libctx = OSSL_LIB_CTX_new();
@@ -122,6 +182,7 @@ int setup_tests(void)
         return 0;
 
     ADD_TEST(test_pkey_sig);
+    ADD_TEST(test_alternative_keygen_init);
 
     return 1;
 }
diff --git a/test/ssl-tests/12-ct.cnf.in b/test/ssl-tests/12-ct.cnf.in
index bf34e4b5e769..ddafd3fc4cda 100644
--- a/test/ssl-tests/12-ct.cnf.in
+++ b/test/ssl-tests/12-ct.cnf.in
@@ -1,5 +1,5 @@
 # -*- mode: perl; -*-
-# Copyright 2016-2020 The OpenSSL Project Authors. All Rights Reserved.
+# Copyright 2016-2022 The OpenSSL Project Authors. All Rights Reserved.
 #
 # Licensed under the Apache License 2.0 (the "License").  You may not use
 # this file except in compliance with the License.  You can obtain a copy
@@ -18,7 +18,8 @@ package ssltests;
 our @tests = (
     {
         name => "ct-permissive-without-scts",
-        server => { },
+        server => {
+        },
         client => {
             extra => {
                 "CTValidation" => "Permissive",
@@ -46,7 +47,8 @@ our @tests = (
     },
     {
         name => "ct-strict-without-scts",
-        server => { },
+        server => {
+        },
         client => {
             extra => {
                 "CTValidation" => "Strict",
diff --git a/test/ssl-tests/17-renegotiate.cnf b/test/ssl-tests/17-renegotiate.cnf
index 099d6d6f196b..2ebc961420b7 100644
--- a/test/ssl-tests/17-renegotiate.cnf
+++ b/test/ssl-tests/17-renegotiate.cnf
@@ -1,6 +1,6 @@
 # Generated with generate_ssl_tests.pl
 
-num_tests = 17
+num_tests = 18
 
 test-0 = 0-renegotiate-client-no-resume
 test-1 = 1-renegotiate-client-resume
@@ -8,17 +8,18 @@ test-2 = 2-renegotiate-server-no-resume
 test-3 = 3-renegotiate-server-resume
 test-4 = 4-renegotiate-client-auth-require
 test-5 = 5-renegotiate-client-auth-once
-test-6 = 6-renegotiate-aead-to-non-aead
-test-7 = 7-renegotiate-non-aead-to-aead
-test-8 = 8-renegotiate-non-aead-to-non-aead
-test-9 = 9-renegotiate-aead-to-aead
-test-10 = 10-no-renegotiation-server-by-client
-test-11 = 11-no-renegotiation-server-by-server
-test-12 = 12-no-renegotiation-client-by-server
-test-13 = 13-no-renegotiation-client-by-client
-test-14 = 14-no-extms-on-renegotiation
-test-15 = 15-allow-client-renegotiation
-test-16 = 16-no-client-renegotiation
+test-6 = 6-renegotiate-client-legacy-connect
+test-7 = 7-renegotiate-aead-to-non-aead
+test-8 = 8-renegotiate-non-aead-to-aead
+test-9 = 9-renegotiate-non-aead-to-non-aead
+test-10 = 10-renegotiate-aead-to-aead
+test-11 = 11-no-renegotiation-server-by-client
+test-12 = 12-no-renegotiation-server-by-server
+test-13 = 13-no-renegotiation-client-by-server
+test-14 = 14-no-renegotiation-client-by-client
+test-15 = 15-no-extms-on-renegotiation
+test-16 = 16-allow-client-renegotiation
+test-17 = 17-no-client-renegotiation
 # ===========================================================
 
 [0-renegotiate-client-no-resume]
@@ -195,22 +196,22 @@ ResumptionExpected = No
 
 # ===========================================================
 
-[6-renegotiate-aead-to-non-aead]
-ssl_conf = 6-renegotiate-aead-to-non-aead-ssl
+[6-renegotiate-client-legacy-connect]
+ssl_conf = 6-renegotiate-client-legacy-connect-ssl
 
-[6-renegotiate-aead-to-non-aead-ssl]
-server = 6-renegotiate-aead-to-non-aead-server
-client = 6-renegotiate-aead-to-non-aead-client
+[6-renegotiate-client-legacy-connect-ssl]
+server = 6-renegotiate-client-legacy-connect-server
+client = 6-renegotiate-client-legacy-connect-client
 
-[6-renegotiate-aead-to-non-aead-server]
+[6-renegotiate-client-legacy-connect-server]
 Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
 CipherString = DEFAULT
-Options = NoResumptionOnRenegotiation
+MaxProtocol = TLSv1.2
 PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
 
-[6-renegotiate-aead-to-non-aead-client]
-CipherString = AES128-GCM-SHA256
-MaxProtocol = TLSv1.2
+[6-renegotiate-client-legacy-connect-client]
+CipherString = DEFAULT
+Options = UnsafeLegacyServerConnect
 VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
 VerifyMode = Peer
 
@@ -218,30 +219,26 @@ VerifyMode = Peer
 ExpectedResult = Success
 HandshakeMode = RenegotiateClient
 Method = TLS
-ResumptionExpected = No
-client = 6-renegotiate-aead-to-non-aead-client-extra
-
-[6-renegotiate-aead-to-non-aead-client-extra]
-RenegotiateCiphers = AES128-SHA
+ResumptionExpected = Yes
 
 
 # ===========================================================
 
-[7-renegotiate-non-aead-to-aead]
-ssl_conf = 7-renegotiate-non-aead-to-aead-ssl
+[7-renegotiate-aead-to-non-aead]
+ssl_conf = 7-renegotiate-aead-to-non-aead-ssl
 
-[7-renegotiate-non-aead-to-aead-ssl]
-server = 7-renegotiate-non-aead-to-aead-server
-client = 7-renegotiate-non-aead-to-aead-client
+[7-renegotiate-aead-to-non-aead-ssl]
+server = 7-renegotiate-aead-to-non-aead-server
+client = 7-renegotiate-aead-to-non-aead-client
 
-[7-renegotiate-non-aead-to-aead-server]
+[7-renegotiate-aead-to-non-aead-server]
 Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
 CipherString = DEFAULT
 Options = NoResumptionOnRenegotiation
 PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
 
-[7-renegotiate-non-aead-to-aead-client]
-CipherString = AES128-SHA
+[7-renegotiate-aead-to-non-aead-client]
+CipherString = AES128-GCM-SHA256
 MaxProtocol = TLSv1.2
 VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
 VerifyMode = Peer
@@ -251,28 +248,28 @@ ExpectedResult = Success
 HandshakeMode = RenegotiateClient
 Method = TLS
 ResumptionExpected = No
-client = 7-renegotiate-non-aead-to-aead-client-extra
+client = 7-renegotiate-aead-to-non-aead-client-extra
 
-[7-renegotiate-non-aead-to-aead-client-extra]
-RenegotiateCiphers = AES128-GCM-SHA256
+[7-renegotiate-aead-to-non-aead-client-extra]
+RenegotiateCiphers = AES128-SHA
 
 
 # ===========================================================
 
-[8-renegotiate-non-aead-to-non-aead]
-ssl_conf = 8-renegotiate-non-aead-to-non-aead-ssl
+[8-renegotiate-non-aead-to-aead]
+ssl_conf = 8-renegotiate-non-aead-to-aead-ssl
 
-[8-renegotiate-non-aead-to-non-aead-ssl]
-server = 8-renegotiate-non-aead-to-non-aead-server
-client = 8-renegotiate-non-aead-to-non-aead-client
+[8-renegotiate-non-aead-to-aead-ssl]
+server = 8-renegotiate-non-aead-to-aead-server
+client = 8-renegotiate-non-aead-to-aead-client
 
-[8-renegotiate-non-aead-to-non-aead-server]
+[8-renegotiate-non-aead-to-aead-server]
 Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
 CipherString = DEFAULT
 Options = NoResumptionOnRenegotiation
 PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
 
-[8-renegotiate-non-aead-to-non-aead-client]
+[8-renegotiate-non-aead-to-aead-client]
 CipherString = AES128-SHA
 MaxProtocol = TLSv1.2
 VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
@@ -283,29 +280,29 @@ ExpectedResult = Success
 HandshakeMode = RenegotiateClient
 Method = TLS
 ResumptionExpected = No
-client = 8-renegotiate-non-aead-to-non-aead-client-extra
+client = 8-renegotiate-non-aead-to-aead-client-extra
 
-[8-renegotiate-non-aead-to-non-aead-client-extra]
-RenegotiateCiphers = AES256-SHA
+[8-renegotiate-non-aead-to-aead-client-extra]
+RenegotiateCiphers = AES128-GCM-SHA256
 
 
 # ===========================================================
 
-[9-renegotiate-aead-to-aead]
-ssl_conf = 9-renegotiate-aead-to-aead-ssl
+[9-renegotiate-non-aead-to-non-aead]
+ssl_conf = 9-renegotiate-non-aead-to-non-aead-ssl
 
-[9-renegotiate-aead-to-aead-ssl]
-server = 9-renegotiate-aead-to-aead-server
-client = 9-renegotiate-aead-to-aead-client
+[9-renegotiate-non-aead-to-non-aead-ssl]
+server = 9-renegotiate-non-aead-to-non-aead-server
+client = 9-renegotiate-non-aead-to-non-aead-client
 
-[9-renegotiate-aead-to-aead-server]
+[9-renegotiate-non-aead-to-non-aead-server]
 Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
 CipherString = DEFAULT
 Options = NoResumptionOnRenegotiation
 PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
 
-[9-renegotiate-aead-to-aead-client]
-CipherString = AES128-GCM-SHA256
+[9-renegotiate-non-aead-to-non-aead-client]
+CipherString = AES128-SHA
 MaxProtocol = TLSv1.2
 VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
 VerifyMode = Peer
@@ -315,34 +312,66 @@ ExpectedResult = Success
 HandshakeMode = RenegotiateClient
 Method = TLS
 ResumptionExpected = No
-client = 9-renegotiate-aead-to-aead-client-extra
+client = 9-renegotiate-non-aead-to-non-aead-client-extra
 
-[9-renegotiate-aead-to-aead-client-extra]
+[9-renegotiate-non-aead-to-non-aead-client-extra]
+RenegotiateCiphers = AES256-SHA
+
+
+# ===========================================================
+
+[10-renegotiate-aead-to-aead]
+ssl_conf = 10-renegotiate-aead-to-aead-ssl
+
+[10-renegotiate-aead-to-aead-ssl]
+server = 10-renegotiate-aead-to-aead-server
+client = 10-renegotiate-aead-to-aead-client
+
+[10-renegotiate-aead-to-aead-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+Options = NoResumptionOnRenegotiation
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+
+[10-renegotiate-aead-to-aead-client]
+CipherString = AES128-GCM-SHA256
+MaxProtocol = TLSv1.2
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
+VerifyMode = Peer
+
+[test-10]
+ExpectedResult = Success
+HandshakeMode = RenegotiateClient
+Method = TLS
+ResumptionExpected = No
+client = 10-renegotiate-aead-to-aead-client-extra
+
+[10-renegotiate-aead-to-aead-client-extra]
 RenegotiateCiphers = AES256-GCM-SHA384
 
 
 # ===========================================================
 
-[10-no-renegotiation-server-by-client]
-ssl_conf = 10-no-renegotiation-server-by-client-ssl
+[11-no-renegotiation-server-by-client]
+ssl_conf = 11-no-renegotiation-server-by-client-ssl
 
-[10-no-renegotiation-server-by-client-ssl]
-server = 10-no-renegotiation-server-by-client-server
-client = 10-no-renegotiation-server-by-client-client
+[11-no-renegotiation-server-by-client-ssl]
+server = 11-no-renegotiation-server-by-client-server
+client = 11-no-renegotiation-server-by-client-client
 
-[10-no-renegotiation-server-by-client-server]
+[11-no-renegotiation-server-by-client-server]
 Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
 CipherString = DEFAULT
 MaxProtocol = TLSv1.2
 Options = NoRenegotiation
 PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
 
-[10-no-renegotiation-server-by-client-client]
+[11-no-renegotiation-server-by-client-client]
 CipherString = DEFAULT
 VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
 VerifyMode = Peer
 
-[test-10]
+[test-11]
 ExpectedResult = ClientFail
 HandshakeMode = RenegotiateClient
 Method = TLS
@@ -351,53 +380,25 @@ ResumptionExpected = No
 
 # ===========================================================
 
-[11-no-renegotiation-server-by-server]
-ssl_conf = 11-no-renegotiation-server-by-server-ssl
+[12-no-renegotiation-server-by-server]
+ssl_conf = 12-no-renegotiation-server-by-server-ssl
 
-[11-no-renegotiation-server-by-server-ssl]
-server = 11-no-renegotiation-server-by-server-server
-client = 11-no-renegotiation-server-by-server-client
+[12-no-renegotiation-server-by-server-ssl]
+server = 12-no-renegotiation-server-by-server-server
+client = 12-no-renegotiation-server-by-server-client
 
-[11-no-renegotiation-server-by-server-server]
+[12-no-renegotiation-server-by-server-server]
 Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
 CipherString = DEFAULT
 MaxProtocol = TLSv1.2
 Options = NoRenegotiation
 PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
 
-[11-no-renegotiation-server-by-server-client]
+[12-no-renegotiation-server-by-server-client]
 CipherString = DEFAULT
 VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
 VerifyMode = Peer
 
-[test-11]
-ExpectedResult = ServerFail
-HandshakeMode = RenegotiateServer
-Method = TLS
-ResumptionExpected = No
-
-
-# ===========================================================
-
-[12-no-renegotiation-client-by-server]
-ssl_conf = 12-no-renegotiation-client-by-server-ssl
-
-[12-no-renegotiation-client-by-server-ssl]
-server = 12-no-renegotiation-client-by-server-server
-client = 12-no-renegotiation-client-by-server-client
-
-[12-no-renegotiation-client-by-server-server]
-Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
-CipherString = DEFAULT
-MaxProtocol = TLSv1.2
-PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
-
-[12-no-renegotiation-client-by-server-client]
-CipherString = DEFAULT
-Options = NoRenegotiation
-VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
-VerifyMode = Peer
-
 [test-12]
 ExpectedResult = ServerFail
 HandshakeMode = RenegotiateServer
@@ -407,26 +408,54 @@ ResumptionExpected = No
 
 # ===========================================================
 
-[13-no-renegotiation-client-by-client]
-ssl_conf = 13-no-renegotiation-client-by-client-ssl
+[13-no-renegotiation-client-by-server]
+ssl_conf = 13-no-renegotiation-client-by-server-ssl
 
-[13-no-renegotiation-client-by-client-ssl]
-server = 13-no-renegotiation-client-by-client-server
-client = 13-no-renegotiation-client-by-client-client
+[13-no-renegotiation-client-by-server-ssl]
+server = 13-no-renegotiation-client-by-server-server
+client = 13-no-renegotiation-client-by-server-client
 
-[13-no-renegotiation-client-by-client-server]
+[13-no-renegotiation-client-by-server-server]
 Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
 CipherString = DEFAULT
 MaxProtocol = TLSv1.2
 PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
 
-[13-no-renegotiation-client-by-client-client]
+[13-no-renegotiation-client-by-server-client]
 CipherString = DEFAULT
 Options = NoRenegotiation
 VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
 VerifyMode = Peer
 
 [test-13]
+ExpectedResult = ServerFail
+HandshakeMode = RenegotiateServer
+Method = TLS
+ResumptionExpected = No
+
+
+# ===========================================================
+
+[14-no-renegotiation-client-by-client]
+ssl_conf = 14-no-renegotiation-client-by-client-ssl
+
+[14-no-renegotiation-client-by-client-ssl]
+server = 14-no-renegotiation-client-by-client-server
+client = 14-no-renegotiation-client-by-client-client
+
+[14-no-renegotiation-client-by-client-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+MaxProtocol = TLSv1.2
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+
+[14-no-renegotiation-client-by-client-client]
+CipherString = DEFAULT
+Options = NoRenegotiation
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
+VerifyMode = Peer
+
+[test-14]
 ExpectedResult = ClientFail
 HandshakeMode = RenegotiateClient
 Method = TLS
@@ -435,58 +464,58 @@ ResumptionExpected = No
 
 # ===========================================================
 
-[14-no-extms-on-renegotiation]
-ssl_conf = 14-no-extms-on-renegotiation-ssl
+[15-no-extms-on-renegotiation]
+ssl_conf = 15-no-extms-on-renegotiation-ssl
 
-[14-no-extms-on-renegotiation-ssl]
-server = 14-no-extms-on-renegotiation-server
-client = 14-no-extms-on-renegotiation-client
+[15-no-extms-on-renegotiation-ssl]
+server = 15-no-extms-on-renegotiation-server
+client = 15-no-extms-on-renegotiation-client
 
-[14-no-extms-on-renegotiation-server]
+[15-no-extms-on-renegotiation-server]
 Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
 CipherString = DEFAULT
 MaxProtocol = TLSv1.2
 PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
 
-[14-no-extms-on-renegotiation-client]
-CipherString = DEFAULT
-MaxProtocol = TLSv1.2
-VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
-VerifyMode = Peer
-
-[test-14]
-ExpectedResult = ServerFail
-HandshakeMode = RenegotiateClient
-Method = TLS
-ResumptionExpected = No
-client = 14-no-extms-on-renegotiation-client-extra
-
-[14-no-extms-on-renegotiation-client-extra]
-RenegotiateNoExtms = Yes
-
-
-# ===========================================================
-
-[15-allow-client-renegotiation]
-ssl_conf = 15-allow-client-renegotiation-ssl
-
-[15-allow-client-renegotiation-ssl]
-server = 15-allow-client-renegotiation-server
-client = 15-allow-client-renegotiation-client
-
-[15-allow-client-renegotiation-server]
-Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
-CipherString = DEFAULT
-MaxProtocol = TLSv1.2
-PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
-
-[15-allow-client-renegotiation-client]
+[15-no-extms-on-renegotiation-client]
 CipherString = DEFAULT
 MaxProtocol = TLSv1.2
 VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
 VerifyMode = Peer
 
 [test-15]
+ExpectedResult = ServerFail
+HandshakeMode = RenegotiateClient
+Method = TLS
+ResumptionExpected = No
+client = 15-no-extms-on-renegotiation-client-extra
+
+[15-no-extms-on-renegotiation-client-extra]
+RenegotiateNoExtms = Yes
+
+
+# ===========================================================
+
+[16-allow-client-renegotiation]
+ssl_conf = 16-allow-client-renegotiation-ssl
+
+[16-allow-client-renegotiation-ssl]
+server = 16-allow-client-renegotiation-server
+client = 16-allow-client-renegotiation-client
+
+[16-allow-client-renegotiation-server]
+Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
+CipherString = DEFAULT
+MaxProtocol = TLSv1.2
+PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
+
+[16-allow-client-renegotiation-client]
+CipherString = DEFAULT
+MaxProtocol = TLSv1.2
+VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
+VerifyMode = Peer
+
+[test-16]
 ExpectedResult = Success
 HandshakeMode = RenegotiateClient
 Method = TLS
@@ -495,27 +524,27 @@ ResumptionExpected = Yes
 
 # ===========================================================
 
-[16-no-client-renegotiation]
-ssl_conf = 16-no-client-renegotiation-ssl
+[17-no-client-renegotiation]
+ssl_conf = 17-no-client-renegotiation-ssl
 
-[16-no-client-renegotiation-ssl]
-server = 16-no-client-renegotiation-server
-client = 16-no-client-renegotiation-client
+[17-no-client-renegotiation-ssl]
+server = 17-no-client-renegotiation-server
+client = 17-no-client-renegotiation-client
 
-[16-no-client-renegotiation-server]
+[17-no-client-renegotiation-server]
 Certificate = ${ENV::TEST_CERTS_DIR}/servercert.pem
 CipherString = DEFAULT
 MaxProtocol = TLSv1.2
 Options = -ClientRenegotiation
 PrivateKey = ${ENV::TEST_CERTS_DIR}/serverkey.pem
 
-[16-no-client-renegotiation-client]
+[17-no-client-renegotiation-client]
 CipherString = DEFAULT
 MaxProtocol = TLSv1.2
 VerifyCAFile = ${ENV::TEST_CERTS_DIR}/rootcert.pem
 VerifyMode = Peer
 
-[test-16]
+[test-17]
 ExpectedResult = ClientFail
 ExpectedServerAlert = NoRenegotiation
 HandshakeMode = RenegotiateClient
diff --git a/test/ssl-tests/17-renegotiate.cnf.in b/test/ssl-tests/17-renegotiate.cnf.in
index 47e9d531ce35..73f967ff646c 100644
--- a/test/ssl-tests/17-renegotiate.cnf.in
+++ b/test/ssl-tests/17-renegotiate.cnf.in
@@ -107,7 +107,24 @@ our @tests = (
             "ResumptionExpected" => "No",
             "ExpectedResult" => "Success"
         }
-    }
+    },
+    {
+#       Just test that UnsafeLegacyServerConnect option
+#       exists, it won't have any real effect here
+        name => "renegotiate-client-legacy-connect",
+        server => {
+            "MaxProtocol" => "TLSv1.2"
+        },
+        client => {
+            "Options" => "UnsafeLegacyServerConnect",
+        },
+        test => {
+            "Method" => "TLS",
+            "HandshakeMode" => "RenegotiateClient",
+            "ResumptionExpected" => "Yes",
+            "ExpectedResult" => "Success"
+        }
+    },
 );
 our @tests_tls1_2 = (
     {
diff --git a/test/ssl_old_test.c b/test/ssl_old_test.c
index 5fb54a3a2eb1..94f0aa7c675d 100644
--- a/test/ssl_old_test.c
+++ b/test/ssl_old_test.c
@@ -666,9 +666,9 @@ static void sv_usage(void)
 #endif
     fprintf(stderr, " -CApath arg   - PEM format directory of CA's\n");
     fprintf(stderr, " -CAfile arg   - PEM format file of CA's\n");
-    fprintf(stderr, " -cert arg     - Server certificate file\n");
+    fprintf(stderr, " -s_cert arg   - Server certificate file\n");
     fprintf(stderr,
-            " -key arg      - Server key file (default: same as -cert)\n");
+            " -s_key arg    - Server key file (default: same as -cert)\n");
     fprintf(stderr, " -c_cert arg   - Client certificate file\n");
     fprintf(stderr,
             " -c_key arg    - Client key file (default: same as -c_cert)\n");
@@ -1296,7 +1296,7 @@ int main(int argc, char *argv[])
     }
 
     if (print_time) {
-        if (bio_type != BIO_PAIR) {
+        if (bio_type == BIO_MEM) {
             fprintf(stderr, "Using BIO pair (-bio_pair)\n");
             bio_type = BIO_PAIR;
         }
@@ -2024,7 +2024,7 @@ int doit_localhost(SSL *s_ssl, SSL *c_ssl, int family, long count,
                 r = BIO_write(c_ssl_bio, cbuf, i);
                 if (r < 0) {
                     if (!BIO_should_retry(c_ssl_bio)) {
-                        fprintf(stderr, "ERROR in CLIENT\n");
+                        fprintf(stderr, "ERROR in CLIENT (write)\n");
                         err_in_client = 1;
                         goto err;
                     }
@@ -2050,7 +2050,7 @@ int doit_localhost(SSL *s_ssl, SSL *c_ssl, int family, long count,
                 r = BIO_read(c_ssl_bio, cbuf, sizeof(cbuf));
                 if (r < 0) {
                     if (!BIO_should_retry(c_ssl_bio)) {
-                        fprintf(stderr, "ERROR in CLIENT\n");
+                        fprintf(stderr, "ERROR in CLIENT (read)\n");
                         err_in_client = 1;
                         goto err;
                     }
@@ -2103,7 +2103,7 @@ int doit_localhost(SSL *s_ssl, SSL *c_ssl, int family, long count,
                 r = BIO_write(s_ssl_bio, sbuf, i);
                 if (r < 0) {
                     if (!BIO_should_retry(s_ssl_bio)) {
-                        fprintf(stderr, "ERROR in SERVER\n");
+                        fprintf(stderr, "ERROR in SERVER (write)\n");
                         err_in_server = 1;
                         goto err;
                     }
@@ -2124,7 +2124,7 @@ int doit_localhost(SSL *s_ssl, SSL *c_ssl, int family, long count,
                 r = BIO_read(s_ssl_bio, sbuf, sizeof(sbuf));
                 if (r < 0) {
                     if (!BIO_should_retry(s_ssl_bio)) {
-                        fprintf(stderr, "ERROR in SERVER\n");
+                        fprintf(stderr, "ERROR in SERVER (read)\n");
                         err_in_server = 1;
                         goto err;
                     }
@@ -2144,8 +2144,25 @@ int doit_localhost(SSL *s_ssl, SSL *c_ssl, int family, long count,
     }
     while (cw_num > 0 || cr_num > 0 || sw_num > 0 || sr_num > 0);
 
-    if (verbose)
+    if (verbose) {
         print_details(c_ssl, "DONE via TCP connect: ");
+
+        if (BIO_get_ktls_send(SSL_get_wbio(s_ssl))
+                && BIO_get_ktls_recv(SSL_get_rbio(s_ssl)))
+            BIO_printf(bio_stdout, "Server using Kernel TLS in both directions\n");
+        else if (BIO_get_ktls_send(SSL_get_wbio(s_ssl)))
+            BIO_printf(bio_stdout, "Server using Kernel TLS for sending\n");
+        else if (BIO_get_ktls_recv(SSL_get_rbio(s_ssl)))
+            BIO_printf(bio_stdout, "Server using Kernel TLS for receiving\n");
+
+        if (BIO_get_ktls_send(SSL_get_wbio(c_ssl))
+                && BIO_get_ktls_recv(SSL_get_rbio(c_ssl)))
+            BIO_printf(bio_stdout, "Client using Kernel TLS in both directions\n");
+        else if (BIO_get_ktls_send(SSL_get_wbio(c_ssl)))
+            BIO_printf(bio_stdout, "Client using Kernel TLS for sending\n");
+        else if (BIO_get_ktls_recv(SSL_get_rbio(c_ssl)))
+            BIO_printf(bio_stdout, "Client using Kernel TLS for receiving\n");
+    }
 # ifndef OPENSSL_NO_NEXTPROTONEG
     if (verify_npn(c_ssl, s_ssl) < 0)
         goto end;
diff --git a/test/threadstest.c b/test/threadstest.c
index 5080b0a8097e..289565c14b5d 100644
--- a/test/threadstest.c
+++ b/test/threadstest.c
@@ -22,10 +22,17 @@
 #include "testutil.h"
 #include "threadstest.h"
 
+/* Limit the maximum number of threads */
+#define MAXIMUM_THREADS     10
+
+/* Limit the maximum number of providers loaded into a library context */
+#define MAXIMUM_PROVIDERS   4
+
 static int do_fips = 0;
 static char *privkey;
 static char *config_file = NULL;
 static int multidefault_run = 0;
+static const char *default_provider[] = { "default", NULL };
 
 static int test_lock(void)
 {
@@ -209,6 +216,94 @@ static int test_atomic(void)
 
 static OSSL_LIB_CTX *multi_libctx = NULL;
 static int multi_success;
+static OSSL_PROVIDER *multi_provider[MAXIMUM_PROVIDERS + 1];
+static size_t multi_num_threads;
+static thread_t multi_threads[MAXIMUM_THREADS];
+
+static void multi_intialise(void)
+{
+    multi_success = 1;
+    multi_libctx = NULL;
+    multi_num_threads = 0;
+    memset(multi_threads, 0, sizeof(multi_threads));
+    memset(multi_provider, 0, sizeof(multi_provider));
+}
+
+static void thead_teardown_libctx(void)
+{
+    OSSL_PROVIDER **p;
+
+    for (p = multi_provider; *p != NULL; p++)
+        OSSL_PROVIDER_unload(*p);
+    OSSL_LIB_CTX_free(multi_libctx);
+    multi_intialise();
+}
+
+static int thread_setup_libctx(int libctx, const char *providers[])
+{
+    size_t n;
+
+    if (libctx && !TEST_true(test_get_libctx(&multi_libctx, NULL, config_file,
+                                             NULL, NULL)))
+        return 0;
+
+    if (providers != NULL)
+        for (n = 0; providers[n] != NULL; n++)
+            if (!TEST_size_t_lt(n, MAXIMUM_PROVIDERS)
+                || !TEST_ptr(multi_provider[n] = OSSL_PROVIDER_load(multi_libctx,
+                                                                    providers[n]))) {
+                thead_teardown_libctx();
+                return 0;
+            }
+    return 1;
+}
+
+static int teardown_threads(void)
+{
+    size_t i;
+
+    for (i = 0; i < multi_num_threads; i++)
+        if (!TEST_true(wait_for_thread(multi_threads[i])))
+            return 0;
+    return 1;
+}
+
+static int start_threads(size_t n, void (*thread_func)(void))
+{
+    size_t i;
+
+    if (!TEST_size_t_le(multi_num_threads + n, MAXIMUM_THREADS))
+        return 0;
+
+    for (i = 0 ; i < n; i++)
+        if (!TEST_true(run_thread(multi_threads + multi_num_threads++, thread_func)))
+            return 0;
+    return 1;
+}
+
+/* Template multi-threaded test function */
+static int thread_run_test(void (*main_func)(void),
+                           size_t num_threads, void (*thread_func)(void),
+                           int libctx, const char *providers[])
+{
+    int testresult = 0;
+
+    multi_intialise();
+    if (!thread_setup_libctx(libctx, providers)
+            || !start_threads(num_threads, thread_func))
+        goto err;
+
+    if (main_func != NULL)
+        main_func();
+
+    if (!teardown_threads()
+            || !TEST_true(multi_success))
+        goto err;
+    testresult = 1;
+ err:
+    thead_teardown_libctx();
+    return testresult;
+}
 
 static void thread_general_worker(void)
 {
@@ -555,6 +650,19 @@ static int test_multi_load(void)
     return res && multi_success;
 }
 
+static void test_lib_ctx_load_config_worker(void)
+{
+    if (!TEST_int_eq(OSSL_LIB_CTX_load_config(multi_libctx, config_file), 1))
+        multi_success = 0;
+}
+
+static int test_lib_ctx_load_config(void)
+{
+    return thread_run_test(&test_lib_ctx_load_config_worker,
+                           MAXIMUM_THREADS, &test_lib_ctx_load_config_worker,
+                           1, default_provider);
+}
+
 typedef enum OPTION_choice {
     OPT_ERR = -1,
     OPT_EOF = 0,
@@ -610,6 +718,7 @@ int setup_tests(void)
     ADD_TEST(test_atomic);
     ADD_TEST(test_multi_load);
     ADD_ALL_TESTS(test_multi, 6);
+    ADD_TEST(test_lib_ctx_load_config);
     return 1;
 }
 
diff --git a/test/uitest.c b/test/uitest.c
index 9013126f7353..dae324b1f801 100644
--- a/test/uitest.c
+++ b/test/uitest.c
@@ -44,8 +44,8 @@ static int test_old(void)
     /* The wrapper passes the UI userdata as the callback userdata param */
     UI_add_user_data(ui, defpass);
 
-    if (!UI_add_input_string(ui, "prompt", UI_INPUT_FLAG_DEFAULT_PWD,
-                             pass, 0, sizeof(pass) - 1))
+    if (UI_add_input_string(ui, "prompt", UI_INPUT_FLAG_DEFAULT_PWD,
+                             pass, 0, sizeof(pass) - 1) <= 0)
         goto err;
 
     switch (UI_process(ui)) {
diff --git a/test/wpackettest.c b/test/wpackettest.c
index b03dfcd2e04e..8adac25bd563 100644
--- a/test/wpackettest.c
+++ b/test/wpackettest.c
@@ -386,7 +386,7 @@ static int test_WPACKET_init_der(void)
         return cleanup(&pkt);
 
     /* Generate random packet data for test */
-    if (!TEST_true(RAND_bytes(&testdata2[3], sizeof(testdata2) - 3)))
+    if (!TEST_int_gt(RAND_bytes(&testdata2[3], sizeof(testdata2) - 3), 0))
         return 0;
 
     /*
diff --git a/util/markdownlint.rb b/util/markdownlint.rb
index 159bf20870ec..51814c29f94e 100644
--- a/util/markdownlint.rb
+++ b/util/markdownlint.rb
@@ -21,3 +21,4 @@ exclude_rule 'MD024' # Multiple headers with the same content
 exclude_rule 'MD025' # Multiple top level headers in the same document
 exclude_rule 'MD026' # Trailing punctuation in header
 exclude_rule 'MD029' # Ordered list item prefix
+exclude_rule 'MD030' # Spaces after list markers (default: 1!)
diff --git a/util/mkdef.pl b/util/mkdef.pl
index a1c76f7c972e..c84fb3348d30 100755
--- a/util/mkdef.pl
+++ b/util/mkdef.pl
@@ -29,6 +29,7 @@ my $name = undef;               # internal library/module name
 my $ordinals_file = undef;      # the ordinals file to use
 my $version = undef;            # the version to use for the library
 my $OS = undef;                 # the operating system family
+my $type = 'lib';               # either lib or dso
 my $verbose = 0;
 my $ctest = 0;
 my $debug = 0;
@@ -40,6 +41,7 @@ GetOptions('name=s'     => \$name,
            'ordinals=s' => \$ordinals_file,
            'version=s'  => \$version,
            'OS=s'       => \$OS,
+           'type=s'     => \$type,
            'ctest'      => \$ctest,
            'verbose'    => \$verbose,
            # For VMS
@@ -48,6 +50,8 @@ GetOptions('name=s'     => \$name,
 
 die "Please supply arguments\n"
     unless $name && $ordinals_file && $OS;
+die "--type argument must be equal to 'lib' or 'dso'"
+    if $type ne 'lib' && $type ne 'dso';
 
 # When building a "variant" shared library, with a custom SONAME, also customize
 # all the symbol versions.  This produces a shared object that can coexist
@@ -101,7 +105,7 @@ die "Please supply arguments\n"
 #
 (my $SO_VARIANT = uc($target{"shlib_variant"} // '')) =~ s/\W/_/g;
 
-my $libname = platform->sharedname($name);
+my $libname = $type eq 'lib' ? platform->sharedname($name) : platform->dsoname($name);
 
 my %OS_data = (
     solaris     => { writer     => \&writer_linux,
diff --git a/util/perl/OpenSSL/config.pm b/util/perl/OpenSSL/config.pm
index 3748788eec6c..84485abae503 100755
--- a/util/perl/OpenSSL/config.pm
+++ b/util/perl/OpenSSL/config.pm
@@ -754,6 +754,7 @@ EOF
       [ 'ia64-.*-.*bsd.*',        { target => "BSD-ia64" } ],
       [ 'x86_64-.*-dragonfly.*',  { target => "BSD-x86_64" } ],
       [ 'amd64-.*-.*bsd.*',       { target => "BSD-x86_64" } ],
+      [ 'arm64-.*-.*bsd.*',       { target => "BSD-aarch64" } ],
       [ '.*86.*-.*-.*bsd.*',
         sub {
             # mimic ld behaviour when it's looking for libc...
